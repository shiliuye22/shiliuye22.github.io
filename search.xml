<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Pinia</title>
      <link href="/2023/04/01/pinia/"/>
      <url>/2023/04/01/pinia/</url>
      
        <content type="html"><![CDATA[<ul><li>介绍<ul><li>什么是 Pinia?<ul><li><a href="https://pinia.web3doc.top/introduction.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8-pinia%EF%BC%9F">为什么要使用 Pinia？</a></li><li><a href="https://pinia.web3doc.top/introduction.html#%E5%9F%BA%E6%9C%AC%E7%A4%BA%E4%BE%8B">基本示例</a></li><li><a href="https://pinia.web3doc.top/introduction.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF-pinia">为什么是 Pinia</a></li><li><a href="https://pinia.web3doc.top/introduction.html#%E4%B8%80%E4%B8%AA%E6%9B%B4%E7%8E%B0%E5%AE%9E%E7%9A%84%E4%BE%8B%E5%AD%90">一个更现实的例子</a></li><li>与 Vuex 的比较<ul><li><a href="https://pinia.web3doc.top/introduction.html#rfc">RFC</a></li><li><a href="https://pinia.web3doc.top/introduction.html#%E4%B8%8E-vuex-3-x-4-x-%E7%9A%84%E6%AF%94%E8%BE%83">与 Vuex 3.x&#x2F;4.x 的比较</a></li></ul></li></ul></li><li><a href="https://pinia.web3doc.top/getting-started.html">开始</a></li></ul></li><li>核心概念<ul><li><a href="https://pinia.web3doc.top/core-concepts/">定义一个 Store</a></li><li><a href="https://pinia.web3doc.top/core-concepts/state.html">State</a></li><li><a href="https://pinia.web3doc.top/core-concepts/getters.html">Getters</a></li><li><a href="https://pinia.web3doc.top/core-concepts/actions.html">Actions</a></li><li><a href="https://pinia.web3doc.top/core-concepts/plugins.html">Plugins</a></li><li><a href="https://pinia.web3doc.top/core-concepts/outside-component-usage.html">Stores outside of components</a></li></ul></li><li>服务端渲染 (SSR)<ul><li><a href="https://pinia.web3doc.top/ssr/">Vue and Vite</a></li><li><a href="https://pinia.web3doc.top/ssr/nuxt.html">Nuxt.js</a></li></ul></li><li>Cookbook<ul><li><a href="https://pinia.web3doc.top/cookbook/migration-vuex.html">从 Vuex ≤4 迁移</a></li><li><a href="https://pinia.web3doc.top/cookbook/hot-module-replacement.html">更换热更新</a></li><li><a href="https://pinia.web3doc.top/cookbook/testing.html">测试</a></li><li><a href="https://pinia.web3doc.top/cookbook/options-api.html">不使用 setup()</a></li><li><a href="https://pinia.web3doc.top/cookbook/composing-stores.html">Composing Stores</a></li><li><a href="https://pinia.web3doc.top/cookbook/migration-v1-v2.html">从 v0&#x2F;v1 迁移到 v2</a></li></ul></li></ul><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍#"></a>介绍<a href="https://pinia.web3doc.top/introduction.html#%E4%BB%8B%E7%BB%8D">#</a></h1><p><a href="https://vueschool.io/lessons/introduction-to-pinia?friend=vuerouter">Watch a free video lesson on Vue School</a></p><p>Pinia <a href="https://github.com/vuejs/pinia/commit/06aeef54e2cad66696063c62829dac74e15fd19e">最初是在 2019 年 11 月左右重新设计使用</a> <a href="https://github.com/vuejs/composition-api">Composition API</a> 。从那时起，最初的原则仍然相同，但 Pinia 对 Vue 2 和 Vue 3 都有效，并且不需要您使用组合 API。 除了安装和 SSR 之外，两者的 API 都是相同的，并且这些文档针对 Vue 3，并在必要时提供有关 Vue 2 的注释，以便 Vue 2 和 Vue 3 用户可以阅读！</p><h2 id="为什么要使用-Pinia？"><a href="#为什么要使用-Pinia？" class="headerlink" title="为什么要使用 Pinia？#"></a>为什么要使用 Pinia？<a href="https://pinia.web3doc.top/introduction.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8-pinia%EF%BC%9F">#</a></h2><p>Pinia 是 Vue 的存储库，它允许您跨组件&#x2F;页面共享状态。 如果您熟悉 Composition API，您可能会认为您已经可以通过一个简单的 <code>export const state = reactive(&#123;&#125;)</code>. 这对于单页应用程序来说是正确的，但如果它是服务器端呈现的，<strong>会使您的应用程序暴露于安全漏洞</strong>。 但即使在小型单页应用程序中，您也可以从使用 Pinia 中获得很多好处：</p><ul><li>dev-tools 支持<ul><li>跟踪动作、突变的时间线</li><li>Store 出现在使用它们的组件中</li><li>time travel 和 更容易的调试</li></ul></li><li>热模块更换<ul><li>在不重新加载页面的情况下修改您的 Store</li><li>在开发时保持任何现有状态</li></ul></li><li>插件：使用插件扩展 Pinia 功能</li><li>为 JS 用户提供适当的 TypeScript 支持或 <strong>autocompletion</strong></li><li>服务器端渲染支持</li></ul><h2 id="基本示例"><a href="#基本示例" class="headerlink" title="基本示例#"></a>基本示例<a href="https://pinia.web3doc.top/introduction.html#%E5%9F%BA%E6%9C%AC%E7%A4%BA%E4%BE%8B">#</a></h2><p>这就是使用 pinia 在 API 方面的样子（请务必查看 <a href="https://pinia.web3doc.top/getting-started.html">Getting Started</a> 以获取完整说明）。 您首先创建一个 Store ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// stores/counter.js</span><br><span class="line">import &#123; defineStore &#125; from &#x27;pinia&#x27;</span><br><span class="line"></span><br><span class="line">export const useCounterStore = defineStore(&#x27;counter&#x27;, &#123;</span><br><span class="line">  state: () =&gt; &#123;</span><br><span class="line">    return &#123; count: 0 &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  // 也可以定义为</span><br><span class="line">  // state: () =&gt; (&#123; count: 0 &#125;)</span><br><span class="line">  actions: &#123;</span><br><span class="line">    increment() &#123;</span><br><span class="line">      this.count++</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后你在一个组件中 <em>使用</em> 它：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useCounterStore &#125; from &#x27;@/stores/counter&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const counter = useCounterStore()</span><br><span class="line"></span><br><span class="line">    counter.count++</span><br><span class="line">    // 带自动补全 ✨</span><br><span class="line">    counter.$patch(&#123; count: counter.count + 1 &#125;)</span><br><span class="line">    // 或使用 action 代替</span><br><span class="line">    counter.increment()</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你甚至可以使用一个函数（类似于一个组件<code>setup()</code>）来为更高级的用例定义一个Store：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export const useCounterStore = defineStore(&#x27;counter&#x27;, () =&gt; &#123;</span><br><span class="line">  const count = ref(0)</span><br><span class="line">  function increment() &#123;</span><br><span class="line">    count.value++</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return &#123; count, increment &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如果你还不熟悉 <code>setup()</code> 和 Composition API，别担心，Pinia 也支持一组类似的 <a href="https://vuex.vuejs.org/guide/state.html#%E5%9C%B0%E5%9B%BE%E7%8A%B6%E6%80%81%E5%8A%A9%E6%89%8B"><em>map helpers</em> like Vuex</a>。 您以相同的方式定义存储，但随后使用 <code>mapStores()</code>、<code>mapState()</code> 或 <code>mapActions()</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">const useCounterStore = defineStore(&#x27;counter&#x27;, &#123;</span><br><span class="line">  state: () =&gt; (&#123; count: 0 &#125;),</span><br><span class="line">  getters: &#123;</span><br><span class="line">    double: (state) =&gt; state.count * 2,</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    increment() &#123;</span><br><span class="line">      this.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const useUserStore = defineStore(&#x27;user&#x27;, &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  computed: &#123;</span><br><span class="line">    // other computed properties</span><br><span class="line">    // ...</span><br><span class="line">    // gives access to this.counterStore and this.userStore</span><br><span class="line">    ...mapStores(useCounterStore, useUserStore)</span><br><span class="line">    // gives read access to this.count and this.double</span><br><span class="line">    ...mapState(useCounterStore, [&#x27;count&#x27;, &#x27;double&#x27;]),</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    // gives access to this.increment()</span><br><span class="line">    ...mapActions(useCounterStore, [&#x27;increment&#x27;]),</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您将在核心概念中找到有关每个 map helper 的更多信息。</p><h2 id="为什么是-Pinia"><a href="#为什么是-Pinia" class="headerlink" title="为什么是 Pinia#"></a>为什么是 <em>Pinia</em><a href="https://pinia.web3doc.top/introduction.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF-pinia">#</a></h2><p>Pinia（发音为 <code>/piːnjʌ/</code>，类似于英语中的“peenya”）是最接近有效包名 <em>piña</em>（西班牙语中的_pineapple_）的词。 菠萝实际上是一组单独的花朵，它们结合在一起形成多个水果。 与 Store 类似，每一家都是独立诞生的，但最终都是相互联系的。 它也是一种美味的热带水果，原产于南美洲。</p><h2 id="一个更现实的例子"><a href="#一个更现实的例子" class="headerlink" title="一个更现实的例子#"></a>一个更现实的例子<a href="https://pinia.web3doc.top/introduction.html#%E4%B8%80%E4%B8%AA%E6%9B%B4%E7%8E%B0%E5%AE%9E%E7%9A%84%E4%BE%8B%E5%AD%90">#</a></h2><p>这是一个更完整的 API 示例，您将与 Pinia 一起使用<strong>即使在 JavaScript 中也具有类型</strong>。 对于某些人来说，这可能足以在不进一步阅读的情况下开始使用，但我们仍然建议您查看文档的其余部分，甚至跳过此示例，并在阅读完所有_核心概念_后返回。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">import &#123; defineStore &#125; from &#x27;pinia&#x27;</span><br><span class="line"></span><br><span class="line">export const todos = defineStore(&#x27;todos&#x27;, &#123;</span><br><span class="line">  state: () =&gt; (&#123;</span><br><span class="line">    /** @type &#123;&#123; text: string, id: number, isFinished: boolean &#125;[]&#125; */</span><br><span class="line">    todos: [],</span><br><span class="line">    /** @type &#123;&#x27;all&#x27; | &#x27;finished&#x27; | &#x27;unfinished&#x27;&#125; */</span><br><span class="line">    filter: &#x27;all&#x27;,</span><br><span class="line">    // type 会自动推断为 number</span><br><span class="line">    nextId: 0,</span><br><span class="line">  &#125;),</span><br><span class="line">  getters: &#123;</span><br><span class="line">    finishedTodos(state) &#123;</span><br><span class="line">      // 自动完成! ✨</span><br><span class="line">      return state.todos.filter((todo) =&gt; todo.isFinished)</span><br><span class="line">    &#125;,</span><br><span class="line">    unfinishedTodos(state) &#123;</span><br><span class="line">      return state.todos.filter((todo) =&gt; !todo.isFinished)</span><br><span class="line">    &#125;,</span><br><span class="line">    /**</span><br><span class="line">     * @returns &#123;&#123; text: string, id: number, isFinished: boolean &#125;[]&#125;</span><br><span class="line">     */</span><br><span class="line">    filteredTodos(state) &#123;</span><br><span class="line">      if (this.filter === &#x27;finished&#x27;) &#123;</span><br><span class="line">        // 自动调用其他 getter ✨</span><br><span class="line">        return this.finishedTodos</span><br><span class="line">      &#125; else if (this.filter === &#x27;unfinished&#x27;) &#123;</span><br><span class="line">        return this.unfinishedTodos</span><br><span class="line">      &#125;</span><br><span class="line">      return this.todos</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    // 任何数量的参数，返回一个 Promise 或者不返回</span><br><span class="line">    addTodo(text) &#123;</span><br><span class="line">      // 你可以直接改变状态</span><br><span class="line">      this.todos.push(&#123; text, id: this.nextId++, isFinished: false &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="与-Vuex-的比较"><a href="#与-Vuex-的比较" class="headerlink" title="与 Vuex 的比较#"></a>与 Vuex 的比较<a href="https://pinia.web3doc.top/introduction.html#%E4%B8%8E-vuex-%E7%9A%84%E6%AF%94%E8%BE%83">#</a></h2><p>Pinia 最初是为了探索 Vuex 的下一次迭代会是什么样子，结合了 Vuex 5 核心团队讨论中的许多想法。最终，我们意识到 Pinia 已经实现了我们在 Vuex 5 中想要的大部分内容，并决定实现它 取而代之的是新的建议。</p><p>与 Vuex 相比，Pinia 提供了一个更简单的 API，具有更少的规范，提供了 Composition-API 风格的 API，最重要的是，在与 TypeScript 一起使用时具有可靠的类型推断支持。</p><h3 id="RFC"><a href="#RFC" class="headerlink" title="RFC#"></a>RFC<a href="https://pinia.web3doc.top/introduction.html#rfc">#</a></h3><p>虽然 Vuex 通过 RFC 从社区收集尽可能多的反馈，但 Pinia 没有。 我根据我开发应用程序、阅读其他人的代码、为使用 Pinia 的客户工作以及在 Discord 上回答问题的经验来测试想法。 这使我能够提供一种适用于各种情况和应用程序大小的有效解决方案。 我经常发布并在保持其核心 API 不变的同时使库不断发展。</p><h3 id="与-Vuex-3-x-x2F-4-x-的比较"><a href="#与-Vuex-3-x-x2F-4-x-的比较" class="headerlink" title="与 Vuex 3.x&#x2F;4.x 的比较#"></a>与 Vuex 3.x&#x2F;4.x 的比较<a href="https://pinia.web3doc.top/introduction.html#%E4%B8%8E-vuex-3-x-4-x-%E7%9A%84%E6%AF%94%E8%BE%83">#</a></h3><blockquote><p>Vuex 3.x 是 Vuex 的 Vue 2 而 Vuex 4.x 是 Vue 3</p></blockquote><p>Pinia API 与 Vuex ≤4 有很大不同，即：</p><ul><li><em>mutations</em> 不再存在。他们经常被认为是 *<strong>非常* 冗长</strong>。他们最初带来了 devtools 集成，但这不再是问题。</li><li>无需创建自定义复杂包装器来支持 TypeScript，所有内容都是类型化的，并且 API 的设计方式尽可能利用 TS 类型推断。</li><li>不再需要注入、导入函数、调用函数、享受自动完成功能！</li><li>无需动态添加 Store，默认情况下它们都是动态的，您甚至都不会注意到。请注意，您仍然可以随时手动使用 Store 进行注册，但因为它是自动的，您无需担心。</li><li>不再有 <em>modules</em> 的嵌套结构。您仍然可以通过在另一个 Store 中导入和 <em>使用</em> 来隐式嵌套 Store，但 Pinia 通过设计提供平面结构，同时仍然支持 Store 之间的交叉组合方式。 <strong>您甚至可以拥有 Store 的循环依赖关系</strong>。</li><li>没有 <em>命名空间模块</em>。鉴于 Store 的扁平架构，“命名空间” Store 是其定义方式所固有的，您可以说所有 Store 都是命名空间的。</li></ul><p>有关如何将现有 Vuex ≤4 项目转换为使用 Pinia 的更详细说明，请参阅<a href="https://pinia.web3doc.top/cookbook/migration-vuex.html">从 Vuex 迁移指南</a>。</p><p><a href="https://github.com/vuejs/pinia/edit/v2/packages/docs/introduction.md">Suggest changes to this page </a></p><p><a href="https://pinia.web3doc.top/getting-started">开始</a></p>]]></content>
      
      
      <categories>
          
          <category> -Pinia </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -标签4 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue2</title>
      <link href="/2023/04/01/vue2/"/>
      <url>/2023/04/01/vue2/</url>
      
        <content type="html"><![CDATA[<p>- </p><ul><li><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3></li><li><p><a href="https://v2.cn.vuejs.org/v2/guide/installation.html">安装</a></p></li><li><p>介绍</p><ul><li><a href="https://v2.cn.vuejs.org/v2/guide/#Vue-js-%E6%98%AF%E4%BB%80%E4%B9%88">Vue.js 是什么</a></li><li><a href="https://v2.cn.vuejs.org/v2/guide/#%E8%B5%B7%E6%AD%A5">起步</a></li><li><a href="https://v2.cn.vuejs.org/v2/guide/#%E5%A3%B0%E6%98%8E%E5%BC%8F%E6%B8%B2%E6%9F%93">声明式渲染</a></li><li><a href="https://v2.cn.vuejs.org/v2/guide/#%E6%9D%A1%E4%BB%B6%E4%B8%8E%E5%BE%AA%E7%8E%AF">条件与循环</a></li><li><a href="https://v2.cn.vuejs.org/v2/guide/#%E5%A4%84%E7%90%86%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5">处理用户输入</a></li><li>组件化应用构建<ul><li><a href="https://v2.cn.vuejs.org/v2/guide/#%E4%B8%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E5%85%83%E7%B4%A0%E7%9A%84%E5%85%B3%E7%B3%BB">与自定义元素的关系</a></li></ul></li><li><a href="https://v2.cn.vuejs.org/v2/guide/#%E5%87%86%E5%A4%87%E5%A5%BD%E4%BA%86%E5%90%97%EF%BC%9F">准备好了吗？</a></li></ul></li><li><p><a href="https://v2.cn.vuejs.org/v2/guide/instance.html">Vue 实例</a></p></li><li><p><a href="https://v2.cn.vuejs.org/v2/guide/syntax.html">模板语法</a></p></li><li><p><a href="https://v2.cn.vuejs.org/v2/guide/computed.html">计算属性和侦听器</a></p></li><li><p><a href="https://v2.cn.vuejs.org/v2/guide/class-and-style.html">Class 与 Style 绑定</a></p></li><li><p><a href="https://v2.cn.vuejs.org/v2/guide/conditional.html">条件渲染</a></p></li><li><p><a href="https://v2.cn.vuejs.org/v2/guide/list.html">列表渲染</a></p></li><li><p><a href="https://v2.cn.vuejs.org/v2/guide/events.html">事件处理</a></p></li><li><p><a href="https://v2.cn.vuejs.org/v2/guide/forms.html">表单输入绑定</a></p></li><li><p><a href="https://v2.cn.vuejs.org/v2/guide/components.html">组件基础</a></p></li><li><h3 id="深入了解组件"><a href="#深入了解组件" class="headerlink" title="深入了解组件"></a>深入了解组件</h3></li><li><p><a href="https://v2.cn.vuejs.org/v2/guide/components-registration.html">组件注册</a></p></li><li><p><a href="https://v2.cn.vuejs.org/v2/guide/components-props.html">Prop</a></p></li><li><p><a href="https://v2.cn.vuejs.org/v2/guide/components-custom-events.html">自定义事件</a></p></li><li><p><a href="https://v2.cn.vuejs.org/v2/guide/components-slots.html">插槽</a></p></li><li><p><a href="https://v2.cn.vuejs.org/v2/guide/components-dynamic-async.html">动态组件 &amp; 异步组件</a></p></li><li><p><a href="https://v2.cn.vuejs.org/v2/guide/components-edge-cases.html">处理边界情况</a></p></li><li><h3 id="过渡-amp-动画"><a href="#过渡-amp-动画" class="headerlink" title="过渡 &amp; 动画"></a>过渡 &amp; 动画</h3></li><li><p><a href="https://v2.cn.vuejs.org/v2/guide/transitions.html">进入&#x2F;离开 &amp; 列表过渡</a></p></li><li><p><a href="https://v2.cn.vuejs.org/v2/guide/transitioning-state.html">状态过渡</a></p></li><li><h3 id="可复用性-amp-组合"><a href="#可复用性-amp-组合" class="headerlink" title="可复用性 &amp; 组合"></a>可复用性 &amp; 组合</h3></li><li><p><a href="https://v2.cn.vuejs.org/v2/guide/mixins.html">混入</a></p></li><li><p><a href="https://v2.cn.vuejs.org/v2/guide/custom-directive.html">自定义指令</a></p></li><li><p><a href="https://v2.cn.vuejs.org/v2/guide/render-function.html">渲染函数 &amp; JSX</a></p></li><li><p><a href="https://v2.cn.vuejs.org/v2/guide/plugins.html">插件</a></p></li><li><p><a href="https://v2.cn.vuejs.org/v2/guide/filters.html">过滤器</a></p></li><li><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3></li><li><p><a href="https://v2.cn.vuejs.org/v2/guide/single-file-components.html">单文件组件</a></p></li><li><p><a href="https://v2.cn.vuejs.org/v2/guide/testing.html">测试</a></p></li><li><p><a href="https://v2.cn.vuejs.org/v2/guide/typescript.html">TypeScript 支持</a></p></li><li><p><a href="https://v2.cn.vuejs.org/v2/guide/deployment.html">生产环境部署</a></p></li><li><h3 id="规模化"><a href="#规模化" class="headerlink" title="规模化"></a>规模化</h3></li><li><p><a href="https://v2.cn.vuejs.org/v2/guide/routing.html">路由</a></p></li><li><p><a href="https://v2.cn.vuejs.org/v2/guide/state-management.html">状态管理</a></p></li><li><p><a href="https://v2.cn.vuejs.org/v2/guide/ssr.html">服务端渲染</a></p></li><li><p><a href="https://v2.cn.vuejs.org/v2/guide/security.html">安全</a></p></li><li><h3 id="内在"><a href="#内在" class="headerlink" title="内在"></a>内在</h3></li><li><p><a href="https://v2.cn.vuejs.org/v2/guide/reactivity.html">深入响应式原理</a></p></li><li><h3 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a>迁移</h3></li><li><p><a href="https://v2.cn.vuejs.org/v2/guide/migration.html">从 Vue 1.x 迁移</a></p></li><li><p><a href="https://v2.cn.vuejs.org/v2/guide/migration-vue-router.html">从 Vue Router 0.7.x 迁移</a></p></li><li><p><a href="https://v2.cn.vuejs.org/v2/guide/migration-vuex.html">从 Vuex 0.6.x 迁移到 1.0</a></p></li><li><p><a href="https://v2.cn.vuejs.org/v2/guide/migration-vue-2-7.html">迁移至 Vue 2.7</a></p></li><li><h3 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h3></li><li><p><a href="https://v2.cn.vuejs.org/v2/guide/comparison.html">对比其他框架</a></p></li><li><p><a href="https://v2.cn.vuejs.org/v2/guide/join.html">加入 Vue.js 社区</a></p></li><li><p><a href="https://v2.cn.vuejs.org/v2/guide/team.html">认识团队</a></p></li></ul><p>您正在浏览的是 Vue 2.x 的文档。Vue 3 的文档<a href="https://cn.vuejs.org/">在这里</a>。</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><h2 id="Vue-js-是什么"><a href="#Vue-js-是什么" class="headerlink" title="Vue.js 是什么"></a><a href="https://v2.cn.vuejs.org/v2/guide/#Vue-js-%E6%98%AF%E4%BB%80%E4%B9%88">Vue.js 是什么</a></h2><p><a href="https://learning.dcloud.io/#/?vid=0">观看本节视频讲解</a></p><p>Vue (读音 &#x2F;vjuː&#x2F;，类似于 <strong>view</strong>) 是一套用于构建用户界面的<strong>渐进式框架</strong>。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与<a href="https://v2.cn.vuejs.org/v2/guide/single-file-components.html">现代化的工具链</a>以及各种<a href="https://github.com/vuejs/awesome-vue#libraries--plugins">支持类库</a>结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</p><p>如果你想在深入学习 Vue 之前对它有更多了解，我们<a href="https://v2.cn.vuejs.org/v2/guide/#">制作了一个视频</a>，带您了解其核心概念和一个示例工程。</p><p>如果你已经是有经验的前端开发者，想知道 Vue 与其它库&#x2F;框架有哪些区别，请查看<a href="https://v2.cn.vuejs.org/v2/guide/comparison.html">对比其它框架</a>。</p><h2 id="起步"><a href="#起步" class="headerlink" title="起步"></a><a href="https://v2.cn.vuejs.org/v2/guide/#%E8%B5%B7%E6%AD%A5">起步</a></h2><p><a href="https://learning.dcloud.io/#/?vid=1">观看本节视频讲解</a></p><p>官方指南假设你已了解关于 HTML、CSS 和 JavaScript 的中级知识。如果你刚开始学习前端开发，将框架作为你的第一步可能不是最好的主意——掌握好基础知识再来吧！之前有其它框架的使用经验会有帮助，但这不是必需的。</p><p><a href="https://v2.cn.vuejs.org/v2/guide/installation.html">安装</a></p><p>尝试 Vue.js 最简单的方法是使用 <a href="https://codesandbox.io/s/github/vuejs/v2.vuejs.org/tree/master/src/v2/examples/vue-20-hello-world">Hello World 例子</a>。你可以在浏览器新标签页中打开它，跟着例子学习一些基础用法。或者你也可以<a href="https://github.com/vuejs/v2.vuejs.org/blob/master/src/v2/examples/vue-20-hello-world/index.html">创建一个 <code>.html</code> 文件</a>，然后通过如下方式引入 Vue：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span><br><span class="line">&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 生产环境版本，优化了尺寸和速度 --&gt;</span><br><span class="line">&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><a href="https://v2.cn.vuejs.org/guide/installation.html">安装教程</a>给出了更多安装 Vue 的方式。请注意我们<strong>不推荐</strong>新手直接使用 <code>vue-cli</code>，尤其是在你还不熟悉基于 Node.js 的构建工具时。</p><p>如果你喜欢交互式的东西，你也可以查阅<a href="https://scrimba.com/g/gvuedocs">这个 Scrimba 上的系列教程</a>，它揉合了录屏和代码试验田，并允许你随时暂停和播放。</p><h2 id="声明式渲染"><a href="#声明式渲染" class="headerlink" title="声明式渲染"></a><a href="https://v2.cn.vuejs.org/v2/guide/#%E5%A3%B0%E6%98%8E%E5%BC%8F%E6%B8%B2%E6%9F%93">声明式渲染</a></h2><p><a href="https://learning.dcloud.io/#/?vid=3">观看本节视频讲解</a></p><p>Vue.js 的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进 DOM 的系统：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &#123;&#123; message &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">var app = new Vue(&#123;</span><br><span class="line">  el: &#x27;#app&#x27;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: &#x27;Hello Vue!&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Hello Vue!</p><p>我们已经成功创建了第一个 Vue 应用！看起来这跟渲染一个字符串模板非常类似，但是 Vue 在背后做了大量工作。现在数据和 DOM 已经被建立了关联，所有东西都是<strong>响应式的</strong>。我们要怎么确认呢？打开你的浏览器的 JavaScript 控制台 (就在这个页面打开)，并修改 <code>app.message</code> 的值，你将看到上例相应地更新。</p><p>注意我们不再和 HTML 直接交互了。一个 Vue 应用会将其挂载到一个 DOM 元素上 (对于这个例子是 <code>#app</code>) 然后对其进行完全控制。那个 HTML 是我们的入口，但其余都会发生在新创建的 Vue 实例内部。</p><p>除了文本插值，我们还可以像这样来绑定元素 attribute：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app-2&quot;&gt;</span><br><span class="line">  &lt;span v-bind:title=&quot;message&quot;&gt;</span><br><span class="line">    鼠标悬停几秒钟查看此处动态绑定的提示信息！</span><br><span class="line">  &lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">var app2 = new Vue(&#123;</span><br><span class="line">  el: &#x27;#app-2&#x27;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: &#x27;页面加载于 &#x27; + new Date().toLocaleString()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>鼠标悬停几秒钟查看此处动态绑定的提示信息！</p><p>这里我们遇到了一点新东西。你看到的 <code>v-bind</code> attribute 被称为<strong>指令</strong>。指令带有前缀 <code>v-</code>，以表示它们是 Vue 提供的特殊 attribute。可能你已经猜到了，它们会在渲染的 DOM 上应用特殊的响应式行为。在这里，该指令的意思是：“将这个元素节点的 <code>title</code> attribute 和 Vue 实例的 <code>message</code> property 保持一致”。</p><p>如果你再次打开浏览器的 JavaScript 控制台，输入 <code>app2.message = &#39;新消息&#39;</code>，就会再一次看到这个绑定了 <code>title</code> attribute 的 HTML 已经进行了更新。</p><h2 id="条件与循环"><a href="#条件与循环" class="headerlink" title="条件与循环"></a><a href="https://v2.cn.vuejs.org/v2/guide/#%E6%9D%A1%E4%BB%B6%E4%B8%8E%E5%BE%AA%E7%8E%AF">条件与循环</a></h2><p><a href="https://learning.dcloud.io/#/?vid=8">观看本节视频讲解</a></p><p>控制切换一个元素是否显示也相当简单：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app-3&quot;&gt;</span><br><span class="line">  &lt;p v-if=&quot;seen&quot;&gt;现在你看到我了&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">var app3 = new Vue(&#123;</span><br><span class="line">  el: &#x27;#app-3&#x27;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    seen: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>现在你看到我了</p><p>继续在控制台输入 <code>app3.seen = false</code>，你会发现之前显示的消息消失了。</p><p>这个例子演示了我们不仅可以把数据绑定到 DOM 文本或 attribute，还可以绑定到 DOM <strong>结构</strong>。此外，Vue 也提供一个强大的过渡效果系统，可以在 Vue 插入&#x2F;更新&#x2F;移除元素时自动应用<a href="https://v2.cn.vuejs.org/v2/guide/transitions.html">过渡效果</a>。</p><p>还有其它很多指令，每个都有特殊的功能。例如，<code>v-for</code> 指令可以绑定数组的数据来渲染一个项目列表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app-4&quot;&gt;</span><br><span class="line">  &lt;ol&gt;</span><br><span class="line">    &lt;li v-for=&quot;todo in todos&quot;&gt;</span><br><span class="line">      &#123;&#123; todo.text &#125;&#125;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">  &lt;/ol&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">var app4 = new Vue(&#123;</span><br><span class="line">  el: &#x27;#app-4&#x27;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    todos: [</span><br><span class="line">      &#123; text: &#x27;学习 JavaScript&#x27; &#125;,</span><br><span class="line">      &#123; text: &#x27;学习 Vue&#x27; &#125;,</span><br><span class="line">      &#123; text: &#x27;整个牛项目&#x27; &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol><li>学习 JavaScript</li><li>学习 Vue</li><li>整个牛项目</li></ol><p>在控制台里，输入 <code>app4.todos.push(&#123; text: &#39;新项目&#39; &#125;)</code>，你会发现列表最后添加了一个新项目。</p><h2 id="处理用户输入"><a href="#处理用户输入" class="headerlink" title="处理用户输入"></a><a href="https://v2.cn.vuejs.org/v2/guide/#%E5%A4%84%E7%90%86%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5">处理用户输入</a></h2><p><a href="https://learning.dcloud.io/#/?vid=11">观看本节视频讲解</a></p><p>为了让用户和你的应用进行交互，我们可以用 <code>v-on</code> 指令添加一个事件监听器，通过它调用在 Vue 实例中定义的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app-5&quot;&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;button v-on:click=&quot;reverseMessage&quot;&gt;反转消息&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">var app5 = new Vue(&#123;</span><br><span class="line">  el: &#x27;#app-5&#x27;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: &#x27;Hello Vue.js!&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    reverseMessage: function () &#123;</span><br><span class="line">      this.message = this.message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Hello Vue.js!</p><p>反转消息</p><p>注意在 <code>reverseMessage</code> 方法中，我们更新了应用的状态，但没有触碰 DOM——所有的 DOM 操作都由 Vue 来处理，你编写的代码只需要关注逻辑层面即可。</p><p>Vue 还提供了 <code>v-model</code> 指令，它能轻松实现表单输入和应用状态之间的双向绑定。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app-6&quot;&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;input v-model=&quot;message&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">var app6 = new Vue(&#123;</span><br><span class="line">  el: &#x27;#app-6&#x27;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: &#x27;Hello Vue!&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Hello Vue!</p><h2 id="组件化应用构建"><a href="#组件化应用构建" class="headerlink" title="组件化应用构建"></a><a href="https://v2.cn.vuejs.org/v2/guide/#%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BA%94%E7%94%A8%E6%9E%84%E5%BB%BA">组件化应用构建</a></h2><p><a href="https://learning.dcloud.io/#/?vid=12">观看本节视频讲解</a></p><p>组件系统是 Vue 的另一个重要概念，因为它是一种抽象，允许我们使用小型、独立和通常可复用的组件构建大型应用。仔细想想，几乎任意类型的应用界面都可以抽象为一个组件树：</p><p><img src="https://v2.cn.vuejs.org/images/components.png" alt="Component Tree"></p><p>在 Vue 里，一个组件本质上是一个拥有预定义选项的一个 Vue 实例。在 Vue 中注册组件很简单：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 定义名为 todo-item 的新组件</span><br><span class="line">Vue.component(&#x27;todo-item&#x27;, &#123;</span><br><span class="line">  template: &#x27;&lt;li&gt;这是个待办项&lt;/li&gt;&#x27;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">var app = new Vue(...)</span><br></pre></td></tr></table></figure><p>现在你可以用它构建另一个组件模板：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;ol&gt;</span><br><span class="line">  &lt;!-- 创建一个 todo-item 组件的实例 --&gt;</span><br><span class="line">  &lt;todo-item&gt;&lt;/todo-item&gt;</span><br><span class="line">&lt;/ol&gt;</span><br></pre></td></tr></table></figure><p>但是这样会为每个待办项渲染同样的文本，这看起来并不炫酷。我们应该能从父作用域将数据传到子组件才对。让我们来修改一下组件的定义，使之能够接受一个 <a href="https://v2.cn.vuejs.org/v2/guide/components.html#%E9%80%9A%E8%BF%87-Prop-%E5%90%91%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE">prop</a>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&#x27;todo-item&#x27;, &#123;</span><br><span class="line">  // todo-item 组件现在接受一个</span><br><span class="line">  // &quot;prop&quot;，类似于一个自定义 attribute。</span><br><span class="line">  // 这个 prop 名为 todo。</span><br><span class="line">  props: [&#x27;todo&#x27;],</span><br><span class="line">  template: &#x27;&lt;li&gt;&#123;&#123; todo.text &#125;&#125;&lt;/li&gt;&#x27;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>现在，我们可以使用 <code>v-bind</code> 指令将待办项传到循环输出的每个组件中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app-7&quot;&gt;</span><br><span class="line">  &lt;ol&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">      现在我们为每个 todo-item 提供 todo 对象</span><br><span class="line">      todo 对象是变量，即其内容可以是动态的。</span><br><span class="line">      我们也需要为每个组件提供一个“key”，稍后再</span><br><span class="line">      作详细解释。</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;todo-item</span><br><span class="line">      v-for=&quot;item in groceryList&quot;</span><br><span class="line">      v-bind:todo=&quot;item&quot;</span><br><span class="line">      v-bind:key=&quot;item.id&quot;</span><br><span class="line">    &gt;&lt;/todo-item&gt;</span><br><span class="line">  &lt;/ol&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">Vue.component(&#x27;todo-item&#x27;, &#123;</span><br><span class="line">  props: [&#x27;todo&#x27;],</span><br><span class="line">  template: &#x27;&lt;li&gt;&#123;&#123; todo.text &#125;&#125;&lt;/li&gt;&#x27;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">var app7 = new Vue(&#123;</span><br><span class="line">  el: &#x27;#app-7&#x27;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    groceryList: [</span><br><span class="line">      &#123; id: 0, text: &#x27;蔬菜&#x27; &#125;,</span><br><span class="line">      &#123; id: 1, text: &#x27;奶酪&#x27; &#125;,</span><br><span class="line">      &#123; id: 2, text: &#x27;随便其它什么人吃的东西&#x27; &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol><li>蔬菜</li><li>奶酪</li><li>随便其它什么人吃的东西</li></ol><p>尽管这只是一个刻意设计的例子，但是我们已经设法将应用分割成了两个更小的单元。子单元通过 prop 接口与父单元进行了良好的解耦。我们现在可以进一步改进 <code>&lt;todo-item&gt;</code> 组件，提供更为复杂的模板和逻辑，而不会影响到父单元。</p><p>在一个大型应用中，有必要将整个应用程序划分为组件，以使开发更易管理。在<a href="https://v2.cn.vuejs.org/v2/guide/components.html">后续教程</a>中我们将详述组件，不过这里有一个 (假想的) 例子，以展示使用了组件的应用模板是什么样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;app-nav&gt;&lt;/app-nav&gt;</span><br><span class="line">  &lt;app-view&gt;</span><br><span class="line">    &lt;app-sidebar&gt;&lt;/app-sidebar&gt;</span><br><span class="line">    &lt;app-content&gt;&lt;/app-content&gt;</span><br><span class="line">  &lt;/app-view&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h3 id="与自定义元素的关系"><a href="#与自定义元素的关系" class="headerlink" title="与自定义元素的关系"></a><a href="https://v2.cn.vuejs.org/v2/guide/#%E4%B8%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E5%85%83%E7%B4%A0%E7%9A%84%E5%85%B3%E7%B3%BB">与自定义元素的关系</a></h3><p>你可能已经注意到 Vue 组件非常类似于<strong>自定义元素</strong>——它是 <a href="https://www.w3.org/wiki/WebComponents/">Web 组件规范</a>的一部分，这是因为 Vue 的组件语法部分参考了该规范。例如 Vue 组件实现了 <a href="https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md">Slot API</a> 与 <code>is</code> attribute。但是，还是有几个关键差别：</p><ol><li>Web Components 规范已经完成并通过，但未被所有浏览器原生实现。目前 Safari 10.1+、Chrome 54+ 和 Firefox 63+ 原生支持 Web Components。相比之下，Vue 组件不需要任何 polyfill，并且在所有支持的浏览器 (IE9 及更高版本) 之下表现一致。必要时，Vue 组件也可以包装于原生自定义元素之内。</li><li>Vue 组件提供了纯自定义元素所不具备的一些重要功能，最突出的是跨组件数据流、自定义事件通信以及构建工具集成。</li></ol><p>虽然 Vue 内部没有使用自定义元素，不过在应用使用自定义元素、或以自定义元素形式发布时，<a href="https://custom-elements-everywhere.com/#vue">依然有很好的互操作性</a>。Vue CLI 也支持将 Vue 组件构建成为原生的自定义元素。</p><h2 id="准备好了吗？"><a href="#准备好了吗？" class="headerlink" title="准备好了吗？"></a><a href="https://v2.cn.vuejs.org/v2/guide/#%E5%87%86%E5%A4%87%E5%A5%BD%E4%BA%86%E5%90%97%EF%BC%9F">准备好了吗？</a></h2><p>我们刚才简单介绍了 Vue 核心最基本的功能——本教程的其余部分将更加详细地涵盖这些功能以及其它高级功能，所以请务必读完整个教程！</p><p>← <a href="https://v2.cn.vuejs.org/v2/guide/installation.html">安装</a><a href="https://v2.cn.vuejs.org/v2/guide/instance.html">Vue 实例</a> →</p><p>发现错误？想参与编辑？ <a href="https://github.com/vuejs/v2.cn.vuejs.org/blob/master/src/v2/guide/index.md">在 GitHub 上编辑此页！</a></p>]]></content>
      
      
      <categories>
          
          <category> -Vue2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -标签2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue3</title>
      <link href="/2023/04/01/vue3/"/>
      <url>/2023/04/01/vue3/</url>
      
        <content type="html"><![CDATA[<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p><a href="https://cn.vuejs.org/guide/introduction.html">简介</a><a href="https://cn.vuejs.org/guide/quick-start.html">快速上手</a></p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p><a href="https://cn.vuejs.org/guide/essentials/application.html">创建一个应用</a><a href="https://cn.vuejs.org/guide/essentials/template-syntax.html">模板语法</a><a href="https://cn.vuejs.org/guide/essentials/reactivity-fundamentals.html">响应式基础</a><a href="https://cn.vuejs.org/guide/essentials/computed.html">计算属性</a><a href="https://cn.vuejs.org/guide/essentials/class-and-style.html">类与样式绑定</a><a href="https://cn.vuejs.org/guide/essentials/conditional.html">条件渲染</a><a href="https://cn.vuejs.org/guide/essentials/list.html">列表渲染</a><a href="https://cn.vuejs.org/guide/essentials/event-handling.html">事件处理</a><a href="https://cn.vuejs.org/guide/essentials/forms.html">表单输入绑定</a><a href="https://cn.vuejs.org/guide/essentials/lifecycle.html">生命周期</a><a href="https://cn.vuejs.org/guide/essentials/watchers.html">侦听器</a><a href="https://cn.vuejs.org/guide/essentials/template-refs.html">模板引用</a><a href="https://cn.vuejs.org/guide/essentials/component-basics.html">组件基础</a></p><h2 id="深入组件"><a href="#深入组件" class="headerlink" title="深入组件"></a>深入组件</h2><p><a href="https://cn.vuejs.org/guide/components/registration.html">注册</a><a href="https://cn.vuejs.org/guide/components/props.html">Props</a><a href="https://cn.vuejs.org/guide/components/events.html">事件</a><a href="https://cn.vuejs.org/guide/components/v-model.html">组件 v-model</a><a href="https://cn.vuejs.org/guide/components/attrs.html">透传 Attributes</a><a href="https://cn.vuejs.org/guide/components/slots.html">插槽</a><a href="https://cn.vuejs.org/guide/components/provide-inject.html">依赖注入</a><a href="https://cn.vuejs.org/guide/components/async.html">异步组件</a></p><h2 id="逻辑复用"><a href="#逻辑复用" class="headerlink" title="逻辑复用"></a>逻辑复用</h2><p><a href="https://cn.vuejs.org/guide/reusability/composables.html">组合式函数</a><a href="https://cn.vuejs.org/guide/reusability/custom-directives.html">自定义指令</a><a href="https://cn.vuejs.org/guide/reusability/plugins.html">插件</a></p><h2 id="内置组件"><a href="#内置组件" class="headerlink" title="内置组件"></a>内置组件</h2><p><a href="https://cn.vuejs.org/guide/built-ins/transition.html">Transition</a><a href="https://cn.vuejs.org/guide/built-ins/transition-group.html">TransitionGroup</a><a href="https://cn.vuejs.org/guide/built-ins/keep-alive.html">KeepAlive</a><a href="https://cn.vuejs.org/guide/built-ins/teleport.html">Teleport</a><a href="https://cn.vuejs.org/guide/built-ins/suspense.html">Suspense</a></p><h2 id="应用规模化"><a href="#应用规模化" class="headerlink" title="应用规模化"></a>应用规模化</h2><p><a href="https://cn.vuejs.org/guide/scaling-up/sfc.html">单文件组件</a><a href="https://cn.vuejs.org/guide/scaling-up/tooling.html">工具链</a><a href="https://cn.vuejs.org/guide/scaling-up/routing.html">路由</a><a href="https://cn.vuejs.org/guide/scaling-up/state-management.html">状态管理</a><a href="https://cn.vuejs.org/guide/scaling-up/testing.html">测试</a><a href="https://cn.vuejs.org/guide/scaling-up/ssr.html">服务端渲染 (SSR)</a></p><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p><a href="https://cn.vuejs.org/guide/best-practices/production-deployment.html">生产部署</a><a href="https://cn.vuejs.org/guide/best-practices/performance.html">性能优化</a><a href="https://cn.vuejs.org/guide/best-practices/accessibility.html">无障碍访问</a><a href="https://cn.vuejs.org/guide/best-practices/security.html">安全</a></p><h2 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h2><p><a href="https://cn.vuejs.org/guide/typescript/overview.html">总览</a><a href="https://cn.vuejs.org/guide/typescript/composition-api.html">TS 与组合式 API</a><a href="https://cn.vuejs.org/guide/typescript/options-api.html">TS 与选项式 API</a></p><h2 id="进阶主题"><a href="#进阶主题" class="headerlink" title="进阶主题"></a>进阶主题</h2><p>你正在阅读的是 Vue 3 的文档！</p><ul><li>Vue 2 将于 2023 年 12 月 31 日停止维护。详见 <a href="https://v2.vuejs.org/lts/">Vue 2 延长 LTS</a>。</li><li>Vue 2 中文文档已迁移至 <a href="https://v2.cn.vuejs.org/">v2.cn.vuejs.org</a>。</li><li>想从 Vue 2 升级？请参考<a href="https://v3-migration.vuejs.org/">迁移指南</a>。</li></ul><h2 id="什么是-Vue？"><a href="#什么是-Vue？" class="headerlink" title="什么是 Vue？"></a>什么是 Vue？<a href="https://cn.vuejs.org/guide/introduction.html#what-is-vue"></a></h2><p>Vue (发音为 &#x2F;vjuː&#x2F;，类似 <strong>view</strong>) 是一款用于构建用户界面的 JavaScript 框架。它基于标准 HTML、CSS 和 JavaScript 构建，并提供了一套声明式的、组件化的编程模型，帮助你高效地开发用户界面。无论是简单还是复杂的界面，Vue 都可以胜任。</p><p>下面是一个最基本的示例：</p><p>js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createApp &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">createApp(&#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      count: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).mount(&#x27;#app&#x27;)</span><br></pre></td></tr></table></figure><p>template</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;button @click=&quot;count++&quot;&gt;</span><br><span class="line">    Count is: &#123;&#123; count &#125;&#125;</span><br><span class="line">  &lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><strong>结果展示</strong></p><p>Count is: 0</p><p>上面的示例展示了 Vue 的两个核心功能：</p><ul><li><strong>声明式渲染</strong>：Vue 基于标准 HTML 拓展了一套模板语法，使得我们可以声明式地描述最终输出的 HTML 和 JavaScript 状态之间的关系。</li><li><strong>响应性</strong>：Vue 会自动跟踪 JavaScript 状态并在其发生变化时响应式地更新 DOM。</li></ul><p>你可能已经有了些疑问——先别急，在后续的文档中我们会详细介绍每一个细节。现在，请继续看下去，以确保你对 Vue 作为一个框架到底提供了什么有一个宏观的了解。</p><p>预备知识</p><p>文档接下来的内容会假设你对 HTML、CSS 和 JavaScript 已经基本熟悉。如果你对前端开发完全陌生，最好不要直接从一个框架开始进行入门学习——最好是掌握了基础知识再回到这里。你可以通过这篇 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/A_re-introduction_to_JavaScript">JavaScript 概述</a>来检验你的 JavaScript 知识水平。如果之前有其他框架的经验会很有帮助，但也不是必须的。</p><h2 id="渐进式框架"><a href="#渐进式框架" class="headerlink" title="渐进式框架"></a>渐进式框架<a href="https://cn.vuejs.org/guide/introduction.html#the-progressive-framework"></a></h2><p>Vue 是一个框架，也是一个生态。其功能覆盖了大部分前端开发常见的需求。但 Web 世界是十分多样化的，不同的开发者在 Web 上构建的东西可能在形式和规模上会有很大的不同。考虑到这一点，Vue 的设计非常注重灵活性和“可以被逐步集成”这个特点。根据你的需求场景，你可以用不同的方式使用 Vue：</p><ul><li>无需构建步骤，渐进式增强静态的 HTML</li><li>在任何页面中作为 Web Components 嵌入</li><li>单页应用 (SPA)</li><li>全栈 &#x2F; 服务端渲染 (SSR)</li><li>Jamstack &#x2F; 静态站点生成 (SSG)</li><li>开发桌面端、移动端、WebGL，甚至是命令行终端中的界面</li></ul><p>如果你是初学者，可能会觉得这些概念有些复杂。别担心！理解教程和指南的内容只需要具备基础的 HTML 和 JavaScript 知识。即使你不是这些方面的专家，也能够跟得上。</p><p>如果你是有经验的开发者，希望了解如何以最合适的方式在项目中引入 Vue，或者是对上述的这些概念感到好奇，我们在<a href="https://cn.vuejs.org/guide/extras/ways-of-using-vue.html">使用 Vue 的多种方式</a>中讨论了有关它们的更多细节。</p><p>无论再怎么灵活，Vue 的核心知识在所有这些用例中都是通用的。即使你现在只是一个初学者，随着你的不断成长，到未来有能力实现更复杂的项目时，这一路上获得的知识依然会适用。如果你已经是一个老手，你可以根据实际场景来选择使用 Vue 的最佳方式，在各种场景下都可以保持同样的开发效率。这就是为什么我们将 Vue 称为“渐进式框架”：它是一个可以与你共同成长、适应你不同需求的框架。</p><h2 id="单文件组件"><a href="#单文件组件" class="headerlink" title="单文件组件"></a>单文件组件<a href="https://cn.vuejs.org/guide/introduction.html#single-file-components"></a></h2><p>在大多数启用了构建工具的 Vue 项目中，我们可以使用一种类似 HTML 格式的文件来书写 Vue 组件，它被称为<strong>单文件组件</strong> (也被称为 <code>*.vue</code> 文件，英文 Single-File Components，缩写为 <strong>SFC</strong>)。顾名思义，Vue 的单文件组件会将一个组件的逻辑 (JavaScript)，模板 (HTML) 和样式 (CSS) 封装在同一个文件里。下面我们将用单文件组件的格式重写上面的计数器示例：</p><p>vue</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      count: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button @click=&quot;count++&quot;&gt;Count is: &#123;&#123; count &#125;&#125;&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">button &#123;</span><br><span class="line">  font-weight: bold;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>单文件组件是 Vue 的标志性功能。如果你的用例需要进行构建，我们推荐用它来编写 Vue 组件。你可以在后续相关章节里了解更多关于<a href="https://cn.vuejs.org/guide/scaling-up/sfc.html">单文件组件的用法及用途</a>。但你暂时只需要知道 Vue 会帮忙处理所有这些构建工具的配置就好。</p><h2 id="API-风格"><a href="#API-风格" class="headerlink" title="API 风格"></a>API 风格<a href="https://cn.vuejs.org/guide/introduction.html#api-styles"></a></h2><p>Vue 的组件可以按两种不同的风格书写：<strong>选项式 API</strong> 和<strong>组合式 API</strong>。</p><h3 id="选项式-API-Options-API"><a href="#选项式-API-Options-API" class="headerlink" title="选项式 API (Options API)"></a>选项式 API (Options API)<a href="https://cn.vuejs.org/guide/introduction.html#options-api"></a></h3><p>使用选项式 API，我们可以用包含多个选项的对象来描述组件的逻辑，例如 <code>data</code>、<code>methods</code> 和 <code>mounted</code>。选项所定义的属性都会暴露在函数内部的 <code>this</code> 上，它会指向当前的组件实例。</p><p>vue</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  // data() 返回的属性将会成为响应式的状态</span><br><span class="line">  // 并且暴露在 `this` 上</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      count: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // methods 是一些用来更改状态与触发更新的函数</span><br><span class="line">  // 它们可以在模板中作为事件监听器绑定</span><br><span class="line">  methods: &#123;</span><br><span class="line">    increment() &#123;</span><br><span class="line">      this.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // 生命周期钩子会在组件生命周期的各个不同阶段被调用</span><br><span class="line">  // 例如这个函数就会在组件挂载完成后被调用</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    console.log(`The initial count is $&#123;this.count&#125;.`)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button @click=&quot;increment&quot;&gt;Count is: &#123;&#123; count &#125;&#125;&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p><a href="https://sfc.vuejs.org/#eyJBcHAudnVlIjoiPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgLy8gcmVhY3RpdmUgc3RhdGVcbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY291bnQ6IDBcbiAgICB9XG4gIH0sXG5cbiAgLy8gZnVuY3Rpb25zIHRoYXQgbXV0YXRlIHN0YXRlIGFuZCB0cmlnZ2VyIHVwZGF0ZXNcbiAgbWV0aG9kczoge1xuICAgIGluY3JlbWVudCgpIHtcbiAgICAgIHRoaXMuY291bnQrK1xuICAgIH1cbiAgfSxcblxuICAvLyBsaWZlY3ljbGUgaG9va3NcbiAgbW91bnRlZCgpIHtcbiAgICBjb25zb2xlLmxvZyhgVGhlIGluaXRpYWwgY291bnQgaXMgJHt0aGlzLmNvdW50fS5gKVxuICB9XG59XG48L3NjcmlwdD5cblxuPHRlbXBsYXRlPlxuICA8YnV0dG9uIEBjbGljaz1cImluY3JlbWVudFwiPkNvdW50IGlzOiB7eyBjb3VudCB9fTwvYnV0dG9uPlxuPC90ZW1wbGF0ZT4ifQ==">在演练场中尝试一下</a></p><h3 id="组合式-API-Composition-API"><a href="#组合式-API-Composition-API" class="headerlink" title="组合式 API (Composition API)"></a>组合式 API (Composition API)<a href="https://cn.vuejs.org/guide/introduction.html#composition-api"></a></h3><p>通过组合式 API，我们可以使用导入的 API 函数来描述组件逻辑。在单文件组件中，组合式 API 通常会与 <a href="https://cn.vuejs.org/api/sfc-script-setup.html">&#96;&#96;</a> 搭配使用。这个 <code>setup</code> attribute 是一个标识，告诉 Vue 需要在编译时进行一些处理，让我们可以更简洁地使用组合式 API。比如，<code>&lt;script setup&gt;</code> 中的导入和顶层变量&#x2F;函数都能够在模板中直接使用。</p><p>下面是使用了组合式 API 与 <code>&lt;script setup&gt;</code> 改造后和上面的模板完全一样的组件：</p><p>vue</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref, onMounted &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">// 响应式状态</span><br><span class="line">const count = ref(0)</span><br><span class="line"></span><br><span class="line">// 用来修改状态、触发更新的函数</span><br><span class="line">function increment() &#123;</span><br><span class="line">  count.value++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 生命周期钩子</span><br><span class="line">onMounted(() =&gt; &#123;</span><br><span class="line">  console.log(`The initial count is $&#123;count.value&#125;.`)</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button @click=&quot;increment&quot;&gt;Count is: &#123;&#123; count &#125;&#125;&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p><a href="https://sfc.vuejs.org/#eyJBcHAudnVlIjoiPHNjcmlwdCBzZXR1cD5cbmltcG9ydCB7IHJlZiwgb25Nb3VudGVkIH0gZnJvbSAndnVlJ1xuXG4vLyByZWFjdGl2ZSBzdGF0ZVxuY29uc3QgY291bnQgPSByZWYoMClcblxuLy8gZnVuY3Rpb25zIHRoYXQgbXV0YXRlIHN0YXRlIGFuZCB0cmlnZ2VyIHVwZGF0ZXNcbmZ1bmN0aW9uIGluY3JlbWVudCgpIHtcbiAgY291bnQudmFsdWUrK1xufVxuXG4vLyBsaWZlY3ljbGUgaG9va3Ncbm9uTW91bnRlZCgoKSA9PiB7XG4gIGNvbnNvbGUubG9nKGBUaGUgaW5pdGlhbCBjb3VudCBpcyAke2NvdW50LnZhbHVlfS5gKVxufSlcbjwvc2NyaXB0PlxuXG48dGVtcGxhdGU+XG4gIDxidXR0b24gQGNsaWNrPVwiaW5jcmVtZW50XCI+Q291bnQgaXM6IHt7IGNvdW50IH19PC9idXR0b24+XG48L3RlbXBsYXRlPiJ9">在演练场中尝试一下</a></p><h3 id="该选哪一个？"><a href="#该选哪一个？" class="headerlink" title="该选哪一个？"></a>该选哪一个？<a href="https://cn.vuejs.org/guide/introduction.html#which-to-choose"></a></h3><p>两种 API 风格都能够覆盖大部分的应用场景。它们只是同一个底层系统所提供的两套不同的接口。实际上，选项式 API 是在组合式 API 的基础上实现的！关于 Vue 的基础概念和知识在它们之间都是通用的。</p><p>选项式 API 以“组件实例”的概念为中心 (即上述例子中的 <code>this</code>)，对于有面向对象语言背景的用户来说，这通常与基于类的心智模型更为一致。同时，它将响应性相关的细节抽象出来，并强制按照选项来组织代码，从而对初学者而言更为友好。</p><p>组合式 API 的核心思想是直接在函数作用域内定义响应式状态变量，并将从多个函数中得到的状态组合起来处理复杂问题。这种形式更加自由，也需要你对 Vue 的响应式系统有更深的理解才能高效使用。相应的，它的灵活性也使得组织和重用逻辑的模式变得更加强大。</p><p>在<a href="https://cn.vuejs.org/guide/extras/composition-api-faq.html">组合式 API FAQ</a> 章节中，你可以了解更多关于这两种 API 风格的对比以及组合式 API 所带来的潜在收益。</p><p>如果你是使用 Vue 的新手，这里是我们的大致建议：</p><ul><li>在学习的过程中，推荐采用更易于自己理解的风格。再强调一下，大部分的核心概念在这两种风格之间都是通用的。熟悉了一种风格以后，你也能够很快地理解另一种风格。</li><li>在生产项目中：<ul><li>当你不需要使用构建工具，或者打算主要在低复杂度的场景中使用 Vue，例如渐进增强的应用场景，推荐采用选项式 API。</li><li>当你打算用 Vue 构建完整的单页应用，推荐采用组合式 API + 单文件组件。</li></ul></li></ul><p>在学习阶段，你不必只固守一种风格。在接下来的文档中我们会为你提供一系列两种风格的代码供你参考，你可以随时通过左上角的 <strong>API 风格偏好</strong>来做切换。</p><h2 id="还有其他问题？"><a href="#还有其他问题？" class="headerlink" title="还有其他问题？"></a>还有其他问题？<a href="https://cn.vuejs.org/guide/introduction.html#still-got-questions"></a></h2><p>请查看我们的 <a href="https://cn.vuejs.org/about/faq.html">FAQ</a>。</p><h2 id="选择你的学习路径"><a href="#选择你的学习路径" class="headerlink" title="选择你的学习路径"></a>选择你的学习路径<a href="https://cn.vuejs.org/guide/introduction.html#pick-your-learning-path"></a></h2><p>不同的开发者有不同的学习方式。尽管在可能的情况下，我们推荐你通读所有内容，但你还是可以自由地选择一种自己喜欢的学习路径！</p><p><a href="https://cn.vuejs.org/tutorial/">尝试互动教程适合喜欢边动手边学的读者。</a><a href="https://cn.vuejs.org/guide/quick-start.html">继续阅读该指南该指南会带你深入了解框架所有方面的细节。</a><a href="https://cn.vuejs.org/examples/">查看示例浏览核心功能和常见用户界面的示例。</a></p><p><a href="https://github.com/vuejs-translations/docs-zh-cn/edit/main/src/guide/introduction.md">在 GitHub 上编辑此页</a></p><p>简介已经加载完毕</p>]]></content>
      
      
      <categories>
          
          <category> -Vue3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -标签3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三篇文章</title>
      <link href="/2023/01/01/ts/"/>
      <url>/2023/01/01/ts/</url>
      
        <content type="html"><![CDATA[<p>- </p><h1 id="ts保姆级教程，别再说你不会ts了"><a href="#ts保姆级教程，别再说你不会ts了" class="headerlink" title="ts保姆级教程，别再说你不会ts了"></a>ts保姆级教程，别再说你不会ts了</h1><h2 id="什么是-TypeScript？"><a href="#什么是-TypeScript？" class="headerlink" title="什么是 TypeScript？"></a>什么是 TypeScript？</h2><p>TypeScript，简称 ts，是微软开发的一种静态的编程语言，它是 JavaScript 的超集。 那么它有什么特别之处呢?</p><ol><li>简单来说，js 有的 ts 都有，所有js 代码都可以在 ts 里面运行。</li><li>ts 支持类型支持，ts &#x3D; type +JavaScript。</li></ol><h3 id="那么-ts-和-js-有什么区别呢？"><a href="#那么-ts-和-js-有什么区别呢？" class="headerlink" title="那么 ts 和 js 有什么区别呢？"></a>那么 ts 和 js 有什么区别呢？</h3><ol><li>JavaScript 属于动态编程语言，而ts 属于静态编程语言。<ul><li>js：边解释边执行，错误只有在运行的时候才能发现</li><li>ts：先编译再执行，在写的时候就会发现错误了（ts不能直接执行，需要先编译成 js ）</li></ul></li><li>ts 完全支持 js ，可以直接转换<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5d0d6b78251046b8a9ee624708709317~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="在这里插入图片描述"></li><li>ts 有类型支持，有强大的代码类型提示</li></ol><p>相信大家现在对 ts 有一个基本的了解了，那么它应该怎么使用呢？ 首先先做一些简单的准备工作：</p><ol><li>下载一个全局的包</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm i  -g  typescript</span><br><span class="line">或者</span><br><span class="line">yarn  <span class="keyword">global</span> <span class="keyword">add</span>  typescript</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ol><li>打开cmd 输入命令 tsc -v 查看包是否下载成功<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c33f6b7c48e40b7a6c34dc3748eb064~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="在这里插入图片描述">当 cmd 输入指令出现版本号，就说明下载成功啦</li><li>首先打开 vscode， 新建一个 .ts文件。如 hello.ts<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/349299ffe90c4d5798ce3077d1e99780~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="在这里插入图片描述"></li></ol><p>接下来就可以书写 ts 的代码啦！</p><ol><li>新建文件，如 hello.ts。（ts文件的后缀名都是 .ts哦）</li><li>书写代码 3. 编译代码：在终端输入 tsc .&#x2F;hello.ts, 会自动生成一个js 文件，接下来就可以用 node 命名来运行js 的文件，在浏览器打开看效果啦</li></ol><p>如果不想下载包的话，也可以在线运行，链接如下： <a href="https://link.juejin.cn/?target=https://www.typescriptlang.org/play">在线运行</a> 接下来了解一下 ts 的类型注解</p><h4 id="什么是类型注解？"><a href="#什么是类型注解？" class="headerlink" title="什么是类型注解？"></a>什么是类型注解？</h4><p>就是给变量添加类型约束，<strong>可以显示标记出代码中的意外行为，从而降低了发生错误的可能性</strong> 语法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> 变量名: 类型 = 初始值</span><br><span class="line"><span class="keyword">let</span> <span class="attr">age</span>: <span class="built_in">number</span> = <span class="number">18</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这样写有啥好处捏？更好的规定了数据的类型，避免了不必要的错误。 如果你不小心写错了，他会直接提示你类型错误哦。是不是很贴心呢?<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/74f781f5d0e74f85a7485e818a1067b0~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="在这里插入图片描述">代码中的 <code>: number</code> 就是<strong>类型注解</strong>。</p><p>注：这里的代码错误提示，我是下载了一个插件才有的。如果大家也想有提示的话，可以在 vscode 里面下载。我把插件的截图贴在下面。<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2874f87a88a494d9c9b6ce4cbf32836~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="在这里插入图片描述"></p><h3 id="ts-的类型"><a href="#ts-的类型" class="headerlink" title="ts 的类型"></a>ts 的类型</h3><p>ts 的常用基础类型分为两种： js 已有类型</p><ol><li>原始类型：<code>number/string/boolean/null/undefined/symbol</code></li><li>对象类型：<code>object</code>（包括，数组、对象、函数等对象）</li></ol><p>ts 新增类型</p><ol><li>联合类型</li><li>自定义类型(类型别名)</li><li>接口</li><li>元组</li><li>字面量类型</li><li>枚举</li><li>void</li><li>any</li><li>等等</li></ol><p>原始类型： number&#x2F;string&#x2F;boolean&#x2F;null&#x2F;undefined&#x2F;symbol 语法比较简单，基本和 js 差别不大</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数值类型</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">age</span>: <span class="built_in">number</span> = <span class="number">18</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串类型</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">myName</span>: <span class="built_in">string</span> = <span class="string">&#x27;小花&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 布尔类型</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">isLoading</span>: <span class="built_in">boolean</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">un</span>: <span class="literal">undefined</span> = <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// null</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">timer</span>:<span class="literal">null</span> = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// symbol</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">uniKey</span>:<span class="built_in">symbol</span> = <span class="title class_">Symbol</span>()</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>类型推论 在 TS 中，某些没有明确指定类型的情况下，<strong>TS 的类型推论机制会自动提供类型</strong>。好处：由于类型推论的存在，有些情况下的类型注解可以省略不写 有如下两种场景：</p><ol><li>声明变量并初始化时<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d4f867a28e440108f14cdf2d9044627~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="在这里插入图片描述"></li><li>决定函数返回值时<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/017f25dc7d194d4ba4a9df3a01200f56~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="在这里插入图片描述">已知函数的两个参数都是<code>number</code>类型，那么该函数的返回值也是 <code>number</code> 类型。</li></ol><h4 id="联合类型："><a href="#联合类型：" class="headerlink" title="联合类型："></a>联合类型：</h4><p>需求：如何定义一个变量可以是null也可以是 number 类型? 这个时候，前面所学的已经不能满足我们的需求了，就需要用到一个新的类型 - 组合类型。 语法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> 变量: 类型<span class="number">1</span> | 类型<span class="number">2</span> | 类型<span class="number">3</span> .... = 初始值</span><br><span class="line"><span class="keyword">let</span> arr1 :<span class="built_in">number</span> | <span class="built_in">string</span> = <span class="number">1</span> <span class="comment">// 可以写两个类型</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>注意： 这里的 <code>|</code> 竖线，在 TS 中叫做<strong>联合类型</strong>，即：由两个或多个其他类型组成的类型，表示可以是这些类型中的任意一种。不要和 js 中的 <code>||</code> 搞混哦。 应用场景： 定时器id</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// | 联合类型  变量可以是两种类型之一</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">timer</span>:<span class="built_in">number</span>|<span class="literal">null</span> = <span class="literal">null</span></span><br><span class="line">timer = <span class="built_in">setTimeout</span>()</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>在我们定义类型的时候，有时候自己定义的类型名往往很长，这个时候就需要在定义个别名，方便书写。 语法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 别名 = 类型</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> s = <span class="built_in">string</span> <span class="comment">// 定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">str1</span>:s = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">str2</span>:<span class="built_in">string</span> = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>作用：</p><ol><li>给类型起别名</li><li>定义了新类型</li></ol><p>使用场景：给复杂的类型起个别名</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">type</span> <span class="title class_">NewType</span> = <span class="built_in">string</span> | <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">let</span> <span class="attr">a</span>: <span class="title class_">NewType</span> = <span class="number">1</span></span><br><span class="line"> <span class="keyword">let</span> <span class="attr">b</span>: <span class="title class_">NewType</span> = <span class="string">&#x27;1&#x27;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4bd8f339b290417194416f426877b004~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="在这里插入图片描述"></p><p>注意：别名可以是任意的合法字符串，一般<strong>首字母大写</strong></p><h3 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h3><p>语法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法1：</span></span><br><span class="line"><span class="keyword">let</span> 变量: 类型[] = [值<span class="number">1</span>，...]:</span><br><span class="line"><span class="keyword">let</span> <span class="attr">numbers</span>: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>] </span><br><span class="line"><span class="comment">//  numbers必须是数组，每个元素都必须是数字</span></span><br><span class="line"><span class="comment">// 写法2：</span></span><br><span class="line"><span class="keyword">let</span> 变量: <span class="title class_">Array</span>&lt;类型&gt; = [值<span class="number">1</span>，...]</span><br><span class="line"><span class="keyword">let</span> <span class="attr">strings</span>: <span class="title class_">Array</span>&lt;<span class="built_in">string</span>&gt; = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>] </span><br><span class="line"><span class="comment">//  strings必须是数组，每个元素都必须是字符串</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>函数涉及的类型实际上指的是：<code>函数参数</code>和<code>返回值</code>的类型</p><h4 id="定义单个函数"><a href="#定义单个函数" class="headerlink" title="定义单个函数"></a>定义单个函数</h4><p>语法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="keyword">function</span> 函数名(形参<span class="number">1</span>： 类型=默认值， 形参<span class="number">2</span>：类型=默认值,...): 返回值类型 &#123; &#125;</span><br><span class="line"><span class="comment">// 声明式实际写法:</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">num1: <span class="built_in">number</span>, num2: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">const</span> 函数名（形参<span class="number">1</span>： 类型=默认值， 形参<span class="number">2</span>：类型=默认值, ...):返回值类型 =&gt; &#123; &#125;</span><br><span class="line"><span class="keyword">const</span> add2 = (<span class="attr">a</span>: <span class="built_in">number</span> =<span class="number">100</span>, <span class="attr">b</span>: <span class="built_in">number</span> = <span class="number">100</span>): <span class="function"><span class="params">number</span> =&gt;</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> a + b</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 注意： 箭头函数的返回值类型要写在参数小括号的后面</span></span><br><span class="line">add（<span class="number">1</span>,<span class="string">&#x27;1&#x27;</span>) <span class="comment">// 报错</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="统一定义函数格式"><a href="#统一定义函数格式" class="headerlink" title="统一定义函数格式"></a>统一定义函数格式</h4><p>当函数的类型一致时，写多个就会显得代码冗余，所以需要统一定义函数的格式 如下所示：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add2 = (<span class="attr">a</span>: <span class="built_in">number</span> =<span class="number">100</span>, <span class="attr">b</span>: <span class="built_in">number</span> = <span class="number">100</span>): <span class="function"><span class="params">number</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add1</span> (<span class="attr">a</span>:<span class="built_in">number</span> = <span class="number">100</span> , <span class="attr">b</span>: <span class="built_in">number</span> = <span class="number">200</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 这里的 add1 和 add2 的参数类型和返回值一致，</span></span><br><span class="line"><span class="comment">// 那么就可以统一定义一个函数类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Fn</span> = <span class="function">(<span class="params">n1:<span class="built_in">number</span>,n2:<span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> </span><br><span class="line"><span class="keyword">const</span> add3 : <span class="title class_">Fn</span> = <span class="function">(<span class="params">a,b</span>)=&gt;</span>&#123;<span class="keyword">return</span> a+b &#125;</span><br><span class="line"><span class="comment">// 这样书写起来就简单多啦</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="函数返回值类型void"><a href="#函数返回值类型void" class="headerlink" title="函数返回值类型void"></a>函数返回值类型void</h4><p>在 ts 中，如果一个函数没有返回值，应该使用 <code>void</code> 类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">name: <span class="built_in">string</span></span>): <span class="built_in">void</span> &#123;  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>, name)  <span class="comment">//&#125;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>可以用到<code>void</code> 有以下几种情况</p><ol><li>函数没写return</li><li>只写了 return， 没有具体的返回值</li><li>return 的是 undefined</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果什么都不写，此时，add 函数的返回值类型为： void</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">add</span> = (<span class="params"></span>) =&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果return之后什么都不写，此时，add 函数的返回值类型为： void</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">add</span> = (<span class="params"></span>) =&gt; &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> add = (): <span class="function"><span class="params">void</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 此处，返回的 undefined 是 JS 中的一个值</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这种写法是明确指定函数返回值类型为 void，与上面不指定返回值类型相同</span></span><br><span class="line"><span class="keyword">const</span> add = (): <span class="function"><span class="params">void</span> =&gt;</span> &#123;&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>那么就有人好奇，既然return undefined，那么为什么不可以直接在返回值那里写 :undefined 呢？ 如果函数没有指定返回值，调用结束之后，值是undefined的，但是不能直接声明返回值是undefined</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a:<span class="built_in">number</span>, b:<span class="built_in">number</span></span>): <span class="literal">undefined</span> &#123; <span class="comment">// 这里会报错</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a,b)</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="函数-可选参数"><a href="#函数-可选参数" class="headerlink" title="函数-可选参数"></a>函数-可选参数</h4><p>使用函数实现某个功能时，参数可以传也可以不传。</p><p>例如：数组的 slice 方法，可以 <code>slice()</code> 也可以 <code>slice(1)</code> 还可以 <code>slice(1, 3)</code> 那么就可以定义可选参数 语法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">可选参数：在可选参数名的后面添加 ?（问号）</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">slice</span> (a?: <span class="built_in">number</span>, b?: <span class="built_in">number</span>) &#123;</span><br><span class="line">    <span class="comment">// ? 跟在参数名字的后面，表示可选的参数</span></span><br><span class="line">    <span class="comment">// 注意：可选参数只能在 必须参数的后面</span></span><br><span class="line">    <span class="comment">// 如果可选参数在必选参数的前面，会报错</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">111</span>);</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">slice</span>()</span><br><span class="line">  <span class="title function_">slice</span>(<span class="number">1</span>)</span><br><span class="line">  <span class="title function_">slice</span>(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h5 id="可选和默认值的区别"><a href="#可选和默认值的区别" class="headerlink" title="可选和默认值的区别"></a>可选和默认值的区别</h5><p>相同点： 调用函数时，可以少传参数</p><p>区别：设置了默认值之后，就是可选的了，不写就会使用默认值； 可选的参数一定有值。</p><p>注意：它们不能一起使用。优先使用默认值<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/adec0275f7bc442fb9ba0ced47910405~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="在这里插入图片描述"></p><h3 id="对象类型-单独使用"><a href="#对象类型-单独使用" class="headerlink" title="对象类型-单独使用"></a>对象类型-单独使用</h3><p>格式： 方法有两种写法： 普通函数 和 箭头函数</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> 对象名: &#123;</span><br><span class="line">  属性名<span class="number">1</span>：类型<span class="number">1</span>，</span><br><span class="line">  属性名<span class="number">2</span>?：类型<span class="number">2</span>，</span><br><span class="line">  方法名<span class="number">1</span>(形参<span class="number">1</span>: 类型<span class="number">1</span>，形参<span class="number">2</span>: 类型<span class="number">2</span>)： 返回值类型,</span><br><span class="line">  方法名<span class="number">2</span>:<span class="function">(<span class="params">形参<span class="number">1</span>: 类型<span class="number">1</span>，形参<span class="number">2</span>: 类型<span class="number">2</span></span>) =&gt;</span> 返回值类型</span><br><span class="line">&#125; = &#123; 属性名<span class="number">1</span>: 值<span class="number">1</span>，属性名<span class="number">2</span>：值<span class="number">2</span>  &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="对象类型-类型别名"><a href="#对象类型-类型别名" class="headerlink" title="对象类型-类型别名"></a>对象类型-类型别名</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建类型别名</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>，</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="title function_">sayHi</span>(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类型别名作为对象的类型：</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">person</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;小花&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">  <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>当一个对象类型被多次使用时，有如下两种方式来来<strong>描述对象</strong>的类型，以达到复用的目的：</p><ol><li>类型别名，type</li><li>接口，interface</li></ol><p>语法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> 接口名  &#123;属性<span class="number">1</span>: 类型<span class="number">1</span>, 属性<span class="number">2</span>: 类型<span class="number">2</span>&#125;</span><br><span class="line"><span class="comment">// 这里用 interface 关键字来声明接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IGoodItem</span>  &#123;</span><br><span class="line"><span class="comment">// 接口名称(比如，此处的 IPerson)，可以是任意合法的变量名称，推荐以 `I` 开头</span></span><br><span class="line">   <span class="attr">name</span>: <span class="built_in">string</span>, <span class="attr">price</span>: <span class="built_in">number</span>, <span class="attr">func</span>: <span class="function">()=&gt;</span><span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明接口后，直接使用接口名称作为变量的类型</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">good1</span>: <span class="title class_">IGoodItem</span> = &#123;</span><br><span class="line">   <span class="attr">name</span>: <span class="string">&#x27;手表&#x27;</span>,</span><br><span class="line">   <span class="attr">price</span>: <span class="number">200</span>,</span><br><span class="line">   <span class="attr">func</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&#x27;看时间&#x27;</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">good2</span>: <span class="title class_">IGoodItem</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;手机&#x27;</span>,</span><br><span class="line">    <span class="attr">price</span>: <span class="number">2000</span>,</span><br><span class="line">    <span class="attr">func</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;打电话&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>接口和类型 的区别 <code>interface</code>（接口）和<code> type</code>（类型别名）的对比：</p><ul><li>相同点：都可以给对象指定类型</li><li>不同点:<ul><li>接口，只能为对象指定类型。<strong>它可以继承。</strong></li><li>类型别名，不仅可以为对象指定类型，实际上可以为<strong>任意类型</strong>指定别名</li></ul></li></ul><p>先有的 <code>interface</code>，后有的 <code>type</code>,推荐使用 <code>type</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口的写法-------------</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IPerson</span> &#123;</span><br><span class="line"><span class="attr">name</span>: <span class="built_in">string</span>,</span><br><span class="line"><span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user1：<span class="title class_">IPerson</span> = &#123;</span><br><span class="line"><span class="attr">name</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line"><span class="attr">age</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// type的写法-------------</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Person</span>  = &#123;</span><br><span class="line"><span class="attr">name</span>: <span class="built_in">string</span>,</span><br><span class="line"><span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> user2：<span class="title class_">Person</span> = &#123;</span><br><span class="line"><span class="attr">name</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line"><span class="attr">age</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="接口继承"><a href="#接口继承" class="headerlink" title="接口继承"></a>接口继承</h4><p>如果两个接口之间有相同的属性或方法，可以将<strong>公共的属性或方法抽离出来，通过继承来实现复用</strong> 语法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> 接口2 <span class="keyword">extends</span> 接口1 &#123;</span><br><span class="line"> 属性<span class="number">1</span>： 类型<span class="number">1</span>， <span class="comment">// 接口2中特有的类型 </span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> a &#123; <span class="attr">x</span>: <span class="built_in">number</span>; <span class="attr">y</span>: <span class="built_in">number</span> &#125;</span><br><span class="line"><span class="comment">// 继承 a</span></span><br><span class="line"><span class="comment">// 使用 extends(继承)关键字实现了接口</span></span><br><span class="line"><span class="keyword">interface</span> b <span class="keyword">extends</span> a &#123;</span><br><span class="line">  <span class="attr">z</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承后，b 就有了 a 的所有属性和方法(此时，b 同时有 x、y、z 三个属性)</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p><strong>元组</strong>是一种特殊的<strong>数组</strong>。有两点特殊之处</p><ol><li>它约定了的元素个数</li><li>它约定了特定索引对应的数据类型</li></ol><p>举个例子： 就拿 react 里面的 useState来举例：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">useState</span>(<span class="params">n: <span class="built_in">number</span></span>): [<span class="built_in">number</span>, <span class="function">(<span class="params"><span class="built_in">number</span></span>)=&gt;</span><span class="built_in">void</span>] &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="title function_">setN</span> = (<span class="params">n1</span>) =&gt; &#123;</span><br><span class="line">            n = n1</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> [n, setN]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [num ,setNum] = <span class="title function_">useState</span>(<span class="number">10</span>)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="字面量类型"><a href="#字面量类型" class="headerlink" title="字面量类型"></a>字面量类型</h4><p>例如下面的代码</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str1 = <span class="string">&#x27;hello TS&#x27;</span></span><br><span class="line"><span class="keyword">const</span> str2 = <span class="string">&#x27;hello TS&#x27;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>大家可以猜一下，str1 是什么类型的，str2 是什么类型？不要偷偷看答案哦。</p><p>这里是正确答案： str1 的类型为 <code>string</code> 类型，str2 的类型为 <code>Hello TS</code>类型<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/24ace532cd2b44b2b80ffb2e9b461fd7~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="在这里插入图片描述">这是为啥呢？</p><ol><li>str1 是一个变量(let)，它的值可以是任意字符串，所以类型为:string</li><li>str2 是一个常量(const)，它的<strong>值不能变化</strong>只能是 ‘hello TS’，所以，它的类型为:’hello TS’</li></ol><p>注意：此处的 ‘Hello TS’，就是一个<strong>字面量类型</strong>，也就是说某个特定的字符串也可以作为 TS 中的类型</p><p>这时候就有人好奇了，那字面量类型有啥作用呢？ 字面量类型一般是配合联合类型一起使用的， 用来表示一组明确的可选值列表。 例如下面的例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Gender</span> = <span class="string">&#x27;girl&#x27;</span> | <span class="string">&#x27;boy&#x27;</span></span><br><span class="line"><span class="comment">// 声明一个类型，他的值 是 &#x27;girl&#x27; 或者是 &#x27;boy&#x27;</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">g1</span>: <span class="title class_">Gender</span> = <span class="string">&#x27;girl&#x27;</span> <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">g2</span>: <span class="title class_">Gender</span> = <span class="string">&#x27;boy&#x27;</span> <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">g3</span>: <span class="title class_">Gender</span> = <span class="string">&#x27;man&#x27;</span> <span class="comment">// 错误</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>可以看到会有提示，明确告诉你只能选这两种。妈妈再也不用担心写错啦<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e225e5ab11d44983be81a27026f8a5ec~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="在这里插入图片描述"></p><h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><p>枚举（enum）的功能类似于<strong>字面量类型+联合类型组合</strong>的功能，来描述一个值，该值只能是 一组命名常量 中的一个。 在没有 type 的时候，大家都是用枚举比较多的，现在比较少了。 语法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> 枚举名 &#123; 可取值<span class="number">1</span>, 可取值<span class="number">2</span>,.. &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用格式：</span></span><br><span class="line">枚举名.可取值</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c8284f378f4e40c6925252bc9e648577~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="在这里插入图片描述">注意：</p><ol><li>一般枚举名称以大写字母开头</li><li>枚举中的多个值之间通过 <code>,</code>（逗号）分隔</li><li>定义好枚举后，直接使用枚举名称作为类型注解</li></ol><p>枚举也分数值枚举 和 字符串枚举。 数值枚举： 默认情况下，枚举的值是<strong>数值</strong>。默认为：从 0 开始自增的数值 当然，也可以给枚举中的成员初始化值</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123; <span class="title class_">Up</span> = <span class="number">10</span>, <span class="title class_">Down</span>, <span class="title class_">Left</span>, <span class="title class_">Right</span> &#125;</span><br><span class="line"><span class="comment">// Down -&gt; 11、Left -&gt; 12、Right -&gt; 13</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123; <span class="title class_">Up</span> = <span class="number">2</span>, <span class="title class_">Down</span> = <span class="number">3</span>, <span class="title class_">Left</span> = <span class="number">8</span>, <span class="title class_">Right</span> = <span class="number">16</span> &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>字符串枚举：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">  <span class="title class_">Up</span> = <span class="string">&#x27;UP&#x27;</span>,</span><br><span class="line">  <span class="title class_">Down</span> = <span class="string">&#x27;DOWN&#x27;</span>,</span><br><span class="line">  <span class="title class_">Left</span> = <span class="string">&#x27;LEFT&#x27;</span>,</span><br><span class="line">  <span class="title class_">Right</span> = <span class="string">&#x27;RIGHT&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>注意：字符串枚举没有自增长行为，因此，<strong>字符串枚举的每个成员必须有初始值</strong></p><h4 id="any-类型"><a href="#any-类型" class="headerlink" title="any 类型"></a>any 类型</h4><p>any: 任意的。当类型设置为 any 时，就取消了类型的限制。 例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">obj</span>: <span class="built_in">any</span> = &#123; <span class="attr">x</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">obj.<span class="property">bar</span> = <span class="number">100</span></span><br><span class="line"><span class="title function_">obj</span>()</span><br><span class="line"><span class="comment">// obj 可以是任意类型</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">n</span>: <span class="built_in">number</span> = obj</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="使用any的场景"><a href="#使用any的场景" class="headerlink" title="使用any的场景"></a>使用any的场景</h3><ul><li>函数就是不挑类型。 例如，<code>console.log()</code> ； 定义一个函数，输入任意类型的数据，返回该数据类型</li><li><strong>临时使用</strong> any 来“避免”书写很长、很复杂的类型</li></ul><p>还有一种隐式 any，有下面两种情况会触发</p><ol><li>声明变量不提供类型也不提供默认值</li><li>定义函数时，参数不给类型</li></ol><p>注意：<strong>不推荐使用 any</strong>!这会让 TypeScript 变为 “AnyScript”(失去 TS 类型保护的优势)</p><p>类型介绍这边就不一一展开了，更多介绍请看查阅官网。<a href="https://link.juejin.cn/?target=https://www.typescriptlang.org/">TypeScript官方文档</a></p><p>分类：</p><p><a href="https://juejin.cn/frontend">前端</a></p><p>标签：</p><p><a href="https://juejin.cn/tag/%E5%89%8D%E7%AB%AF">前端</a></p><p><a href="https://juejin.cn/extension/?utm_source=standalone&utm_medium=post&utm_campaign=extension_promotion">安装掘金浏览器插件</a></p><p>多内容聚合浏览、多引擎快捷搜索、多工具便捷提效、多模式随心畅享，你想要的，这里都有！</p><p><a href="https://juejin.cn/extension/?utm_source=standalone&utm_medium=post&utm_campaign=extension_promotion">前往安装</a></p><p>相关小册</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5551a4e63b04bd5828a1fbfa72b6346~tplv-k3u1fbpfcp-no-mark:420:420:300:420.awebp" alt="「从 0 到 1 实现一套 CI/CD 流程」封面"></p><p>VIP</p><p> 从 0 到 1 实现一套 CI&#x2F;CD 流程</p><p><a href="https://juejin.cn/user/3368559357218382">王圣松<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05be64d75fee4dbdb290ba23afd21fcf~tplv-k3u1fbpfcp-no-mark:0:0:0:0.awebp" alt="lv-4"></a></p><p>3224购买</p><p>¥14.95</p><p>¥29.9</p><p>首单券后价</p><p>首单券后价</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/359ac54a4608421f854b11b27201723c~tplv-k3u1fbpfcp-no-mark:420:420:300:420.awebp" alt="「TypeScript 类型体操通关秘籍」封面"></p><p>VIP</p><p> TypeScript 类型体操通关秘籍</p><p><a href="https://juejin.cn/user/2788017216685118">zxg_神说要有光<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/549f476f5e9146848df91d2cd912fe61~tplv-k3u1fbpfcp-no-mark:0:0:0:0.awebp" alt="lv-7"><img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/162b40efbd71af9a806dd2b54c4580ef.svg" alt="img"></a></p><p>4321购买</p><p>¥19.95</p><p>¥39.9</p><p>首单券后价</p><p>首单券后价</p><p>评论</p><p><img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/58aaf1326ac763d8a1054056f3b7f2ef.svg" alt="img"></p><p>看完啦，</p><p>登录</p><p>分享一下感受吧～</p><p>热门评论</p><p><a href="https://juejin.cn/user/449053829898887"><img src="https://p3-passport.byteimg.com/img/user-avatar/929f24831f692aeeda06a0c4ccc2c0be~100x100.awebp" alt="KuAi9的头像"></a></p><p><a href="https://juejin.cn/user/449053829898887">KuAi9<img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/65a6a28f15d70e5a77bf881c5ec5340d.svg" alt="掘友等级"></a></p><p>Web前端 @ 武汉不知名物联网公司10月前</p><p>学的是 TypeScript，用的是 AnyScript</p><p>82</p><p>11</p><p><a href="https://juejin.cn/user/589812812228408"><img src="https://p3-passport.byteimg.com/img/user-avatar/7b5c2c3cf901317b71ba95fdb4ab9cb0~100x100.awebp" alt="img"></a></p><p><a href="https://juejin.cn/user/589812812228408">一起去看星星吧</a></p><p>（作者）10月前</p><p>哈哈，既然使用了typeScript，还是尽量按照规范来写啦</p><p>1</p><p>回复</p><p><a href="https://juejin.cn/user/3306960384174958"><img src="https://p3-passport.byteimg.com/img/user-avatar/9a6efc830c91064895c1060087e5edef~100x100.awebp" alt="img"></a></p><p><a href="https://juejin.cn/user/3306960384174958">FE_winter</a></p><p>回复</p><p><a href="https://juejin.cn/user/589812812228408">一起去看星星吧</a></p><p>10月前</p><p>我不</p><p>“</p><p>哈哈，既然使用了typeScript，还是尽量按照规范来写啦</p><p>”</p><p>17</p><p>回复</p><p>查看更多回复</p><p><a href="https://juejin.cn/user/2752832847484637"><img src="https://p3-passport.byteimg.com/img/user-avatar/4fcacaa02b44d93eb9fc52154ebdd55e~100x100.awebp" alt="心有猛虎嗷呜的头像"></a></p><p><a href="https://juejin.cn/user/2752832847484637">心有猛虎嗷呜<img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/8c6985e2aa4c06f307ae3734da4b43ac.svg" alt="掘友等级"></a></p><p>前端开发10月前</p><p>我觉得难点在于实战项目，求推荐写的好的，使用vue3+ts的开源项目</p><p>13</p><p>14</p><p><a href="https://juejin.cn/user/589812812228408"><img src="https://p3-passport.byteimg.com/img/user-avatar/7b5c2c3cf901317b71ba95fdb4ab9cb0~100x100.awebp" alt="img"></a></p><p><a href="https://juejin.cn/user/589812812228408">一起去看星星吧</a></p><p>（作者）10月前</p><p><img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/img/jj_emoji_28.8981538.png" alt="[捂脸]">我现在用的是react＋ts，vue的没用，你可以自己尝试在项目中加ts，自己也会理解的更好一些</p><p>点赞</p><p>回复</p><p><a href="https://juejin.cn/user/826482430323197"><img src="https://p3-passport.byteimg.com/img/user-avatar/2a1bf4bd50c4b5ddc217dd744ac5a69e~100x100.awebp" alt="img"></a></p><p><a href="https://juejin.cn/user/826482430323197">cathats</a></p><p>10月前</p><p>vban-admin</p><p>2</p><p>回复</p><p>查看更多回复</p><p><a href="https://juejin.cn/user/2392971577140862"><img src="https://p3-passport.byteimg.com/img/user-avatar/13dda37f90de661ca776cae75f76e293~100x100.awebp" alt="不关心waring的程序员的头像"></a></p><p><a href="https://juejin.cn/user/2392971577140862">不关心waring的程序员<img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/cf19b122213ebdbd25b66f02500b8c27.svg" alt="掘友等级"></a></p><p>10月前</p><p>那个中文的提示怎么弄的</p><p>1</p><p>10</p><p><a href="https://juejin.cn/user/3597257777363886"><img src="https://p3-passport.byteimg.com/img/mosaic-legacy/3796/2975850990~100x100.awebp" alt="img"></a></p><p><a href="https://juejin.cn/user/3597257777363886">子非余a</a></p><p>10月前</p><p>这样</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d4aa7684c3241529952f68ed34c23bc~tplv-k3u1fbpfcp-no-mark:320:320:320:320.awebp" alt="image"></p><p>1</p><p>回复</p><p><a href="https://juejin.cn/user/2392971577140862"><img src="https://p3-passport.byteimg.com/img/user-avatar/13dda37f90de661ca776cae75f76e293~100x100.awebp" alt="img"></a></p><p><a href="https://juejin.cn/user/2392971577140862">不关心waring的程序员</a></p><p>回复</p><p><a href="https://juejin.cn/user/3597257777363886">子非余a</a></p><p>10月前</p><p>这个我也设置了，咋没生效，难道要重启vscode<img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/img/jj_emoji_31.606e7a5.png" alt="[疑问]"></p><p>“</p><p>这样</p><p>”</p><p>点赞</p><p>回复</p><p>查看更多回复</p><p>全部评论 204</p><p>最新</p><p>最热</p><p><a href="https://juejin.cn/user/1504551129856302"><img src="https://p3-passport.byteimg.com/img/user-avatar/3d97cab99f51d1712591cf0383174aae~100x100.awebp" alt="props的头像"></a></p><p><a href="https://juejin.cn/user/1504551129856302">props<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a3f5a3e7550645a08184e5c4247cc3d4~tplv-k3u1fbpfcp-no-mark:0:0:0:0.awebp" alt="lv-3"><img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/cf19b122213ebdbd25b66f02500b8c27.svg" alt="掘友等级"></a></p><p>前端开发2天前</p><p>6</p><p>点赞</p><p>回复</p><p><a href="https://juejin.cn/user/3211023413674919"><img src="https://p3-passport.byteimg.com/img/user-avatar/8e7d81012b1afef7d15a3d582e49ee3f~100x100.awebp" alt="模拟哦莫哦的头像"></a></p><p><a href="https://juejin.cn/user/3211023413674919">模拟哦莫哦<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a4dbd8a81a84d599442ef1095e35bab~tplv-k3u1fbpfcp-no-mark:0:0:0:0.awebp" alt="lv-1"><img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/cf19b122213ebdbd25b66f02500b8c27.svg" alt="掘友等级"></a></p><p>12天前</p><p><img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/img/jj_emoji_108.a6defc6.png" alt="[赞]"></p><p>点赞</p><p>回复</p><p><a href="https://juejin.cn/user/4001878056646589"><img src="https://p3-passport.byteimg.com/img/user-avatar/151144ce1f815b0ffe5c8acf4125e066~100x100.awebp" alt="我要让全世界知道我很低调的头像"></a></p><p><a href="https://juejin.cn/user/4001878056646589">我要让全世界知道我很低调<img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/65a6a28f15d70e5a77bf881c5ec5340d.svg" alt="掘友等级"></a></p><p>前端搬砖工程师18天前</p><p>真的很保姆级了~</p><p>点赞</p><p>回复</p><p><a href="https://juejin.cn/user/1327865776053143"><img src="https://p3-passport.byteimg.com/img/user-avatar/0037bda427f9a2f86ee9c00914d98156~100x100.awebp" alt="zhangcl♐️的头像"></a></p><p><a href="https://juejin.cn/user/1327865776053143">zhangcl♐️<img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/65a6a28f15d70e5a77bf881c5ec5340d.svg" alt="掘友等级"></a></p><p>24天前</p><p><img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/img/jj_emoji_108.a6defc6.png" alt="[赞]"></p><p>点赞</p><p>回复</p><p><a href="https://juejin.cn/user/1636503231934141"><img src="https://p3-passport.byteimg.com/img/user-avatar/10f17a0a8b63dbf7a12f3b8a78139e88~100x100.awebp" alt="认知ing的头像"></a></p><p><a href="https://juejin.cn/user/1636503231934141">认知ing<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a4dbd8a81a84d599442ef1095e35bab~tplv-k3u1fbpfcp-no-mark:0:0:0:0.awebp" alt="lv-1"><img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/8c6985e2aa4c06f307ae3734da4b43ac.svg" alt="掘友等级"></a></p><p>Java高级搬砖工程师1月前</p><p><img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/img/jj_emoji_128.e55728c.png" alt="[666]"></p><p>点赞</p><p>回复</p><p><a href="https://juejin.cn/user/562563413192446"><img src="https://p3-passport.byteimg.com/img/user-avatar/edfb00bf7efc48bdfb664faf9ab913ce~100x100.awebp" alt="恐龙不要烦恼的头像"></a></p><p><a href="https://juejin.cn/user/562563413192446">恐龙不要烦恼<img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/8c6985e2aa4c06f307ae3734da4b43ac.svg" alt="掘友等级"></a></p><p>前端 @ 辣鸡公司1月前</p><p>Error Lens vscode 搜不出来这个插件</p><p>点赞</p><p>回复</p><p><a href="https://juejin.cn/user/588993965604013"><img src="https://p3-passport.byteimg.com/img/user-avatar/b0c831d97a3a8d94d8ea1a2ae8b8183e~100x100.awebp" alt="闲不住的咸鱼的头像"></a></p><p><a href="https://juejin.cn/user/588993965604013">闲不住的咸鱼<img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/cf19b122213ebdbd25b66f02500b8c27.svg" alt="掘友等级"></a></p><p>搬砖员 @ 砖厂1月前</p><p>实际使用肯定图方便，any是最常使用的</p><p>点赞</p><p>回复</p><p><a href="https://juejin.cn/user/606586149540942"><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/2/16f65373d9410573~tplv-t2oaga2asx-no-mark:100:100:100:100.awebp" alt="爬行的蜗牛的头像"></a></p><p><a href="https://juejin.cn/user/606586149540942">爬行的蜗牛<img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/65a6a28f15d70e5a77bf881c5ec5340d.svg" alt="掘友等级"></a></p><p>1月前</p><p>我有个问题困扰多时，望帮忙解答下，obj 的参数a是可选布尔值，当a为真时obj的参数b必选，否则b可不选<br>这种如何定义obj 的参数类型</p><p>点赞</p><p>6</p><p><a href="https://juejin.cn/user/2995531848885464"><img src="https://p3-passport.byteimg.com/img/user-avatar/b304086e87387d2afd51a06b15bef056~100x100.awebp" alt="img"></a></p><p><a href="https://juejin.cn/user/2995531848885464">gegadan</a></p><p>1月前</p><p>用泛型</p><p>1</p><p>回复</p><p><a href="https://juejin.cn/user/1714893867990440"><img src="https://p3-passport.byteimg.com/img/user-avatar/fa99f0a42e3eb1234edfda60bcfffa32~100x100.awebp" alt="img"></a></p><p><a href="https://juejin.cn/user/1714893867990440">黑色摩天轮</a></p><p>1月前</p><p>泛型搭配Partial高级类型<br>export interface Obj<T extends boolean> {<br>a?: T;<br>b: string;<br>}</p><p>export type ABObj<U extends boolean> &#x3D; U extends true ? Obj<U>: Partial&lt;Obj<U>&gt;</p><p>展开</p><p>2</p><p>回复</p><p>查看更多回复</p><p><a href="https://juejin.cn/user/2718467973193614"><img src="https://p3-passport.byteimg.com/img/user-avatar/b4134e6fd2f9ee04e8419dba4cce1ac1~100x100.awebp" alt="日落c的头像"></a></p><p><a href="https://juejin.cn/user/2718467973193614">日落c<img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/7042b5a0cda0d030ddfdd1fdd14f8049.svg" alt="掘友等级"></a></p><p>2月前</p><p>可以</p><p>点赞</p><p>回复</p><p><a href="https://juejin.cn/user/3756374523125022"><img src="https://p3-passport.byteimg.com/img/user-avatar/d40546d3a9d703df09c33b804ccc456c~100x100.awebp" alt="木鱼啊的头像"></a></p><p><a href="https://juejin.cn/user/3756374523125022">木鱼啊<img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/8c6985e2aa4c06f307ae3734da4b43ac.svg" alt="掘友等级"></a></p><p>前端开发2月前</p><p>不能直接给number类型setTimeout哎，要window.setTimeout才行</p><p>点赞</p><p>回复</p><p><a href="https://juejin.cn/user/2735998492479901"><img src="https://p3-passport.byteimg.com/img/user-avatar/48e0fe4fb726a1d62dfab9206c397a08~100x100.awebp" alt="LausanneChan的头像"></a></p><p><a href="https://juejin.cn/user/2735998492479901">LausanneChan<img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/8c6985e2aa4c06f307ae3734da4b43ac.svg" alt="掘友等级"></a></p><p>2月前</p><p>谢谢保姆</p><p>点赞</p><p>回复</p><p><a href="https://juejin.cn/user/2850386632515192"><img src="https://p3-passport.byteimg.com/img/user-avatar/9d75c8e634df8263f021f80f41084cab~100x100.awebp" alt="窦戈的头像"></a></p><p><a href="https://juejin.cn/user/2850386632515192">窦戈<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a4dbd8a81a84d599442ef1095e35bab~tplv-k3u1fbpfcp-no-mark:0:0:0:0.awebp" alt="lv-1"><img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/65a6a28f15d70e5a77bf881c5ec5340d.svg" alt="掘友等级"></a></p><p>潍坊筋斗云网络科技有限公司4月前</p><p>这就是传说中的课代表吗<img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/img/jj_emoji_2.cd1e2bd.png" alt="[呲牙]"></p><p>点赞</p><p>回复</p><p><a href="https://juejin.cn/user/2168697250654696"><img src="https://p3-passport.byteimg.com/img/mosaic-legacy/3796/2975850990~100x100.awebp" alt="limoamoa的头像"></a></p><p><a href="https://juejin.cn/user/2168697250654696">limoamoa<img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/8c6985e2aa4c06f307ae3734da4b43ac.svg" alt="掘友等级"></a></p><p>前端开发 @ 湖南4月前</p><p>在ts里按照js写，哈哈哈</p><p>1</p><p>回复</p><p><a href="https://juejin.cn/user/2362229250073918"><img src="https://p3-passport.byteimg.com/img/user-avatar/267e164f63ab671b3afa565976be4706~100x100.awebp" alt="侃侃339的头像"></a></p><p><a href="https://juejin.cn/user/2362229250073918">侃侃339<img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/8c6985e2aa4c06f307ae3734da4b43ac.svg" alt="掘友等级"></a></p><p>4月前</p><p>学过c，对弱类型JS很不习惯，总担心，既不执行更不报错<img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/img/jj_emoji_2.cd1e2bd.png" alt="[呲牙]"></p><p>点赞</p><p>回复</p><p><a href="https://juejin.cn/user/1283872757917448"><img src="https://p3-passport.byteimg.com/img/user-avatar/d6241fe30f51d6cbe1055beb661ccaf8~100x100.awebp" alt="土狗大黄的头像"></a></p><p><a href="https://juejin.cn/user/1283872757917448">土狗大黄<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad1d5b8ec0974b0bbc14446acdd7c20d~tplv-k3u1fbpfcp-no-mark:0:0:0:0.awebp" alt="lv-2"><img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/8c6985e2aa4c06f307ae3734da4b43ac.svg" alt="掘友等级"></a></p><p>4月前</p><p>我感觉我现在不用ts已经不会写代码了<img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/img/jj_emoji_61.a296509.png" alt="[哭笑]"></p><p>点赞</p><p>回复</p><p><a href="https://juejin.cn/user/800907044327902"><img src="https://p3-passport.byteimg.com/img/user-avatar/dbe68af40bc02e65b8f1ff4a191c1ad8~100x100.awebp" alt="大花猫啊的头像"></a></p><p><a href="https://juejin.cn/user/800907044327902">大花猫啊<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a4dbd8a81a84d599442ef1095e35bab~tplv-k3u1fbpfcp-no-mark:0:0:0:0.awebp" alt="lv-1"><img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/8c6985e2aa4c06f307ae3734da4b43ac.svg" alt="掘友等级"></a></p><p>前端素描师5月前</p><p>有没有泛型的文章看看</p><p>1</p><p>回复</p><p><a href="https://juejin.cn/user/1204720475840958"><img src="https://p3-passport.byteimg.com/img/user-avatar/0d6268888cbe3188eb67aa9c837667c4~100x100.awebp" alt="kevinyang的头像"></a></p><p><a href="https://juejin.cn/user/1204720475840958">kevinyang<img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/8c6985e2aa4c06f307ae3734da4b43ac.svg" alt="掘友等级"></a></p><p>5月前</p><p>牛，着么漂亮的妹子，写的文章着么好</p><p>点赞</p><p>回复</p><p><a href="https://juejin.cn/user/167551120972109"><img src="https://p3-passport.byteimg.com/img/mosaic-legacy/3793/3131589739~100x100.awebp" alt="wc001的头像"></a></p><p><a href="https://juejin.cn/user/167551120972109">wc001<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a4dbd8a81a84d599442ef1095e35bab~tplv-k3u1fbpfcp-no-mark:0:0:0:0.awebp" alt="lv-1"><img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/65a6a28f15d70e5a77bf881c5ec5340d.svg" alt="掘友等级"></a></p><p>5月前</p><p>枚举类型愣是没整明白，什么呀<img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/img/jj_emoji_6.dde0d83.png" alt="[流泪]"></p><p>点赞</p><p>1</p><p><a href="https://juejin.cn/user/589812812228408"><img src="https://p3-passport.byteimg.com/img/user-avatar/7b5c2c3cf901317b71ba95fdb4ab9cb0~100x100.awebp" alt="img"></a></p><p><a href="https://juejin.cn/user/589812812228408">一起去看星星吧</a></p><p>（作者）5月前</p><p>你可以把它当成联合类型，你枚举中写了几种类型，那么你写的类型只能从那几种类型中去找。如果是 string 类型的枚举，必须每个都有值，number 类型的可以不用每个都有，它会自己推论其他的值。</p><p>点赞</p><p>回复</p><p><a href="https://juejin.cn/user/4459274894317437"><img src="https://p3-passport.byteimg.com/img/user-avatar/ca3d694d6564db8833b02be2fe2c3aca~100x100.awebp" alt="showFaker的头像"></a></p><p><a href="https://juejin.cn/user/4459274894317437">showFaker<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a4dbd8a81a84d599442ef1095e35bab~tplv-k3u1fbpfcp-no-mark:0:0:0:0.awebp" alt="lv-1"><img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/65a6a28f15d70e5a77bf881c5ec5340d.svg" alt="掘友等级"></a></p><p>6月前</p><p>文章不错，就是太短了</p><p>点赞</p><p>1</p><p><a href="https://juejin.cn/user/4459274894317437"><img src="https://p3-passport.byteimg.com/img/user-avatar/ca3d694d6564db8833b02be2fe2c3aca~100x100.awebp" alt="img"></a></p><p><a href="https://juejin.cn/user/4459274894317437">showFaker</a></p><p>6月前</p><p>实战中后端返回的对象属性太多的情况下，申明interface{key:xxx},里面超多属性时该怎么优化，每次写这些真的好烦，不要{[key:string]:any}这个方法</p><p>点赞</p><p>回复</p><p><a href="https://juejin.cn/user/334691144316536"><img src="https://p3-passport.byteimg.com/img/mosaic-legacy/3796/2975850990~100x100.awebp" alt="用户9320669017517的头像"></a></p><p><a href="https://juejin.cn/user/334691144316536">用户9320669017517<img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/8c6985e2aa4c06f307ae3734da4b43ac.svg" alt="掘友等级"></a></p><p>6月前</p><p>求同款vscode主题<img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/img/jj_emoji_2.cd1e2bd.png" alt="[呲牙]"></p><p>2</p><p>回复</p><p>查看全部 204 条回复</p><p>相关推荐</p><p><a href="https://juejin.cn/user/289926802309400">悠哉wu</a></p><p>9月前</p><p><a href="https://juejin.cn/tag/%E5%89%8D%E7%AB%AF">前端</a><a href="https://juejin.cn/tag/Vue.js">Vue.js</a></p><p><a href="https://juejin.cn/post/7109775800915722277">由于不好用，就用Vue3+Ts做了个视频网站</a></p><ul><li><p>1.9w</p></li><li><p>211</p></li><li><p>82</p></li></ul><p><a href="https://juejin.cn/user/3835563370095262">闲D阿强</a></p><p>4月前</p><p><a href="https://juejin.cn/tag/%E5%89%8D%E7%AB%AF">前端</a><a href="https://juejin.cn/tag/React.js">React.js</a></p><p><a href="https://juejin.cn/post/7167701003976835102">Antd5一出，治好了我组件库选择内耗，我直接搭配React18+Vite+Ts做了一个管理后台</a></p><ul><li><p>6.5w</p></li><li><p>772</p></li><li><p>201</p></li></ul><p><a href="https://juejin.cn/user/1732486058219064">yaoxfly</a></p><p>2年前</p><p><a href="https://juejin.cn/tag/TypeScript">TypeScript</a></p><p><a href="https://juejin.cn/post/6907831475089965064">走近Ts，用了爽，用后一直爽（二)</a></p><ul><li><p>9861</p></li><li><p>61</p></li><li><p>17</p></li></ul><p><a href="https://juejin.cn/user/2084329777010894">程序员乔戈里</a></p><p>3年前</p><p><a href="https://juejin.cn/tag/Java">Java</a></p><p><a href="https://juejin.cn/post/6844904036873814023">美团面试官问我一个字符的String.length()是多少，我说是1，面试官说你回去好好学一下吧</a></p><ul><li><p>24.2w</p></li><li><p>791</p></li><li><p>246</p></li></ul><p><a href="https://juejin.cn/user/3913917126422743">lin嘟嘟嘟</a></p><p>2月前</p><p><a href="https://juejin.cn/tag/%E5%89%8D%E7%AB%AF">前端</a><a href="https://juejin.cn/tag/JavaScript">JavaScript</a><a href="https://juejin.cn/tag/TypeScript">TypeScript</a></p><p><a href="https://juejin.cn/post/7193917621069152311">TS类型写不好？一起来训练提升吧！</a></p><ul><li><p>1.5w</p></li><li><p>351</p></li><li><p>32</p></li></ul><p><a href="https://juejin.cn/user/3773179635179005">Kaiser</a></p><p>1年前</p><p><a href="https://juejin.cn/tag/TypeScript">TypeScript</a></p><p><a href="https://juejin.cn/post/6953500339425247246">【豁然开朗】为什么要用那么复杂的TS</a></p><ul><li><p>4199</p></li><li><p>21</p></li><li><p>9</p></li></ul><p><a href="https://juejin.cn/user/8451825602654">vortesnail</a></p><p>1年前</p><p><a href="https://juejin.cn/tag/%E5%89%8D%E7%AB%AF">前端</a><a href="https://juejin.cn/tag/%E9%9D%A2%E8%AF%95">面试</a></p><p><a href="https://juejin.cn/post/7061588533214969892">做了一份前端面试复习计划，保熟～</a></p><ul><li><p>46.8w</p></li><li><p>8575</p></li><li><p>450</p></li></ul><p><a href="https://juejin.cn/user/2788017216685118">zxg_神说要有光</a></p><p>5月前</p><p><a href="https://juejin.cn/tag/%E5%89%8D%E7%AB%AF">前端</a><a href="https://juejin.cn/tag/JavaScript">JavaScript</a></p><p><a href="https://juejin.cn/post/7158430758070140942">为什么说 90% 的前端不会调试 Ant Design 源码？</a></p><ul><li><p>4.1w</p></li><li><p>702</p></li><li><p>96</p></li></ul><p><a href="https://juejin.cn/user/3350967174838701">一碗周</a></p><p>1年前</p><p><a href="https://juejin.cn/tag/axios">axios</a><a href="https://juejin.cn/tag/TypeScript">TypeScript</a></p><p><a href="https://juejin.cn/post/7071518211392405541">在项目中用ts封装axios，一次封装整个团队受益😁</a></p><ul><li><p>10.1w</p></li><li><p>1515</p></li><li><p>303</p></li></ul><p><a href="https://juejin.cn/user/2960327966986621">逍丶</a></p><p>5月前</p><p><a href="https://juejin.cn/tag/%E5%89%8D%E7%AB%AF">前端</a><a href="https://juejin.cn/tag/Vue.js">Vue.js</a><a href="https://juejin.cn/tag/TypeScript">TypeScript</a></p><p><a href="https://juejin.cn/post/7160962909332307981">2022年我的面试万字总结（Vue3+TS）</a></p><ul><li><p>2.5w</p></li><li><p>560</p></li><li><p>32</p></li></ul><p><a href="https://juejin.cn/user/3350967174838701">一碗周</a></p><p>1年前</p><p><a href="https://juejin.cn/tag/Vue.js">Vue.js</a><a href="https://juejin.cn/tag/%E5%89%8D%E7%AB%AF">前端</a></p><p><a href="https://juejin.cn/post/7062740057018335245">总结了Vue3的七种组件通信方式，别再说不会组件通信了</a></p><ul><li><p>2.9w</p></li><li><p>427</p></li><li><p>62</p></li></ul><p><a href="https://juejin.cn/user/2101921961483374">阿崔cxr</a></p><p>1年前</p><p><a href="https://juejin.cn/tag/Vue.js">Vue.js</a><a href="https://juejin.cn/tag/%E5%89%8D%E7%AB%AF">前端</a></p><p><a href="https://juejin.cn/post/7070809037398343717">字节一面，面试官问我Vue3源码，我说……</a></p><ul><li><p>18.9w</p></li><li><p>2504</p></li><li><p>332</p></li></ul><p><a href="https://juejin.cn/user/764915822103079">阿宝哥</a></p><p>2年前</p><p><a href="https://juejin.cn/tag/%E5%89%8D%E7%AB%AF">前端</a><a href="https://juejin.cn/tag/TypeScript">TypeScript</a></p><p><a href="https://juejin.cn/post/6871752423577223176">细数这些年被困扰过的 TS 问题</a></p><ul><li><p>1.4w</p></li><li><p>373</p></li><li><p>29</p></li></ul><p><a href="https://juejin.cn/user/3421335916909416">信心</a></p><p>4年前</p><p><a href="https://juejin.cn/tag/Vue.js">Vue.js</a><a href="https://juejin.cn/tag/HTML">HTML</a><a href="https://juejin.cn/tag/CSS">CSS</a></p><p><a href="https://juejin.cn/post/6844903673009553416">2018前端面试总结，看完弄懂，工资少说加3K | 掘金技术征文</a></p><ul><li><p>27.6w</p></li><li><p>5531</p></li><li><p>141</p></li></ul><p><a href="https://juejin.cn/user/3438928099549352">前端胖头鱼</a></p><p>1年前</p><p><a href="https://juejin.cn/tag/%E5%89%8D%E7%AB%AF">前端</a><a href="https://juejin.cn/tag/JavaScript">JavaScript</a><a href="https://juejin.cn/tag/%E7%AE%97%E6%B3%95">算法</a></p><p><a href="https://juejin.cn/post/7067315820937871373">面试官：你都工作3年了，这个算法题都不会？</a></p><ul><li><p>9.9w</p></li><li><p>702</p></li><li><p>244</p></li></ul><p><a href="https://juejin.cn/user/3298190612510792">WaterMan</a></p><p>2年前</p><p><a href="https://juejin.cn/tag/%E9%9D%A2%E8%AF%95">面试</a></p><p><a href="https://juejin.cn/post/6844904147167215624">手撕ts面试题——不能不掌握的ts高级特性（三）</a></p><ul><li><p>1.2w</p></li><li><p>105</p></li><li><p>11</p></li></ul><p><a href="https://juejin.cn/user/4389662909007864">Gaby</a></p><p>1年前</p><p><a href="https://juejin.cn/tag/JavaScript">JavaScript</a><a href="https://juejin.cn/tag/%E9%9D%A2%E8%AF%95">面试</a></p><p><a href="https://juejin.cn/post/7016593221815910408">🔥 连八股文都不懂还指望在前端混下去么</a></p><ul><li><p>64.4w</p></li><li><p>12192</p></li><li><p>605</p></li></ul><p><a href="https://juejin.cn/user/2735240661707479">Web前端严选</a></p><p>2年前</p><p><a href="https://juejin.cn/tag/Vue.js">Vue.js</a></p><p><a href="https://juejin.cn/post/6896748218076364814">Vue3+TS，写一个逼格满满的项目</a></p><ul><li><p>4.3w</p></li><li><p>262</p></li><li><p>47</p></li></ul><p><a href="https://juejin.cn/user/817692381812999">周姐日常事</a></p><p>1年前</p><p><a href="https://juejin.cn/tag/TypeScript">TypeScript</a><a href="https://juejin.cn/tag/%E9%9D%A2%E8%AF%95">面试</a></p><p><a href="https://juejin.cn/post/6999985372440559624">TypeScript TS「面试题及答案」不断更新</a></p><ul><li><p>3.0w</p></li><li><p>363</p></li><li><p>18</p></li></ul><p><a href="https://juejin.cn/user/703321119406919">小杜杜</a></p><p>11月前</p><p><a href="https://juejin.cn/tag/%E5%89%8D%E7%AB%AF">前端</a><a href="https://juejin.cn/tag/TypeScript">TypeScript</a></p><p><a href="https://juejin.cn/post/7088304364078497800">一篇让你完全够用的TS指南</a></p><ul><li><p>4.1w</p></li><li><p>1012</p></li><li><p>89</p></li></ul><p>友情链接：</p><ul><li><a href="https://backend.devrank.cn/traffic-aggregation/1116353">termux安装docker</a></li></ul><p><a href="https://juejin.cn/user/589812812228408"><img src="https://p3-passport.byteimg.com/img/user-avatar/7b5c2c3cf901317b71ba95fdb4ab9cb0~100x100.awebp" alt="img"></a></p><p><a href="https://juejin.cn/user/589812812228408">一起去看星星吧<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2fa3f08a7107485f81157b296fd9d41f~tplv-k3u1fbpfcp-no-mark:0:0:0:0.awebp" alt="lv-5"></a></p><p>关注<a href="https://juejin.cn/notification/im?participantId=589812812228408">私信</a></p><p>获得点赞 2,160</p><p>文章被阅读 104,127</p><p>- </p><p><a href="https://juejin.cn/user/center/signin?from=item"><img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/img/sign-in.d6891e5.png" alt="限时领掘金会员"></a></p><p>相关文章</p><p><a href="https://juejin.cn/post/7170662948656906253">TS泛型进阶272点赞 · 21评论</a><a href="https://juejin.cn/post/7088304364078497800">一篇让你完全够用的TS指南1012点赞 · 89评论</a><a href="https://juejin.cn/post/6979478474620665887">保姆级教程：从零搭建 Webpack5+ts+Vue3 开发环境64点赞 · 9评论</a><a href="https://juejin.cn/post/7091681875583828005">可以实现继承的几种方式0点赞 · 0评论</a><a href="https://juejin.cn/post/6987735091925483551">一文读懂TS的(.d.ts)文件151点赞 · 15评论</a></p><p>目录</p><ul><li><a href="https://juejin.cn/post/7092415149809598500#heading-0">什么是 TypeScript？</a><ul><li><a href="https://juejin.cn/post/7092415149809598500#heading-1">那么 ts 和 js 有什么区别呢？</a><ul><li><a href="https://juejin.cn/post/7092415149809598500#heading-2">什么是类型注解？</a></li></ul></li><li><a href="https://juejin.cn/post/7092415149809598500#heading-3">ts 的类型</a><ul><li><a href="https://juejin.cn/post/7092415149809598500#heading-4">联合类型：</a></li></ul></li><li><a href="https://juejin.cn/post/7092415149809598500#heading-5">类型别名</a></li><li><a href="https://juejin.cn/post/7092415149809598500#heading-6">数组类型</a></li><li><a href="https://juejin.cn/post/7092415149809598500#heading-7">函数</a><ul><li><a href="https://juejin.cn/post/7092415149809598500#heading-8">定义单个函数</a></li><li><a href="https://juejin.cn/post/7092415149809598500#heading-9">统一定义函数格式</a></li><li><a href="https://juejin.cn/post/7092415149809598500#heading-10">函数返回值类型void</a></li><li><a href="https://juejin.cn/post/7092415149809598500#heading-11">函数-可选参数</a></li></ul></li><li><a href="https://juejin.cn/post/7092415149809598500#heading-13">对象类型-单独使用</a><ul><li><a href="https://juejin.cn/post/7092415149809598500#heading-14">对象类型-类型别名</a></li></ul></li><li><a href="https://juejin.cn/post/7092415149809598500#heading-15">接口</a><ul><li><a href="https://juejin.cn/post/7092415149809598500#heading-16">接口继承</a></li></ul></li><li><a href="https://juejin.cn/post/7092415149809598500#heading-17">元组</a><ul><li><a href="https://juejin.cn/post/7092415149809598500#heading-18">字面量类型</a></li><li><a href="https://juejin.cn/post/7092415149809598500#heading-19">枚举</a></li><li><a href="https://juejin.cn/post/7092415149809598500#heading-20">any 类型</a></li></ul></li><li><a href="https://juejin.cn/post/7092415149809598500#heading-21">使用any的场景</a></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> -Ts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -标签1 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二篇文章</title>
      <link href="/2023/01/01/React/"/>
      <url>/2023/01/01/React/</url>
      
        <content type="html"><![CDATA[<p>- </p><h1 id="React｜入门之我终于开始学-习啦"><a href="#React｜入门之我终于开始学-习啦" class="headerlink" title="React｜入门之我终于开始学 习啦"></a>React｜入门之我终于开始学 习啦</h1><p>最开始接触前端框架的时候，我选择了上手更快的 Vue；到目前为止基于 Vue 开发了几个项目，对于 Vue 原理也有了一定的了解，可以说是“熟练使用”了～🌝 最近项目不太忙，我终于…决定开始学 React 了！！！（搓手、激动、👋🏼）</p><p>⤴️ 入门路线：官网入门教程 + 选一本评价还行的 React 书籍 📚</p><h3 id="开始前的准备"><a href="#开始前的准备" class="headerlink" title="开始前的准备"></a>开始前的准备</h3><p>概览一下 React 特点：【虚拟 DOM、状态、单向数据流、组件】</p><ul><li>声明式的视图层 —— JSX，HTML 和 JS 的结合</li><li>简单的更新流程 —— 开发者只负责定义 UI 状态，React 负责渲染</li><li>灵活的渲染实现 —— 虚拟 DOM 可以结合其他库将其渲染到不同终端</li><li>高效的 DOM 操作 —— 虚拟 DOM</li></ul><p>先启动一个 React 项目试试：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install -g create-react-app <span class="comment">// 安装 create-react-app 脚手架</span></span><br><span class="line">create-react-app my-app <span class="comment">// 创建项目 </span></span><br><span class="line">cd my-app/ </span><br><span class="line">npm start <span class="comment">// 启动</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>启动有问题：check： <a href="https://link.juejin.cn/?target=https://create-react-app.dev/docs/getting-started/">create-react-app.dev&#x2F;docs&#x2F;gettin…</a></p><p>兼容问题 node 版本切换：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo n v14<span class="number">.15</span><span class="number">.0</span> <span class="comment">// 某个版本号</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="一、一些基础概念"><a href="#一、一些基础概念" class="headerlink" title="一、一些基础概念"></a>一、一些基础概念</h3><h4 id="1、JSX"><a href="#1、JSX" class="headerlink" title="1、JSX"></a>1、JSX</h4><ul><li>WHAT？</li></ul><p>JSX 是 Javascript 的语法扩展，<code>JSX = Javascript + XML</code>，即在 Javascript 里面写 XML，因为 JSX 的这个特性，所以它既具备了 Javascript 的灵活性，同时又兼具 html 的语义化和直观性。</p><p>比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Title</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Im title~~~<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>在 React 中，JSX 可以生成 <code>React “元素”</code>。【后面会解释什么是 React 元素】</p><ul><li>WHY？</li></ul><p>React 认为渲染逻辑本质上与其他 UI 逻辑内在耦合，比如，在 UI 中需要绑定处理事件、在某些时刻状态发生变化时需要通知到 UI，以及需要在 UI 中展示准备好的数据。React 通过将二者共同存放在称之为“组件”的松散耦合单元之中，来实现关注点分离。</p><p>【不同于 VUE 将 JS 和 HTML 分离开来的方式】</p><ul><li>HOW？</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;Josh Perez&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> element = <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>; <span class="comment">// &#123;&#125;里面可以写 JS 表达式</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">  element,</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 表示将 element 这个 JSX 渲染到 id 为 root 的元素上</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>建议：如果 JSX 有多行的话，用括号括起来。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Good to see you here.<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>Babel 会把 JSX 转译成一个名为 <code>React.createElement()</code> 函数调用，创建对应的 DOM 对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是简化过的结构</span></span><br><span class="line"><span class="keyword">const</span> element = &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&quot;h1&quot;</span>,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">className</span>: <span class="string">&quot;greeting&quot;</span>,</span><br><span class="line">    <span class="attr">children</span>: <span class="string">&quot;Hello, world!&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这些对象被称为 <code>“React 元素”</code>。——【JS对象】</p><p>注意：JSX 中写原生 DOM 属性的时候，<code>class</code> 要写成 <code>className</code>，事件名要写成驼峰形式（<code>onclick </code>-&gt; <code>onClick</code>）。</p><h4 id="2、元素渲染"><a href="#2、元素渲染" class="headerlink" title="2、元素渲染"></a>2、元素渲染</h4><p>要将一个 React 元素渲染到 DOM 节点中，只需把它们一起传入 <code>ReactDOM.render()</code>。如果 UI 要更新，那就需要重新调用 <code>ReactDOM.render()</code>。重新渲染时，React 只会更新变化的部分 —— 虚拟DOM &amp; diff。</p><h4 id="3、组件-amp-props"><a href="#3、组件-amp-props" class="headerlink" title="3、组件 &amp; props"></a>3、组件 &amp; props</h4><p>React 中编写组件有 2 种方式：函数 和 class（类组件）。组件首字母必须大写。</p><p><code>函数组件：</code>【如果组件只有一个 render 方法，没有 state 这些，写成函数组件比较简洁】</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">MyComp</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><code>class组件</code>(等价写法)：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承于 React.Component</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyComp</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props); <span class="comment">// props 是组件接收的参数，super表示执行父类的构造函数，完成初始化</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// render 方法返回需要展示的视图结构——React元素</span></span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>在所有含有构造函数的的 React 组件中，构造函数必须以 <code>super(props)</code> 开头，否则，<code>this.props</code> 在构造函数中可能会出现未定义的 bug。</p><p>类组件需满足两个条件：</p><ul><li><code>class</code> 继承自 <code>React.Component</code>；</li><li><code>class</code> 内部必须定义 <code>render</code> 方法；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">MyComp</span> <span class="attr">name</span>=<span class="string">&quot;A&quot;</span> /&gt;</span> </span></span><br><span class="line"><span class="language-xml">      &#123;/* 子组件会通过 this.props.name 接收到 */&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">MyComp</span> <span class="attr">name</span>=<span class="string">&quot;B&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">MyComp</span> <span class="attr">name</span>=<span class="string">&quot;C&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>传递给子组件之后，子组件得到了一个 <code>props</code> 对象。</p><p><code>props</code> 是父组件向子组件传递值的形式！它具有<code>只读性</code>：所有 React 组件都必须像纯函数一样保护它们的 <code>props</code> 不被更改。【也就是说我们不能在子组件中直接更改 props 哦！】</p><p>React 提供了 <code>PropTypes</code> 对象用于校验 <code>props</code> 的类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">PropTypes</span> <span class="keyword">from</span> <span class="string">&quot;prop-types&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">PropTypes</span>.<span class="property">propTypes</span> = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="title class_">PropTypes</span>.<span class="property">object</span>, <span class="comment">// a 属性是一个对象类型</span></span><br><span class="line">  <span class="attr">b</span>: <span class="title class_">PropTypes</span>.<span class="property">number</span>, <span class="comment">// b 属性是一个数字类型</span></span><br><span class="line">  <span class="attr">c</span>: <span class="title class_">PropTypes</span>.<span class="property">func</span>.<span class="property">isRequired</span>, <span class="comment">// 函数类型，必需</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// defaultProps为属性指定默认值</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Welcome</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Welcome</span>.<span class="property">defaultProps</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;World&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>组件样式： 外部 CSS 和 内联样式</p><ul><li><link> 标签引入：作用于所有组件</li><li>import 引入：scoped 局部样式</li><li>内联样式：<code>&lt;div style=&#123;&#123;color: 'red'&#125;&#125;&gt;&lt;/div&gt;</code> 第一个 {} 表示是 JS 表达式，第二个 {} 表示内部是一个对象，属性名必须使用驼峰式。</li></ul><h4 id="4、生命周期"><a href="#4、生命周期" class="headerlink" title="4、生命周期"></a>4、生命周期</h4><p>⚠️只有类组件才具有生命周期方法，函数组件是没有的哦～</p><p>生命周期具体包括：</p><ul><li>挂载阶段，依次调用：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params"></span>) <span class="comment">// class 的构造方法，在其中 super(props) 接收参数</span></span><br><span class="line"><span class="title function_">componentWillMount</span>() <span class="comment">// 组件挂载前调用，实际比较少用到</span></span><br><span class="line"><span class="title function_">render</span>() <span class="comment">// 组件中定义的方法，返回一个 React 元素，并不负责实际的渲染工作</span></span><br><span class="line"><span class="title function_">componentDidMount</span>() <span class="comment">// 组件被挂载到 DOM 后调用，比如向后端请求一些数据，此时调用 setState 会引起组件的重新渲染</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>更新阶段，组件 props 或者 state 变化，依次调用：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">componentWillReceiveProps</span>(nextProps) <span class="comment">// props 变化时调用，nextProps 是新参数</span></span><br><span class="line"><span class="title function_">shouldComponentUpdate</span>(nextProps, nextState) <span class="comment">// 是否继续执行更新过程，返回一个布尔值</span></span><br><span class="line"><span class="comment">// 通过比较新旧值，如果新旧值相同，该方法会返回 false，后续的更新过程将不再继续，从而优化性能</span></span><br><span class="line"><span class="title function_">componentWillUpdate</span>(nextProps, nextState) <span class="comment">// 更新之前，比较少用到</span></span><br><span class="line"><span class="title function_">render</span>()</span><br><span class="line"><span class="title function_">componentDidUpdate</span>(prevProps, prevState) <span class="comment">// 组件更新之后调用，可以操作更新之后的 DOM 了</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>卸载阶段：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">componentWillUnmount</span>(<span class="params"></span>) &#123; &#125; <span class="comment">// 组件被删除前调用，执行一些清理工作</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="5、state"><a href="#5、state" class="headerlink" title="5、state"></a>5、state</h4><p>在组件中可以设置 state 存放组件自己的数据：【是组件私有的数据！】</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComp</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">time</span>: <span class="keyword">new</span> <span class="title class_">Date</span>(),</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Its &#123;this.state.time&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>不要直接修改 state，而是使用 <code>setState()</code>，React 会【合并】我们设置的 state。每次在组件中调用 <code>setState</code> 时，React 都会自动更新其子组件。</p><p><code>数据流是单向的～</code>只能由父组件流向子组件。</p><p>【<code>不可变性</code>】：一般来说，有两种改变数据的方式。第一种方式是直接修改变量的值，第二种方式是使用新的一份数据替换旧数据。React 推荐使用第二种方式，为什么呢？</p><ul><li>简化复杂的功能</li></ul><p>不可变性使得复杂的特性更容易实现。比如 —— 撤销和恢复功能 在开发中是一个很常见的需求，不直接在数据上修改可以让我们追溯并复用历史记录。</p><ul><li>跟踪数据的改变</li></ul><p>如果直接修改数据，那么就很难跟踪到数据的改变。跟踪数据的改变需要可变对象可以与改变之前的版本进行对比，这样整个对象树都需要被遍历一次。</p><p>跟踪不可变数据的变化相对来说就容易多了。如果发现对象变成了一个新对象，那么我们就可以说对象发生改变了。</p><ul><li>确定在 React 中何时重新渲染</li></ul><p>不可变性最主要的优势在于它可以帮助我们在 React 中创建 pure components。我们可以很轻松的确定不可变数据是否发生了改变，从而确定何时对组件进行重新渲染。</p><h4 id="6、事件处理"><a href="#6、事件处理" class="headerlink" title="6、事件处理"></a>6、事件处理</h4><p>React 的事件命名是采用驼峰式，写法是这样的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;activateLasers&#125;</span>&gt;</span> Activate Lasers <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>处理事件的响应函数要以对象的形式赋值给事件属性，而不是字符串形式。因为 React 中的事件是合成事件，不是原生 DOM 事件。</p><p>在 React 中，有一个命名规范，通常会将代表事件的监听 prop 命名为 on[Event]，将处理事件的监听方法命名为 handle[Event] 这样的格式。</p><p>值得注意的是 React 事件处理中的 <code>this 指向</code>问题：</p><p>（1）箭头函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComp</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">time</span>: <span class="keyword">new</span> <span class="title class_">Date</span>(),</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">handleClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">time</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">button</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">          this.handleClick();</span></span><br><span class="line"><span class="language-xml">        &#125;&#125;</span></span><br><span class="line"><span class="language-xml">      &gt;</span></span><br><span class="line"><span class="language-xml">        按钮</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// this 指向当前组件的实例对象</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这种写法，每次 render 调用时都会重新创建一个新的事件处理函数。</p><p>（2）组件方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComp</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">time</span>: <span class="keyword">new</span> <span class="title class_">Date</span>(),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleClick</span> = <span class="variable language_">this</span>.<span class="property">handleClick</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="comment">// 通过 bind 将这个方法绑定到当前组件实例</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">handleClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">time</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这种写法， render 调用时不会重新创建一个新的事件处理函数，但需要在构造函数中手动绑定 this。</p><p>还有一种选择是，我们可以在为元素事件属性赋值的同时绑定 this：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick.bind(this)&#125;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>（3）属性初始化语法（ES7）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComp</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">time</span>: <span class="keyword">new</span> <span class="title class_">Date</span>(),</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  handleClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">time</span>);</span><br><span class="line">  &#125;; <span class="comment">// 也是箭头函数</span></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>使用官方脚手架 Create React App 创建的项目默认是支持这个特性的，可以在项目中引入 babel 的 transform-class-properties 插件获取这个特性支持。</p><h4 id="7、条件渲染-amp-列表-amp-表单"><a href="#7、条件渲染-amp-列表-amp-表单" class="headerlink" title="7、条件渲染 &amp; 列表 &amp; 表单"></a>7、条件渲染 &amp; 列表 &amp; 表单</h4><p>条件渲染：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Greeting</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> isLoggedIn = props.<span class="property">isLoggedIn</span>;</span><br><span class="line">  <span class="keyword">if</span> (isLoggedIn) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">UserGreeting</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">GuestGreeting</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>列表：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> listItems = numbers.<span class="title function_">map</span>(<span class="function">(<span class="params">number</span>) =&gt;</span>  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;number&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>建议给每个动态列表元素加一个 key ：【和 Vue 类似】，不然控制台会报错</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> listItems = numbers.<span class="title function_">map</span>(<span class="function">(<span class="params">number</span>) =&gt;</span> (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;number.toString()&#125;</span>&gt;</span>&#123;number&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">));</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>表单：如果一个表单元素的值是由 React 管理的，那称它为一个受控组件。</p><p>1）文本框 —— 类型为 text 的 input 元素和 textarea 元素，它们受控的主要原理是，通过表单元素的 value 属性设置表单元素的值，通过表单元素的 onChange 事件监听值的变化，并将变化同步到 React 组件的 state 中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">form</span> <span class="attr">onSubmit</span>=<span class="string">&#123;this.handleSubmit&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          名字:</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&#123;this.state.value&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;this.handleChange&#125;</span> /&gt;</span>        </span></span><br><span class="line"><span class="language-xml">         <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">         <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>2）select 元素 —— 通过在 select 上定义 value 属性来决定哪一个 option 元素处于选中状态。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">select</span> <span class="attr">value</span>=<span class="string">&#x27;2&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&#x27;1&#x27;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&#x27;2&#x27;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&#x27;3&#x27;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// value 为 2 的元素被选中</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>3）复选框和单选框 —— type 为 checkbox 和 radio 的 input 元素，React 控制的是 checked 属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">handleSelectChange</span>(<span class="params">event</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">        [event.<span class="property">target</span>.<span class="property">name</span>]: event.<span class="property">target</span>.<span class="property">checked</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">value</span>=<span class="string">&quot;yes&quot;</span> <span class="attr">name</span>=<span class="string">&quot;yes&quot;</span> <span class="attr">checked</span>=<span class="string">&#123;this.state.yes&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;this.handleSelectChange&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          /&gt;</span></span></span><br><span class="line"><span class="language-xml">          是的</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">value</span>=<span class="string">&quot;no&quot;</span> <span class="attr">name</span>=<span class="string">&quot;no&quot;</span> <span class="attr">checked</span>=<span class="string">&#123;this.state.no&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;this.handleSelectChange&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">         /&gt;</span></span></span><br><span class="line"><span class="language-xml">          不是</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>使用受控组件处理表单状态是比较繁琐的，一种可替代方案时使用非受控组件 —— 表单自己管理状态，React 通过 ref 获取表单的值。这样简化了操作，但是破坏了 React 对组件状态管理的一致性，所以还是少用为好，这里就略过了。</p><p>8、状态提升</p><p>所谓状态提升，就是将多个子组件需要共同维护的数据提升到父组件中去。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">handleChange</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">props</span>.<span class="title function_">onTemperatureChange</span>(e.<span class="property">target</span>.<span class="property">value</span>); <span class="comment">// 触发父组件的事件</span></span><br><span class="line">  <span class="comment">// 和 vue 的 this.$emit 类似</span></span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>当你遇到需要同时获取多个子组件数据，或者两个组件之间需要相互通讯的情况时，需要把子组件的 state 数据提升至其共同的父组件当中保存。之后父组件可以通过 props 将状态数据传递到子组件当中。这样应用当中所有组件的状态数据就能够更方便地同步共享了。</p><h4 id="9、组合-amp-继承"><a href="#9、组合-amp-继承" class="headerlink" title="9、组合 &amp; 继承"></a>9、组合 &amp; 继承</h4><p>React 推荐使用【组合】方式实现代码复用。Props 和组合为你提供了清晰而安全地定制组件外观和行为的灵活方式。</p><p>注意：组件可以接受任意 props，包括基本数据类型，React 元素以及函数。</p><h3 id="二、React-哲学"><a href="#二、React-哲学" class="headerlink" title="二、React 哲学"></a>二、React 哲学</h3><p>React 最棒的部分之一是引导我们思考如何构建一个应用。</p><p>举个例子，假设我们已经拿到了一个设计稿和返回数据的 API：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/608f93fc80f3425caa1948c8034c8056~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p><p><code>第一步</code>：将设计好的 UI 划分为组件层级</p><p>在设计稿上用方框圈出每一个组件，包括它们的子组件，并以合适的名字命名。组件划分原则——<code>单一功能原则</code>：一个组件只负责一个功能。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/92da1595c9164544b1ee57f470877a24~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p><p><code>第二步</code>：用 React 创建一个静态版本</p><p>确定了组件层级，可以编写对应的应用了。最好将渲染 UI 和 添加交互这两个过程分开。</p><p>先用已有的数据模型渲染一个不包含交互的静态 UI。</p><p><code>第三步</code>：确定 UI state 的【最小且完整】表示</p><p>找出应用所需的 state 的最小集合，不要重复或者冗余。【就是说在实现功能的前提下，设置的变量个数尽可能最小】</p><p>比如刚刚的示例应用拥有如下数据：</p><ul><li>包含所有产品的原始列表</li><li>用户输入的搜索词</li><li>复选框是否选中的值</li><li>经过搜索筛选的产品列表</li></ul><p>怎么去 check state 的最小表示呢？问自己三个问题：</p><ul><li>该数据是否是由父组件通过 props 传递而来的？如果是，那它应该不是 state。</li><li>该数据是否随时间的推移而保持不变？如果是，那它应该也不是 state。</li><li>你能否根据其他 state 或 props 计算出该数据的值？如果是，那它也不是 state。</li></ul><p>经过检查，刚刚例子中属于 state 的有：</p><ul><li>用户输入的搜索词</li><li>复选框是否选中的值</li></ul><p><code>第四步</code>：确定 state 放置的位置 —— 哪个组件应该拥有某个 state</p><p>React 中的数据流是单向的，并顺着组件层级从上往下传递。</p><p>对于应用中的每一个 state：</p><ul><li>找到根据这个 state 进行渲染的所有组件。</li><li>找到他们的共同所有者（common owner）组件（在组件层级上高于所有需要该 state 的组件）。</li><li>该共同所有者组件或者比它层级更高的组件应该拥有该 state。</li><li>如果你找不到一个合适的位置来存放该 state，就可以直接创建一个新的组件来存放该 state，并将这一新组件置于高于共同所有者组件层级的位置。</li></ul><p><code>第五步</code>：添加反向数据流</p><p>子组件向父组件传值。</p><p>【官网这个小例子蛮好的，不管是用什么框架，在开发之前先想清楚要怎么划分组件、怎么设置变量，想好再开始写代码或许事半功倍。】</p><h3 id="三、React-16-新特性"><a href="#三、React-16-新特性" class="headerlink" title="三、React 16 新特性"></a>三、React 16 新特性</h3><p>🤡 React 16 之前， render 方法必须返回单个元素，现在支持返回 <code>数组【由 React 元素组成】和 字符串</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;ssss&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>🤡 React 16 之前，组件如果在运行时出错，会阻塞整个应用的渲染，现在有了<code>新的错误处理机制</code>：默认情况下，当组件中抛出错误时，这个组件会从组件树中卸载，从而避免整个应用的崩溃。React 16 还提供了一种更加友好的错误处理方式——<code>错误边界（Error Boundaries）</code>，是能够捕获子组件的错误并对其做优雅处理的组件。优雅的处理可以是输出错误日志、显示出错提示等，显然这比直接卸载组件要更加友好。</p><p>定义了 componentDidCatch(error, info) 这个方法的组件将成为一个错误边界：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ErrorBoundary</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">hasError</span>: <span class="literal">false</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">componentDidCatch</span>(<span class="params">error, info</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">hasError</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(error, info);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">hasError</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>OOPS, 出错了！<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">children</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">ErrorBoundary</span>;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>使用 ErrorBoundary ：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ErrorBoundary</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Example</span>&gt;</span><span class="tag">&lt;/<span class="name">Example</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ErrorBoundary</span>&gt;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>内部组件有异常时，错误会被 ErrorBoundary 捕获，并在界面上显示提示。</p><p>🤡 <code>Portals 特性</code>：可以让我们把组件渲染到当前组件树以外的 DOM 节点上。【和 Vue 的 teleport 作用类似】</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">createPortal</span>(child, container);</span><br><span class="line"><span class="comment">// child 是可以被渲染的 React 元素/元素数组/字符串等</span></span><br><span class="line"><span class="comment">// container 是 child 被挂载的 DOM 节点</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>比如创建一个 Modal 组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&quot;react-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Modal</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">container</span> = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(<span class="variable language_">this</span>.<span class="property">container</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">conponentWillUnmount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">removeChild</span>(<span class="variable language_">this</span>.<span class="property">container</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">ReactDOM</span>.<span class="title function_">createPortal</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>我是 Modal<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>, <span class="variable language_">this</span>.<span class="property">container</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Modal</span>;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这样不论在哪里调用该组件，它都是 body 的最后一个子元素。</p><p>🤡 <code>React Hooks</code>：使用类组件时，有大量的业务逻辑如各类的接口请求需要放在 componentDidMount 和 componentDidUpdate 等生命周期函数中，会使组件变得特别复杂并且难以维护，并且 Class 中的 this 问题也需要特别注意；函数组件虽然能避免 this 问题，但没有生命周期等。</p><p>Hooks 出现之后，可以在函数式组件中去使用 React 的各种特性。</p><p>Hooks 本质是一些特殊的函数，常见的有：</p><p>🎣 <code>useState</code>：使用 state</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, setState] = <span class="title function_">useState</span>(initState);</span><br><span class="line"><span class="comment">// 举个例子</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [state, setState] = <span class="title function_">useState</span>(<span class="string">&quot;Hah&quot;</span>);</span><br><span class="line">  <span class="comment">// 当然这里可以用结构赋值重新命名，whatever u need</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;state&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这里 useState 方法同类组件的方法一样，是异步的。但它没有合并多个 state 的作用。</p><p>🎣 <code>useRef</code>：使用 ref</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useRef &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> el = <span class="title function_">useRef</span>();</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span> <span class="attr">ref</span>=<span class="string">&#123;el&#125;</span>&gt;</span>&#123;state&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">  <span class="comment">// 通过 el.current 可以获得 DOM 节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>🎣 <code>useEffect</code>：处理副作用，诸如网络请求、DOM 操作之类的；相当于 <code>componentDidMount</code> 和 <code>componentDidUpdate</code> 等的集合体。</p><p>举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Course</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [name, setName] = <span class="title function_">useState</span>(<span class="string">&quot;React&quot;</span>);</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;组件挂载或更新&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;清理更新前的一些内容&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, [name]);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">select</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">value</span>=<span class="string">&#123;name&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onChange</span>=<span class="string">&#123;(&#123;</span> <span class="attr">target</span> &#125;) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">          setName(target.value);</span></span><br><span class="line"><span class="language-xml">        &#125;&#125;</span></span><br><span class="line"><span class="language-xml">      &gt;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;React&quot;</span>&gt;</span>React<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;Vue&quot;</span>&gt;</span>Vue<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;JQuery&quot;</span>&gt;</span>JQuery<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Course</span>;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>可以看到，<code>useEffect</code> 接收两个参数，第一个是个函数，第二个是个数组，其中第一个函数返回一个函数，第二个数组表示依赖参数。当依赖参数发生变化时，就会执行回调函数。整个组件的生命周期过程：组件挂载 → 执行副作用（回调函数）→ 组件更新 → 执行清理函数（返还函数）→ 执行副作用（回调函数）→ 组件准备卸载 → 执行清理函数（返还函数）→ 组件卸载。</p><p>如果单纯想在某一个特定的生命周期执行某些操作，可以通过传递的参数不同来实现：</p><ul><li>只在 <code>componentDidMount</code> 执行，可以把依赖参数置为空数组，这样在更新时就不会执行该副作用了。</li><li>只在 <code>componentWillUnmount</code> 执行，同样把依赖参数置为空数组，该副作用的返还函数就会在卸载前执行。</li><li>只在 <code>componentDidUpdate</code> 执行，需要区分更新还是挂载，需要检测依赖数据和初始值是否一致，如果当前的数据和初始数据保持一致就说明是挂载阶段，当然安全起见应和上一次的值进行对比，若当前的依赖数据和上一次的依赖数据完全一样，则说明组件没有更新。这种情况需要借助 <code>useRef</code>，原因在于 ref 如果和数据绑定的话，数据更新时 ref 并不会自动更新，这样就可以获取到更新前数据的值。</li></ul><p>⚠️只能在函数式组件和自定义 Hooks 之中调用 Hooks，普通函数或者类组件中不能使用 Hooks。</p><p>⚠️只能在函数的第一层调用 Hooks。</p><p>自定义 Hooks：可以把一些需要重复使用的逻辑自定义成 Hooks，命名必须要以 use 开头。这里暂时不放例子了。</p><h3 id="四、深入理解组件"><a href="#四、深入理解组件" class="headerlink" title="四、深入理解组件"></a>四、深入理解组件</h3><h4 id="1、state"><a href="#1、state" class="headerlink" title="1、state"></a>1、state</h4><p>我们在组件中用到的与渲染无关的变量，应该定义为组件的普通属性，而不应该放在 state 中。也就是说，render 中没有用到的，都不应该出现在 state 中。</p><p>注意：</p><ul><li>不能直接修改 state，这样不会触发 render。</li><li>state 的更新是异步的，而且 React 可能会将多次状态修改合并为一次更新。【Vue 中有相同的机制，很好理解。】props 的更新也是异步的。</li><li>state 的更新是一个合并的过程。</li></ul><p>React 建议将 state 当作<code>不可变对象</code>，比如当 state 中有数组时，使用 concat、slice、filter 等返回一个新数组的方法，而不是用 push、pop、shift、splice 等直接修改数组的方法。如果有对象时，使用 ES6 的 Object.assign 方法 或者对象扩展语法等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// eg </span></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function"><span class="params">preState</span> =&gt;</span> (&#123; <span class="attr">arr</span>: preState.<span class="property">arr</span>.<span class="title function_">slice</span>(<span class="number">1</span>,<span class="number">3</span>) &#125;)) </span><br><span class="line"><span class="comment">// preState 是旧状态</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="2、组件与服务器通信"><a href="#2、组件与服务器通信" class="headerlink" title="2、组件与服务器通信"></a>2、组件与服务器通信</h4><ul><li>组件挂载阶段通信：<code>componentDidMount</code> 钩子，官方推荐 ✔️</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">componentDidMount</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> that = <span class="variable language_">this</span></span><br><span class="line">    <span class="title function_">fetch</span>(<span class="string">&#x27;/getXXX&#x27;</span>).<span class="title function_">then</span>(<span class="title function_">funtion</span>(<span class="params">response</span>)&#123;</span><br><span class="line">        that.<span class="title function_">setState</span>(&#123;</span><br><span class="line">          <span class="attr">data</span>: response.<span class="property">data</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><code>componentWillMount</code> 钩子会在组件被挂载前调用，也可以从服务端获取数据。如果在服务端渲染，<code>componentWillMount</code> 钩子会被调用两次，而 <code>componentDidMount</code> 钩子 只会被调用一次。所以推荐 <code>componentDidMount</code> 钩子。</p><ul><li>组件更新阶段通信：<code>componentWillReceiveProps(nextProps)</code> 钩子</li></ul><h4 id="3、组件之间通信"><a href="#3、组件之间通信" class="headerlink" title="3、组件之间通信"></a>3、组件之间通信</h4><ul><li>父子组件通信：props</li></ul><p>父传子：props 属性，子传父：回调</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子传父，通过 props 调用父组件的方法</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">props</span>.<span class="title function_">handleClick</span>(xxx)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父组件中</span></span><br><span class="line">&lt;<span class="title class_">Child</span> handleClick=&#123;<span class="variable language_">this</span>.<span class="property">handleClick</span>&#125;&gt;&lt;/<span class="title class_">Child</span>&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>兄弟组件通信：<code>状态提升</code>——把共享的状态保存在离它们最近的公共父组件中，核心还是 props</li><li>Context：组件层级太深时，以 props 为桥梁会很繁琐，React 提供了一个 context 上下文，让任意层级的子组件都可以获得父组件中的状态和方法。创建 context：在提供 context 的组件内新增一个 <code>getChildContext</code> 方法，返回 context 对象，然后在组件的 <code>childContextTypes</code> 属性上定义 context 对象的属性的类型信息。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件 Father</span></span><br><span class="line"><span class="title function_">getChildContext</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">handleClick</span>: <span class="variable language_">this</span>.<span class="property">handleClick</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="title class_">Father</span>.<span class="property">childContextTypes</span> = &#123;</span><br><span class="line">    <span class="attr">handleClick</span>: <span class="title class_">PropTypes</span>.<span class="property">func</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件通过 context 访问</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">context</span>.<span class="title function_">handleClick</span>()</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="title class_">Child</span>.<span class="property">contextTypes</span> = &#123;</span><br><span class="line">    <span class="attr">handleClick</span>: <span class="title class_">PropTypes</span>.<span class="property">func</span></span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>项目复杂时，可以引入 Redux 等状态管理库。</li></ul><h4 id="4、特殊的-ref-——-获取-DOM-元素或组件"><a href="#4、特殊的-ref-——-获取-DOM-元素或组件" class="headerlink" title="4、特殊的 ref —— 获取 DOM 元素或组件"></a>4、特殊的 ref —— 获取 DOM 元素或组件</h4><p>在 DOM 上使用 ref：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">textInput</span>.<span class="title function_">focus</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// render 中</span></span><br><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> ref=&#123; <span class="function">(<span class="params">input</span>) =&gt;</span> &#123; <span class="variable language_">this</span>.<span class="property">textInput</span> = input &#125;&#125;/&gt;</span><br><span class="line"><span class="comment">// input 表示 input 元素</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>在组件上使用 ref：【只能是类组件】</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">inputInstance</span>.<span class="title function_">handleChange</span>() <span class="comment">// 调用通过 ref 获取的 inputInstance 组件实例的 handleChange 方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// render 中</span></span><br><span class="line">&lt;<span class="title class_">Child</span> ref=&#123; <span class="function">(<span class="params">input</span>) =&gt;</span> &#123; <span class="variable language_">this</span>.<span class="property">inputInstance</span> = input &#125;&#125;/&gt;</span><br><span class="line"><span class="comment">// 这里 input 表示组件实例</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="五、虚拟-DOM-和性能优化"><a href="#五、虚拟-DOM-和性能优化" class="headerlink" title="五、虚拟 DOM 和性能优化"></a>五、虚拟 DOM 和性能优化</h3><h4 id="1、虚拟-DOM-——-JS-对象"><a href="#1、虚拟-DOM-——-JS-对象" class="headerlink" title="1、虚拟 DOM —— JS 对象"></a>1、虚拟 DOM —— JS 对象</h4><p>前端性能优化中有一个原则：尽量减少 DOM 操作，而虚拟 DOM 正是这一原则的体现。</p><p>DIFF 算法：对比新旧虚拟 DOM，时间复杂度 O(n)。</p><p>前提假设：</p><p>（1）如果两个元素的类型不同，那么它们将生成两棵不同的树。</p><p>（2）为列表中的元素设置 key 属性，用 key 标识对应的元素在多次 render 过程中是否发生变化。</p><p>具体来说：</p><ul><li>当根节点是不同类型，不会继续比较子节点，直接按照新的虚拟 DOM 生成真实 DOM；</li><li>根节点是相同的 DOM 类型，保留根节点，更新变化了的根节点属性；</li><li>根节点是相同的组件类型，对应的组件实例不会被销毁，只会执行更新操作；</li><li>比较完根节点， React 会以相同的原则递归对比子节点；</li><li>React 给列表提供了一个 key 属性，用来复用列表。</li></ul><h4 id="2、性能优化"><a href="#2、性能优化" class="headerlink" title="2、性能优化"></a>2、性能优化</h4><ul><li>避免不必要的组件渲染，善用 <code>shouldComponentUpdate</code> 钩子，根据具体业务逻辑决定返回 true 或 false；</li><li>使用 key；</li><li>React Developer Tools for Chrome 插件</li><li>why-did-you-update 插件</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ac136ef2d8348bc829489aefd1b66fa~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p><h3 id="六、高阶组件（HOC）-——-组件逻辑的抽象和复用"><a href="#六、高阶组件（HOC）-——-组件逻辑的抽象和复用" class="headerlink" title="六、高阶组件（HOC） —— 组件逻辑的抽象和复用"></a>六、高阶组件（HOC） —— 组件逻辑的抽象和复用</h3><p>– HighOrderComponent</p><h4 id="1、基本概念"><a href="#1、基本概念" class="headerlink" title="1、基本概念"></a>1、基本概念</h4><p>高阶函数：以函数为参数，返回值也是函数的函数。类似地，高阶组件就是以 React 组件为参数，返回一个新的 React 组件的组件。</p><p>和父组件有啥区别呢？高阶组件强调的是<code>逻辑的抽象</code>。高阶组件是一个函数，函数关注的是逻辑；父组件是一个组件，组件主要关注的是 UI&#x2F;DOM。如果逻辑是与 DOM 直接相关的，那么这部分逻辑适合放到父组件中实现；如果逻辑是与 DOM 不直接相关的，那么这部分逻辑适合使用高阶组件抽象，如数据校验、请求发送等。</p><p>比如我们写一个 MyComp 组件，来获取 localStorage 中的数据并显示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComp</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">componentWillMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> data = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&quot;data&quot;</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; data &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.state.data&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>如果其他组件也有这样的逻辑时，试试复用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 高阶组件</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">HocComp</span>(<span class="params">OtherComp</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">React</span>.<span class="property">Component</span> &#123;</span><br><span class="line">    <span class="title function_">componentWillMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> data = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&quot;data&quot;</span>);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; data &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">OtherComp</span> <span class="attr">data</span>=<span class="string">&#123;this.state.data&#125;</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyComp</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.props.data&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MycompWithOther</span> = <span class="title class_">HocComp</span>(<span class="title class_">MyComp</span>);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>可以看出高阶组件的主要功能：<code>封装并分离组件的通用逻辑，让通用逻辑在组件中更好地被复用</code> —— 装饰者设计模式【🚩：后面看一下设计模式】。</p><h4 id="2、使用场景"><a href="#2、使用场景" class="headerlink" title="2、使用场景"></a>2、使用场景</h4><h5 id="1）操纵props"><a href="#1）操纵props" class="headerlink" title="1）操纵props"></a>1）操纵props</h5><p>前面的例子</p><h5 id="2）通过-ref-访问组件实例"><a href="#2）通过-ref-访问组件实例" class="headerlink" title="2）通过 ref 访问组件实例"></a>2）通过 ref 访问组件实例</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">withRef</span>(<span class="params">WrappedComp</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">React</span>.<span class="property">Component</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">      <span class="variable language_">super</span>(props);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">someMethod</span> = <span class="variable language_">this</span>.<span class="property">someMethod</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里保存了 WrappedComp 实例的引用</span></span><br><span class="line">    <span class="title function_">someMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">instance</span>.<span class="title function_">methodOfWrappedComp</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">WrappedComp</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">ref</span>=<span class="string">&#123;(instance)</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">            this.instance = instance;</span></span><br><span class="line"><span class="language-xml">          &#125;&#125;</span></span><br><span class="line"><span class="language-xml">          &#123;...this.props&#125;</span></span><br><span class="line"><span class="language-xml">        /&gt;</span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h5 id="3）组件状态提升"><a href="#3）组件状态提升" class="headerlink" title="3）组件状态提升"></a>3）组件状态提升</h5><p>比如利用高阶组件将原本受控组件需要自己维护的状态统一提升到高阶组件中。</p><h5 id="4）用其他元素包装组件"><a href="#4）用其他元素包装组件" class="headerlink" title="4）用其他元素包装组件"></a>4）用其他元素包装组件</h5><p>比如增加布局或者修改样式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">withRedBg</span>(<span class="params">WrappedComp</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">React</span>.<span class="property">Component</span> &#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">backgroundColor:</span> &quot;<span class="attr">red</span>&quot; &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">WrappedComp</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="3、参数传递"><a href="#3、参数传递" class="headerlink" title="3、参数传递"></a>3、参数传递</h4><p>高阶组件除了接收组件作为参数外，还可以接收其他参数。比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 高阶组件</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">HocComp</span>(<span class="params">OtherComp, key</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">React</span>.<span class="property">Component</span> &#123;</span><br><span class="line">    <span class="title function_">componentWillMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> data = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(key);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; data &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">OtherComp</span> <span class="attr">data</span>=<span class="string">&#123;this.state.data&#125;</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyComp</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.props.data&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MycompWithOther</span> = <span class="title class_">HocComp</span>(<span class="title class_">MyComp</span>, <span class="string">&quot;data&quot;</span>);</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MycompWithOther</span> = <span class="title class_">HocComp</span>(<span class="title class_">MyComp</span>, <span class="string">&quot;username&quot;</span>);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="4、继承方式实现高阶组件"><a href="#4、继承方式实现高阶组件" class="headerlink" title="4、继承方式实现高阶组件"></a>4、继承方式实现高阶组件</h4><p>继承方式实现的高阶组件常用于渲染劫持。例如，当用户处于登录状态时，允许组件渲染；否则渲染一个空组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">withAuth</span>(<span class="params">WrappedComp</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">WrappedComp</span> &#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">isLogin</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">super</span>.<span class="title function_">render</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="七、项目实战之-Router-和-Redux"><a href="#七、项目实战之-Router-和-Redux" class="headerlink" title="七、项目实战之 Router 和 Redux"></a>七、项目实战之 Router 和 Redux</h3><h4 id="1、React-Router-基本用法"><a href="#1、React-Router-基本用法" class="headerlink" title="1、React Router 基本用法"></a>1、React Router 基本用法</h4><p>React Router 包含3个库：<code>react-router、react-router-dom 和 react-router-native</code>。</p><ul><li>react-router 提供最基本的路由功能，实际使用时，根据应用运行的环境选择安装 react-router-dom（在浏览器中使用）或react-router-native（在 react-native 中使用）。</li><li>react-router-dom 和 react-router-native 都依赖于 react-router，所以在安装时，react-router 也会自动安装。</li></ul><p>在 Web 应用中安装 <code>react-router-dom</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install react-router-dom</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>React Router 通过 <code>Router 和 Route</code> 两个组件完成路由功能。Router 可以理解成路由器，一个应用中只需要一个 Router 实例，所有的路由配置组件 Route 都定义为 Router 的子组件。【和 VueRouer 类似】</p><p>在 Web 应用中，一般会根据路由的实现方式分为：</p><ul><li><code>BrowserRouter</code>：基于 H5 的 history API，</li><li><code>HashRouter</code>：基于 hash</li></ul><p>Route 是 React Router 中用于配置路由信息的组件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Route</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router&#x27;</span></span><br><span class="line">&lt;<span class="title class_">Route</span> path=<span class="string">&#x27;/&#x27;</span> /&gt; <span class="comment">// path  匹配路径，匹配之后会创建一个 match 对象作为 props 中的一个属性传递给被渲染的组件</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/&#x27;</span> <span class="attr">component</span>=<span class="string">&#123;Home&#125;</span> /&gt;</span></span> <span class="comment">// 匹配时，渲染 Home 组件</span></span><br><span class="line"><span class="comment">// 也可以写为</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/&#x27;</span> <span class="attr">render</span>=<span class="string">&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  (<span class="attr">props</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Home</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span></span><br><span class="line"><span class="language-xml">  &#125;</span></span><br><span class="line"><span class="language-xml">&#125; /&gt;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>如果只想让匹配到的第一个 Route 渲染，可以使用 Switch：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">    <span class="title class_">BrowserRouter</span> <span class="keyword">as</span> <span class="title class_">Router</span>, <span class="comment">// 注意这里</span></span><br><span class="line">    <span class="title class_">Switch</span>,</span><br><span class="line">    <span class="title class_">Route</span>,</span><br><span class="line">    <span class="title class_">Link</span></span><br><span class="line">  &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 比如首页导航，exact 精确匹配</span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Router</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Route</span> <span class="attr">exact</span> <span class="attr">path</span>=<span class="string">&#x27;/&#x27;</span> <span class="attr">component</span>=<span class="string">&#123;Home&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/about&#x27;</span> <span class="attr">component</span>=<span class="string">&#123;About&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/user&#x27;</span> <span class="attr">component</span>=<span class="string">&#123;User&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">Router</span>&gt;</span></span></span><br><span class="line"><span class="comment">// 不使用 Switch 的话，/about/user 这个路径会匹配上面三个 Route，都会被渲染</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>Link 组件定义了点击时页面如何路由：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;button&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&#x27;/login&#x27;</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span>&lt;/button&gt;</span><br><span class="line"><span class="comment">// to 也可以是一个对象</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">pathname:</span> &#x27;/<span class="attr">login</span>&#x27;,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">state:</span> &#123;<span class="attr">isLogin</span> <span class="attr">:</span> <span class="attr">false</span>&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">&#125;&#125; /&gt;</span></span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>Redirect 组件用于页面重定向：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Redirect</span> to = &#123;xxx&#125;/&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>在非路由组件中获取路由信息：<code>withRouter 和 Router Hooks</code>。</p><p>withRouter 的作用有点类似于 Redux 中的 connect，把要获取路由信息的组件传入 withRouter，withRouter 会把路由信息传递给该组件，并会返回一个新的组件，来方便其他地方调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; withRouter &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">backBtn</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; history &#125; = props;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">button</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">        history.goBack();</span></span><br><span class="line"><span class="language-xml">      &#125;&#125;</span></span><br><span class="line"><span class="language-xml">    &gt;</span></span><br><span class="line"><span class="language-xml">      返回上一页</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">backBtn = <span class="title function_">withRouter</span>(backBtn);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> backBtn;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>除了使用 withRouter 来为非路由组件获取路由信息之外，在Router5.x中新增加了 Router Hooks，使用规则和 React 的其他 Hooks 一致。</p><p>1）useHistory： 调用该 Hook 会返回 history 对象</p><p>2）useLocation：调用该 Hook 会返回 location 对象</p><p>3）useRouteMatch：调用该 Hook 会返回 match 对象</p><p>4）useParams：调用该 Hook 会返回 match 对象中的 params，也就是 path 传递的参数</p><h4 id="2、Redux-基本用法-——-状态管理机，和-Vuex-类似"><a href="#2、Redux-基本用法-——-状态管理机，和-Vuex-类似" class="headerlink" title="2、Redux 基本用法 —— 状态管理机，和 Vuex 类似"></a>2、Redux 基本用法 —— 状态管理机，和 Vuex 类似</h4><p>比如我们有一个 TODO 事项的数据对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">todoList</span>: [&#123;</span><br><span class="line">        <span class="attr">text</span>: <span class="string">&#x27;吃饭&#x27;</span>,</span><br><span class="line">        <span class="attr">finished</span>: <span class="literal">false</span></span><br><span class="line">    &#125;,&#123;</span><br><span class="line">        <span class="attr">text</span>: <span class="string">&#x27;睡觉&#x27;</span>,</span><br><span class="line">        <span class="attr">finished</span>: <span class="literal">false</span></span><br><span class="line">    &#125;,&#123;</span><br><span class="line">        <span class="attr">text</span>: <span class="string">&#x27;打豆豆&#x27;</span>,</span><br><span class="line">        <span class="attr">finished</span>: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">visibilityFilter</span>: <span class="string">&#x27;SHOW_FINISHED&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>如果我们需要修改数据，必须发送一个 <code>action</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">type</span>: <span class="string">&#x27;ADD_TODO&#x27;</span>, <span class="attr">text</span>: <span class="string">&#x27;运动&#x27;</span> &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>type 表示 action 的类型，这是 action 必须包含的字段，其他的不是确定的。如何解析 action 呢？Redux 利用 reducer 解析 action，reducer 是一个普通的 JS 函数，接收 action为参数，返回一个新的应用状态 state。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">todoApp</span>(<span class="params">state = &#123;&#125;, action</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;ADD_TODO&quot;</span>:</span><br><span class="line">    <span class="comment">// return new state</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;XXXX&quot;</span>:</span><br><span class="line">    <span class="comment">// return new state</span></span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>以上就是 Redux 的基础概念：<code>store【数据容器】、state【数据对象】、action【修改命令】、reducer</code>。</p><p>Redux 应用需要遵循<code>三大原则</code>：</p><ul><li>唯一数据源：只维护一个全局的状态对象，存储在 Redux 的 store 中</li><li>保持应用状态只读：不能直接修改状态，而是基于 action 修改</li><li>状态的改变通过纯函数完成：action 表示修改状态的意图，真正执行的是 reducer，reducer 必须是纯函数</li></ul><p>【PS：所谓<code>纯函数</code>，就是：对于同样的输入，函数总是有同样的输出，且函数的执行不会产生副作用，比如修改外部对象或输出到 I&#x2F;O 设备】</p><h5 id="1）action：通过-store-的-dispatch-方法分发"><a href="#1）action：通过-store-的-dispatch-方法分发" class="headerlink" title="1）action：通过 store 的 dispatch 方法分发"></a>1）action：通过 store 的 dispatch 方法分发</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// action creater，返回 action</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addTodo</span>(<span class="params">text</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;ADD_TODO&quot;</span>,</span><br><span class="line">    text,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h5 id="2）reducer：描述应用发生了什么操作，根据-action-做出响应"><a href="#2）reducer：描述应用发生了什么操作，根据-action-做出响应" class="headerlink" title="2）reducer：描述应用发生了什么操作，根据 action 做出响应"></a>2）reducer：描述应用发生了什么操作，根据 action 做出响应</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reducer</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">todoApp</span>(<span class="params">state = &#123;&#125;, action</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;ADD_TODO&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        <span class="attr">todoList</span>: [</span><br><span class="line">          ...state.<span class="property">todoList</span>,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">text</span>: action.<span class="property">text</span>,</span><br><span class="line">            <span class="attr">finished</span>: <span class="literal">false</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h5 id="3）store：对象："><a href="#3）store：对象：" class="headerlink" title="3）store：对象："></a>3）store：对象：</h5><ul><li>保存状态</li><li>通过 getState() 访问状态</li><li>通过 dispatch(action) 发送更新状态的 action</li><li>通过 subscribe(listener) 注册监听函数，监听状态改变</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">todoApp</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(todoApp, initState)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取状态</span></span><br><span class="line"><span class="keyword">const</span> state = store.<span class="title function_">getState</span>()</span><br><span class="line"><span class="comment">// 发送 action</span></span><br><span class="line">store.<span class="title function_">dispatch</span>(<span class="title function_">addTodo</span>(<span class="string">&#x27;吃饭&#x27;</span>))</span><br><span class="line"><span class="comment">// 注册监听函数</span></span><br><span class="line"><span class="keyword">let</span> listener = store.<span class="title function_">subscribe</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(store.<span class="title function_">getState</span>()) <span class="comment">// 状态更新时，获取最新的状态</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 取消监听，直接调用 store.subscribe 返回的函数即可</span></span><br><span class="line"><span class="title function_">listener</span>()</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>Redux 的<code>数据流过程</code>：</p><p>（1）调用 <code>store.dispatch(action)</code>。一个 action 是一个用于描述“发生了什么”的对象。<code>store.dispatch(action)</code> 可以在应用的任何地方调用，包括组件、XHR 的回调、定时器。</p><p>（2）Redux 的 store <code>调用 reducer 函数</code>。store 传递两个参数给 reducer：当前应用的状态和 action。reducer 必须是一个纯函数，它的唯一职责是计算下一个应用的状态。</p><p>（3）根 reducer 会把多个子 reducer 的返回结果组<code>合成最终的应用状态</code>。根 reducer 的构建形式完全取决于用户。Redux 提供了 combineReducers，方便把多个拆分的子reducer 组合到一起，但完全可以不使用它。当使用 combineReducers 时，action 会传递给每一个子 reducer 处理，子 reducer 处理后的结果会合并成最终的应用状态。</p><p>（4）Redux 的 store 保存根 reducer 返回的完整应用状态。此时，应用状态才完成更新。如果 UI 需要根据应用状态进行更新，那么这就是更新 UI 的时机。对于 React 应用而言，可以在这个时候调用组件的 setState 方法，根据新的应用状态更新 UI。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de08de45e7794e39a15d820659d5c176~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p><p>使用 Redux：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install react-redux</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>根据意图的不同，组件可以分为容器组件和展示组件：</p><ul><li>容器组件：负责逻辑</li><li>展示组件：负责 UI</li></ul><p>react-redux 提供了一个 <code>connect 函数</code>，用于把 React 组件和 Redux 的 store 连接起来，生成一个容器组件，负责数据管理和业务逻辑：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">&quot;react-redux&quot;</span>;</span><br><span class="line"><span class="comment">// 这里有个组件 TodoList</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">VisibleTodoList</span> = <span class="title function_">connect</span>()(<span class="title class_">TodoList</span>); <span class="comment">// 创建了一个容器组件</span></span><br><span class="line"><span class="comment">// 传递两个参数，让这个容器组件同步状态变化</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">VisibleTodoList</span> = <span class="title function_">connect</span>(mapStateToProps, mapDispatchToProps)(<span class="title class_">TodoList</span>);</span><br><span class="line"><span class="comment">//   mapStateToProps 和 mapDispatchToProps 都是函数</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>react-redux 提供了一个 <code>Provider 组件</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示意代码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Provider</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">getChildContext</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">store</span>: <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">store</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">children</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Provider</span>.<span class="property">childContextTypes</span> = &#123;</span><br><span class="line">  <span class="attr">store</span>: <span class="title class_">React</span>.<span class="property">PropTypes</span>.<span class="property">object</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 把 store 保存到 context</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>Provider 组件通过 context 把 store 传递给子组件，所以一般将 Provider 组件<code>用作根组件</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&quot;redux&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Provider</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react-redux&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">render</span>(</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Provider</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">App</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span>,</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>)</span><br><span class="line">);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="3、React-Redux"><a href="#3、React-Redux" class="headerlink" title="3、React + Redux"></a>3、React + Redux</h4><p>1）如何组织项目结构？</p><ul><li>按照类型：components、containers、actions等，同类型的文件组织在一起</li><li>按照页面功能：一个页面功能对应一个文件夹，里面包括 components、action等</li><li>Ducks：<a href="https://link.juejin.cn/?target=https://github.com/erikras/ducks-modular-redux">github.com&#x2F;erikras&#x2F;duc…</a> 以应用的状态作为划分模块的依据</li></ul><p>2）设计 state：像设计数据库一样设计 state</p><ul><li>把整个应用的状态按照领域分成若干子状态，子状态之间不能保存重复的数据</li><li>state 以键值对的结构存储数据，以记录的 key 或 ID 作为记录的索引，记录中的其他字段都依赖于索引</li><li>state 中不能保存可以通过 state 中的已有字段计算而来的数据，即 state 中的字段不互相依赖</li></ul><h3 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h3><p>至此算是完成了 React 入门，在了解 React 的过程中，感受之一是 React 对于 JavaScript 基础的要求更高一些，比如 this 指向、高阶函数、class 这些，而且抽象程度也更高，比如高阶组件、Redux 中间件等等，其中每一个点都值得深挖学习。</p><p>Anyway，总算开始学习 React 了，“框架是相通的”这句话不假，有 Vue 的使用经验能在很大程度上帮助我对 React 的理解。后续打算写一写小 demo 增加对 React 的熟练度，同时慢慢了解下原理性的东西。🔑</p><p>分类：</p><p><a href="https://juejin.cn/frontend">前端</a></p><p>标签：</p><p><a href="https://juejin.cn/tag/React.js">React.js</a><a href="https://juejin.cn/tag/%E5%89%8D%E7%AB%AF">前端</a></p><p><a href="https://juejin.cn/extension/?utm_source=standalone&utm_medium=post&utm_campaign=extension_promotion">安装掘金浏览器插件</a></p><p>多内容聚合浏览、多引擎快捷搜索、多工具便捷提效、多模式随心畅享，你想要的，这里都有！</p><p><a href="https://juejin.cn/extension/?utm_source=standalone&utm_medium=post&utm_campaign=extension_promotion">前往安装</a></p><p>相关小册</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1646d797b8c34de6b4d323657f430635~tplv-k3u1fbpfcp-no-mark:420:420:300:420.awebp" alt="「Babel 插件通关秘籍」封面"></p><p>VIP</p><p> Babel 插件通关秘籍</p><p><a href="https://juejin.cn/user/2788017216685118">zxg_神说要有光<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/549f476f5e9146848df91d2cd912fe61~tplv-k3u1fbpfcp-no-mark:0:0:0:0.awebp" alt="lv-7"><img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/162b40efbd71af9a806dd2b54c4580ef.svg" alt="img"></a></p><p>5264购买</p><p>¥24.95</p><p>¥49.9</p><p>首单券后价</p><p>首单券后价</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22cb14cfcc6047419eb4e1bfea62a57d~tplv-k3u1fbpfcp-no-mark:420:420:300:420.awebp" alt="「玩转 CSS 的艺术之美」封面"></p><p>VIP</p><p> 玩转 CSS 的艺术之美</p><p><a href="https://juejin.cn/user/2330620350432110">JowayYoung<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/549f476f5e9146848df91d2cd912fe61~tplv-k3u1fbpfcp-no-mark:0:0:0:0.awebp" alt="lv-7"><img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/07302452a7ad81cb43a173b5cd580237.svg" alt="img"></a></p><p>4652购买</p><p>¥9.95</p><p>¥19.9</p><p>首单券后价</p><p>首单券后价</p><p>评论</p><p><img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/58aaf1326ac763d8a1054056f3b7f2ef.svg" alt="img"></p><p>看完啦，</p><p>登录</p><p>分享一下感受吧～</p><p>全部评论 5</p><p>最新</p><p>最热</p><p><a href="https://juejin.cn/user/831671363182168"><img src="https://p3-passport.byteimg.com/img/mosaic-legacy/3795/3047680722~100x100.awebp" alt="SAM9029的头像"></a></p><p><a href="https://juejin.cn/user/831671363182168">SAM9029<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad1d5b8ec0974b0bbc14446acdd7c20d~tplv-k3u1fbpfcp-no-mark:0:0:0:0.awebp" alt="lv-2"><img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/cf19b122213ebdbd25b66f02500b8c27.svg" alt="掘友等级"></a></p><p>Good at JavaStupid!4月前</p><p>强者，react的入门解析，逻辑清晰，基础点知识明了，层级划分由浅入深，可见博主技术与写作的能力之实力恐怖如斯，在下佩服<img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/img/jj_emoji_29.2801857.png" alt="[奋斗]">；随便请问有没有推荐的入门学习视频？</p><p>1</p><p>回复</p><p><a href="https://juejin.cn/user/431440356458382"><img src="https://p3-passport.byteimg.com/img/user-avatar/ffec397d84c42b0c278afcb98f2ba66a~100x100.awebp" alt="snowingfox的头像"></a></p><p><a href="https://juejin.cn/user/431440356458382">snowingfox<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a3f5a3e7550645a08184e5c4247cc3d4~tplv-k3u1fbpfcp-no-mark:0:0:0:0.awebp" alt="lv-3"><img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/8c6985e2aa4c06f307ae3734da4b43ac.svg" alt="掘友等级"></a></p><p>HFUT7月前</p><p>class Compoennt….你学的什么</p><p>点赞</p><p>1</p><p><a href="https://juejin.cn/user/1125498171427054"><img src="https://p3-passport.byteimg.com/img/user-avatar/c563fc2e60a498e8eace019bb3120e78~100x100.awebp" alt="img"></a></p><p><a href="https://juejin.cn/user/1125498171427054">程序猿小灰</a></p><p>（作者）7月前</p><p>还是有很多老项目在用class Component 的<img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/img/jj_emoji_51.e6d838e.png" alt="[机智]">（不过我最近也开始用 hooks 了hhh</p><p>点赞</p><p>回复</p><p><a href="https://juejin.cn/user/3510115640551789"><img src="https://p3-passport.byteimg.com/img/user-avatar/43f0d8893334e7e03f8b018e905ab8e3~100x100.awebp" alt="小刘是个技术菜的头像"></a></p><p><a href="https://juejin.cn/user/3510115640551789">小刘是个技术菜<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad1d5b8ec0974b0bbc14446acdd7c20d~tplv-k3u1fbpfcp-no-mark:0:0:0:0.awebp" alt="lv-2"><img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/cf19b122213ebdbd25b66f02500b8c27.svg" alt="掘友等级"></a></p><p>10月前</p><p>老铁你写掘金用的什么写的，样式这么好看</p><p>点赞</p><p>1</p><p><a href="https://juejin.cn/user/1125498171427054"><img src="https://p3-passport.byteimg.com/img/user-avatar/c563fc2e60a498e8eace019bb3120e78~100x100.awebp" alt="img"></a></p><p><a href="https://juejin.cn/user/1125498171427054">程序猿小灰</a></p><p>（作者）10月前</p><p>掘金的 markdown 主题～</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/138f0cda50cb4bcaac062b03dcfeff28~tplv-k3u1fbpfcp-no-mark:320:320:320:320.awebp" alt="image"></p><p>点赞</p><p>回复</p><p>相关推荐</p><p><a href="https://juejin.cn/user/2576910988093293">西门吹喵</a></p><p>3年前</p><p><a href="https://juejin.cn/tag/React.js">React.js</a></p><p><a href="https://juejin.cn/post/6844904072168865800">终于搞懂 React Hooks了！！！！！</a></p><ul><li><p>5.1w</p></li><li><p>1137</p></li><li><p>103</p></li></ul><p><a href="https://juejin.cn/user/4001878052973400">Marno</a></p><p>4年前</p><p>[React Native](<a href="https://juejin.cn/tag/React">https://juejin.cn/tag/React</a> Native)<a href="https://juejin.cn/tag/Flutter">Flutter</a></p><p><a href="https://juejin.cn/post/6844903795504201742">React Native 团队怎么看待 Flutter 的？终于有官方回复了</a></p><ul><li><p>3.7w</p></li><li><p>87</p></li><li><p>62</p></li></ul><p><a href="https://juejin.cn/user/4019470240582311">voanit</a></p><p>3年前</p><p><a href="https://juejin.cn/tag/%E5%89%8D%E7%AB%AF">前端</a></p><p><a href="https://juejin.cn/post/6844903974437388295">前端框架用vue还是react？清晰对比两者差异</a></p><ul><li><p>6.2w</p></li><li><p>759</p></li><li><p>70</p></li></ul><p><a href="https://juejin.cn/user/4098589725834317">字节前端</a></p><p>1年前</p><p><a href="https://juejin.cn/tag/React.js">React.js</a><a href="https://juejin.cn/tag/%E5%89%8D%E7%AB%AF">前端</a></p><p><a href="https://juejin.cn/post/6952696734078369828">React + TypeScript实践</a></p><ul><li><p>4.2w</p></li><li><p>975</p></li><li><p>17</p></li></ul><p><a href="https://juejin.cn/user/1742041823325422">柯尔茶</a></p><p>3月前</p><p><a href="https://juejin.cn/tag/%E5%89%8D%E7%AB%AF">前端</a><a href="https://juejin.cn/tag/React.js">React.js</a></p><p><a href="https://juejin.cn/post/7173953093158060039">当公司要求你必须会 React，Vueer 不得不学</a></p><ul><li><p>3.3w</p></li><li><p>272</p></li><li><p>93</p></li></ul><p><a href="https://juejin.cn/user/3544481220801815">CUGGZ</a></p><p>1月前</p><p><a href="https://juejin.cn/tag/%E5%89%8D%E7%AB%AF">前端</a><a href="https://juejin.cn/tag/JavaScript">JavaScript</a><a href="https://juejin.cn/tag/Vite">Vite</a></p><p><a href="https://juejin.cn/post/7195398724040785976">React团队回应用Vite替换Create React App的建议</a></p><ul><li><p>4.2w</p></li><li><p>182</p></li><li><p>68</p></li></ul><p><a href="https://juejin.cn/user/3949101466785709">ConardLi</a></p><p>11月前</p><p><a href="https://juejin.cn/tag/%E5%89%8D%E7%AB%AF">前端</a><a href="https://juejin.cn/tag/JavaScript">JavaScript</a><a href="https://juejin.cn/tag/React.js">React.js</a></p><p><a href="https://juejin.cn/post/7085542534943883301">2022 年的 React 生态</a></p><ul><li><p>10.0w</p></li><li><p>2698</p></li><li><p>220</p></li></ul><p><a href="https://juejin.cn/user/4248168658899741">乘风gg</a></p><p>3年前</p><p><a href="https://juejin.cn/tag/React.js">React.js</a><a href="https://juejin.cn/tag/TypeScript">TypeScript</a></p><p><a href="https://juejin.cn/post/6844903849166110728">可能是你需要的 React + TypeScript 50 条规范和经验</a></p><ul><li><p>7.8w</p></li><li><p>1330</p></li><li><p>100</p></li></ul><p><a href="https://juejin.cn/user/1838039171075352">彭道宽</a></p><p>3年前</p><p><a href="https://juejin.cn/tag/React.js">React.js</a></p><p><a href="https://juejin.cn/post/6844903988794671117">由浅到深的React合成事件</a></p><ul><li><p>2.3w</p></li><li><p>156</p></li><li><p>35</p></li></ul><p><a href="https://juejin.cn/user/1714893870865303">摸鱼的春哥</a></p><p>1年前</p><p><a href="https://juejin.cn/tag/%E5%89%8D%E7%AB%AF">前端</a><a href="https://juejin.cn/tag/Vue.js">Vue.js</a><a href="https://juejin.cn/tag/React.js">React.js</a></p><p><a href="https://juejin.cn/post/7066951709678895141">浅谈：为啥vue和react都选择了Hooks🏂？</a></p><ul><li><p>15.2w</p></li><li><p>2925</p></li><li><p>297</p></li></ul><p><a href="https://juejin.cn/user/3896324939067608">创宇前端</a></p><p>5年前</p><p><a href="https://juejin.cn/post/6844903555921362952">React + Electron 搭建一个桌面应用</a></p><ul><li><p>5.3w</p></li><li><p>429</p></li><li><p>35</p></li></ul><p><a href="https://juejin.cn/user/3535628726188280">MoonLight</a></p><p>1年前</p><p><a href="https://juejin.cn/tag/React.js">React.js</a><a href="https://juejin.cn/tag/%E5%89%8D%E7%AB%AF">前端</a></p><p><a href="https://juejin.cn/post/6960262593265025031">React快速暴力入门</a></p><ul><li><p>1.5w</p></li><li><p>277</p></li><li><p>26</p></li></ul><p><a href="https://juejin.cn/user/2330620350435501">王大冶</a></p><p>3年前</p><p><a href="https://juejin.cn/tag/React.js">React.js</a><a href="https://juejin.cn/tag/JavaScript">JavaScript</a></p><p><a href="https://juejin.cn/post/6844903988073070606">35 道咱们必须要清楚的 React 面试题</a></p><ul><li><p>6.7w</p></li><li><p>1009</p></li><li><p>47</p></li></ul><p><a href="https://juejin.cn/user/3562073402638798">ReactNative开发圈</a></p><p>5年前</p><p><a href="https://juejin.cn/tag/React.js">React.js</a><a href="https://juejin.cn/tag/JavaScript">JavaScript</a><a href="https://juejin.cn/tag/%E9%9D%A2%E8%AF%95">面试</a></p><p><a href="https://juejin.cn/post/6844903583368871943">React Native面试知识点</a></p><ul><li><p>1.7w</p></li><li><p>149</p></li><li><p>评论</p></li></ul><p><a href="https://juejin.cn/user/2418581313687390">我不是外星人</a></p><p>2年前</p><p><a href="https://juejin.cn/tag/React.js">React.js</a><a href="https://juejin.cn/tag/JavaScript">JavaScript</a></p><p><a href="https://juejin.cn/post/6944863057000529933">「react进阶」一文吃透react-hooks原理</a></p><ul><li><p>7.5w</p></li><li><p>2272</p></li><li><p>144</p></li></ul><p><a href="https://juejin.cn/user/1943592291009511">魔术师卡颂</a></p><p>1年前</p><p><a href="https://juejin.cn/tag/%E5%89%8D%E7%AB%AF">前端</a><a href="https://juejin.cn/tag/React.js">React.js</a></p><p><a href="https://juejin.cn/post/7021748242308136991">React全新文档终于来了</a></p><ul><li><p>1.9w</p></li><li><p>137</p></li><li><p>18</p></li></ul><p><a href="https://juejin.cn/user/4248168660738606">Xieyezi</a></p><p>2年前</p><p><a href="https://juejin.cn/tag/%E5%89%8D%E7%AB%AF">前端</a></p><p><a href="https://juejin.cn/post/6844904183934484494">2020了，还不开始学react吗？| react 入门必知必会知识点(万字总结✍)</a></p><ul><li><p>3.0w</p></li><li><p>558</p></li><li><p>34</p></li></ul><p><a href="https://juejin.cn/user/993614240680983">0x7e2</a></p><p>5年前</p><p><a href="https://juejin.cn/tag/Angular.js">Angular.js</a><a href="https://juejin.cn/tag/React.js">React.js</a><a href="https://juejin.cn/tag/Vue.js">Vue.js</a></p><p>[<a href="https://juejin.cn/post/6844903511835017230">译] 2017 年比较 Angular、React、Vue 三剑客</a></p><ul><li><p>6.2w</p></li><li><p>922</p></li><li><p>89</p></li></ul><p><a href="https://juejin.cn/user/3949101466785709">ConardLi</a></p><p>3年前</p><p><a href="https://juejin.cn/tag/React.js">React.js</a><a href="https://juejin.cn/tag/%E5%89%8D%E7%AB%AF">前端</a></p><p><a href="https://juejin.cn/post/6844903815762673671">【React深入】从Mixin到HOC再到Hook</a></p><ul><li><p>6.6w</p></li><li><p>988</p></li><li><p>61</p></li></ul><p><a href="https://juejin.cn/user/2418581313687390">我不是外星人</a></p><p>8月前</p><p><a href="https://juejin.cn/tag/React.js">React.js</a><a href="https://juejin.cn/tag/JavaScript">JavaScript</a><a href="https://juejin.cn/tag/%E5%89%8D%E7%AB%AF">前端</a></p><p><a href="https://juejin.cn/post/7118937685653192735">「React 进阶」 React 全部 Hooks 使用大全 （包含 React v18 版本 ）</a></p><ul><li><p>5.0w</p></li><li><p>1302</p></li><li><p>110</p></li></ul><p>友情链接：</p><ul><li><a href="https://backend.devrank.cn/traffic-aggregation/1081637">touppercase java</a></li><li><a href="https://backend.devrank.cn/traffic-aggregation/1081644">c ado sql语句</a></li><li><a href="https://backend.devrank.cn/traffic-aggregation/1081649">网络av数据结构面板</a></li><li><a href="https://frontend.devrank.cn/traffic-aggregation/140175">json反序列化 节点</a></li><li><a href="https://backend.devrank.cn/traffic-aggregation/1081601">sqlserver 2008 发布订阅</a></li><li><a href="https://backend.devrank.cn/traffic-aggregation/1102015">java文件分割器</a></li></ul><p><a href="https://juejin.cn/user/1125498171427054"><img src="https://p3-passport.byteimg.com/img/user-avatar/c563fc2e60a498e8eace019bb3120e78~100x100.awebp" alt="img"></a></p><p><a href="https://juejin.cn/user/1125498171427054">程序猿小灰<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05be64d75fee4dbdb290ba23afd21fcf~tplv-k3u1fbpfcp-no-mark:0:0:0:0.awebp" alt="lv-4"></a></p><p>前端攻城狮🦁️ @ ByteDance</p><p>关注<a href="https://juejin.cn/notification/im?participantId=1125498171427054">私信</a></p><p>获得点赞 602</p><p>文章被阅读 39,516</p><p>- </p><p><a href="https://juejin.cn/user/center/signin?from=item"><img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/img/sign-in.d6891e5.png" alt="限时领掘金会员"></a></p><p>相关文章</p><p><a href="https://juejin.cn/post/6960262593265025031">React快速暴力入门277点赞 · 26评论</a><a href="https://juejin.cn/post/6844904183934484494">2020了，还不开始学react吗？| react 入门必知必会知识点(万字总结✍)558点赞 · 34评论</a><a href="https://juejin.cn/post/7041483613514235934">webpack｜学习总结：知其原理，手写一个 mini-webpack11点赞 · 0评论</a><a href="https://juejin.cn/post/7021748242308136991">React全新文档终于来了137点赞 · 18评论</a><a href="https://juejin.cn/post/7088883914005184525">面经｜三四月前端面试问题记录499点赞 · 57评论</a></p><p>目录</p><ul><li><a href="https://juejin.cn/post/7046218136177082398#heading-0">开始前的准备</a></li><li><a href="https://juejin.cn/post/7046218136177082398#heading-1">一、一些基础概念</a><ul><li><a href="https://juejin.cn/post/7046218136177082398#heading-2">1、JSX</a></li><li><a href="https://juejin.cn/post/7046218136177082398#heading-3">2、元素渲染</a></li><li><a href="https://juejin.cn/post/7046218136177082398#heading-4">3、组件 &amp; props</a></li><li><a href="https://juejin.cn/post/7046218136177082398#heading-5">4、生命周期</a></li><li><a href="https://juejin.cn/post/7046218136177082398#heading-6">5、state</a></li><li><a href="https://juejin.cn/post/7046218136177082398#heading-7">6、事件处理</a></li><li><a href="https://juejin.cn/post/7046218136177082398#heading-8">7、条件渲染 &amp; 列表 &amp; 表单</a></li><li><a href="https://juejin.cn/post/7046218136177082398#heading-9">9、组合 &amp; 继承</a></li></ul></li><li><a href="https://juejin.cn/post/7046218136177082398#heading-10">二、React 哲学</a></li><li><a href="https://juejin.cn/post/7046218136177082398#heading-11">三、React 16 新特性</a></li><li><a href="https://juejin.cn/post/7046218136177082398#heading-12">四、深入理解组件</a><ul><li><a href="https://juejin.cn/post/7046218136177082398#heading-13">1、state</a></li><li><a href="https://juejin.cn/post/7046218136177082398#heading-14">2、组件与服务器通信</a></li><li><a href="https://juejin.cn/post/7046218136177082398#heading-15">3、组件之间通信</a></li><li><a href="https://juejin.cn/post/7046218136177082398#heading-16">4、特殊的 ref —— 获取 DOM 元素或组件</a></li></ul></li><li><a href="https://juejin.cn/post/7046218136177082398#heading-17">五、虚拟 DOM 和性能优化</a><ul><li><a href="https://juejin.cn/post/7046218136177082398#heading-18">1、虚拟 DOM —— JS 对象</a></li><li><a href="https://juejin.cn/post/7046218136177082398#heading-19">2、性能优化</a></li></ul></li><li><a href="https://juejin.cn/post/7046218136177082398#heading-20">六、高阶组件（HOC） —— 组件逻辑的抽象和复用</a><ul><li><a href="https://juejin.cn/post/7046218136177082398#heading-21">1、基本概念</a></li><li><a href="https://juejin.cn/post/7046218136177082398#heading-22">2、使用场景</a><ul><li><a href="https://juejin.cn/post/7046218136177082398#heading-23">1）操纵props</a></li><li><a href="https://juejin.cn/post/7046218136177082398#heading-24">2）通过 ref 访问组件实例</a></li><li><a href="https://juejin.cn/post/7046218136177082398#heading-25">3）组件状态提升</a></li><li><a href="https://juejin.cn/post/7046218136177082398#heading-26">4）用其他元素包装组件</a></li></ul></li><li><a href="https://juejin.cn/post/7046218136177082398#heading-27">3、参数传递</a></li><li><a href="https://juejin.cn/post/7046218136177082398#heading-28">4、继承方式实现高阶组件</a></li></ul></li><li><a href="https://juejin.cn/post/7046218136177082398#heading-29">七、项目实战之 Router 和 Redux</a><ul><li><a href="https://juejin.cn/post/7046218136177082398#heading-30">1、React Router 基本用法</a></li><li><a href="https://juejin.cn/post/7046218136177082398#heading-31">2、Redux 基本用法 —— 状态管理机，和 Vuex 类似</a><ul><li><a href="https://juejin.cn/post/7046218136177082398#heading-32">1）action：通过 store 的 dispatch 方法分发</a></li><li><a href="https://juejin.cn/post/7046218136177082398#heading-33">2）reducer：描述应用发生了什么操作，根据 action 做出响应</a></li><li><a href="https://juejin.cn/post/7046218136177082398#heading-34">3）store：对象：</a></li></ul></li><li><a href="https://juejin.cn/post/7046218136177082398#heading-35">3、React + Redux</a></li></ul></li><li><a href="https://juejin.cn/post/7046218136177082398#heading-36">八、总结</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> -React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -标签5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇文章</title>
      <link href="/2023/01/01/git/"/>
      <url>/2023/01/01/git/</url>
      
        <content type="html"><![CDATA[<h1 id="01、认识一下Git！—简介"><a href="#01、认识一下Git！—简介" class="headerlink" title="01、认识一下Git！—简介"></a>01、认识一下Git！—简介</h1><p>Git是当前最先进、最主流的<strong>分布式</strong>版本控制系统，免费、开源！核心能力就是版本控制。再具体一点，就是面向代码文件的版本控制，代码的任何修改历史都会被记录管理起来，意味着可以恢复到到以前的任意时刻状态。支持跨区域多人协作编辑，是团队项目开发的必备基础，所以Git也就成了程序员的必备技能。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bff72050dee7400db8045109f8ca6119~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image"></p><p><strong>🟢主要特点</strong>：</p><ul><li>开源免费，使用广泛。</li><li>强大的文档（代码）的历史版本管理，直接记录完整快照（完整内容，而非差异），支持回滚、对比。</li><li>分布式多人协作的的代码协同开发，几乎所有操作都是本地执行的，支持代码合并、代码同步。</li><li>简单易用的分支管理，支持高效的创建分支、合并分支。</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05512798305d4a20a38fd3b89be2b6e0~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"></p><p>Git是Linux之父被迫开发的，为了解决Linux混乱的代码管理而开发的。Linux和Git之父 <strong>李纳斯·托沃兹</strong>（Linus Benedic Torvalds），来自1969年的芬兰。</p><hr><h1 id="02、Git是干什么的？—基础概念"><a href="#02、Git是干什么的？—基础概念" class="headerlink" title="02、Git是干什么的？—基础概念"></a>02、Git是干什么的？—基础概念</h1><p>先了解下Git的基本概念，及基本框架、工作流程。</p><h2 id="2-1、Git概念汇总🔥"><a href="#2-1、Git概念汇总🔥" class="headerlink" title="2.1、Git概念汇总🔥"></a>2.1、Git概念汇总🔥</h2><table><thead><tr><th><strong>概念名称</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>工作区</strong>（Workspace）</td><td>就是在电脑里能看到的代码库目录，是我们搬砖的地方，新增、修改的文件会提交到暂存区</td></tr><tr><td><strong>暂存区</strong>（stage 或 index）</td><td>用于临时存放文件的修改，实际上上它只是一个文件（<code>.git/index</code>），保存待提交的文件列表信息。</td></tr><tr><td><strong>版本库&#x2F;仓库</strong>（Repository）</td><td>Git的管理仓库，管理版本的数据库，记录文件&#x2F;目录状态的地方，所有内容的修改记录（版本）都在这里。</td></tr><tr><td><strong>服务端&#x2F;远程仓库</strong>（origin 或 remote）</td><td>服务端的版本库，专用的Git服务器，为多人共享提供服务，承担中心服务器的角色。本地版本库通过push指令把代码推送到服务端版本库。</td></tr><tr><td><strong>本地仓库</strong></td><td>用户机器上直接使用的的的版本库</td></tr><tr><td><strong>分支</strong>（Branch）</td><td>分支是从主线分离出去的“副本”，可以独立操作而互不干扰，仓库初始化就有一个默认主分支<code>master</code>。</td></tr><tr><td><strong>头</strong>（HEAD）</td><td>HEAD类似一个“指针”，指向当前活动 <strong>分支</strong> 的 <strong>最新版本</strong>。</td></tr><tr><td><strong>提交</strong>（Commit）</td><td>把暂存区的所有变更的内容提交到当前仓库的活动分支。</td></tr><tr><td><strong>推送</strong>（Push）</td><td>将本地仓库的版本推送到服务端（远程）仓库，与他人共享。</td></tr><tr><td><strong>拉取</strong>（Pull）</td><td>从服务端（远程）仓库获取更新到本地仓库，获取他人共享的更新。</td></tr><tr><td><strong>获取</strong>（Fetch）</td><td>从服务端（远程）仓库更新，作用同拉取（Pull），区别是不会自动合并。</td></tr><tr><td><strong>冲突</strong>（Conflict）</td><td>多人对同一文件的工作副本进行更改，并将这些更改合并到仓库时就会面临冲突，需要人工合并处理。</td></tr><tr><td><strong>合并</strong>（Merge）</td><td>对有冲突的文件进行合并操作，Git会自动合并变更内容，无法自动处理的冲突内容会提示人工处理。</td></tr><tr><td><strong>标签</strong>（Tags）</td><td>标签指的是某个分支某个特定时间点的状态，可以理解为提交记录的别名，常用来标记版本。</td></tr><tr><td><strong>master</strong>（或main）</td><td>仓库的“<code>master</code>”分支，默认的主分支，初始化仓库就有了。Github上创建的仓库默认名字为“<code>main</code>”</td></tr><tr><td><strong>origin&#x2F;master</strong></td><td>表示远程仓库（<code>origin</code>）的“<code>master</code>”分支</td></tr><tr><td><strong>origin&#x2F;HEAD</strong></td><td>表示远程仓库（<code>origin</code>）的最新提交的位置，一般情况等于“<code>origin/master</code>”</td></tr></tbody></table><h2 id="2-2、工作区-x2F-暂存区-x2F-仓库"><a href="#2-2、工作区-x2F-暂存区-x2F-仓库" class="headerlink" title="2.2、工作区&#x2F;暂存区&#x2F;仓库"></a>2.2、工作区&#x2F;暂存区&#x2F;仓库</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/091ebdafedb746d98b5340fa107c8d1b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"></p><p>工作区、暂存区、版本库是Git最基本的概念，关系如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c97776f4f3b64b1e979dde63e634847e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image"></p><p><strong>🔸工作区</strong>（Workspace）就是在电脑里能看到的代码库目录，是我们搬砖的地方，新增、修改的文件会提交到暂存区。</p><ul><li>在这里新增文件、修改文件内容，或删除文件。</li></ul><p><strong>🔸暂存区</strong>（stage或index） 用于临时存放文件的修改，实际上上它只是一个文件（.git&#x2F;index），保存待提交的文件列表信息。</p><ul><li>用<code>git add</code> 命令将工作区的修改保存到暂存区。</li></ul><p><strong>🔸版本库&#x2F;仓库</strong>（Repository &#x2F;rɪˈpɑːzətɔːri&#x2F; 仓库）Git的管理仓库，管理版本的数据库，记录文件&#x2F;目录状态的地方，所有内容的修改记录（版本）都在这里。就是工作区目录下的隐藏文件夹<code>.git</code>，包含暂存区、分支、历史记录等信息。</p><ul><li>用<code>git commit</code> 命令将暂存区的内容正式提交到版本库。</li><li><code>master</code> 为仓库的默认分支<code>master</code>，<strong>HEAD</strong>是一个“指针”指向当前分支的最新提交，默认指向最新的<code>master</code>。</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b886c1cb4844010a76409ff36beb458~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image"></p><p>如上图，为对应本地仓库目录的结构关系。</p><ul><li><code>KWebNote</code>为项目目录，也就是Git工作区。</li><li>项目根目录下隐藏的<code>.git</code>目录就是Git仓库目录了，存放了所有Git管理的信息。</li><li><code>.git/config</code>为该仓库的配置文件，可通过指令修改或直接修改。</li><li><code>index</code>文件就是存放的暂存区内容。</li></ul><h2 id="2-3、Git基本流程（图）"><a href="#2-3、Git基本流程（图）" class="headerlink" title="2.3、Git基本流程（图）"></a>2.3、Git基本流程（图）</h2><p>Git的工作流程核心就下面几个步骤，掌握了就可以开始写Bug了。</p><ul><li>0、<strong>准备仓库</strong>：创建或从服务端克隆一个仓库。</li><li>1、<strong>搬砖</strong>：在工作目录中添加、修改代码。</li><li>2、<strong>暂存</strong>（git add）：将需要进行版本管理的文件放入暂存区域。</li><li>3、<strong>提交</strong>（git commit）：将暂存区域的文件提交到Git仓库。</li><li>4、<strong>推送</strong>（git push）：将本地仓库推送到远程仓库，同步版本库。</li><li>5、<strong>获取更新</strong>（fetch&#x2F;pull）：从服务端更新到本地，获取他人推送的更新，与他人协作、共享。</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/666f0c95490744bbafe060f5d44c22b0~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image"></p><ul><li><code>git commit -a</code>指令省略了<code>add</code>到暂存区的步骤，直接提交工作区的修改内容到版本库，不包括新增的文件。</li><li><code>git fetch</code>、<code>git pull</code> 都是从远程服务端获取最新记录，区别是<code>git pull</code>多了一个步骤，就是自动合并更新工作区。</li><li><code>git checkout .</code>、<code>git checkout [file]</code> 会清除工作区中未添加到暂存区的修改，用暂存区内容替换工作区。</li><li><code>git checkout HEAD .</code>、<code> git checkout HEAD [file]</code> 会清除工作区、暂存区的修改，用HEAD指向的当前分支最新版本替换暂存区、工作区。</li><li><code>git diff</code> 用来对比不同部分之间的区别，如暂存区、工作区，最新版本与未提交内容，不同版本之间等。</li><li><code>git reset</code>是专门用来撤销修改、回退版本的指令，替代上面<code>checkout</code>的撤销功能。</li></ul><h2 id="2-4、Git状态（图）"><a href="#2-4、Git状态（图）" class="headerlink" title="2.4、Git状态（图）"></a>2.4、Git状态（图）</h2><p>Git在执行提交的时候，不是直接将工作区的修改保存到仓库，而是将暂存区域的修改保存到仓库。要提交文件，首先需要把文件加入到暂存区域中。因此，Git管理的文件有三（+2）种状态：</p><ul><li>未跟踪（untracked）：新添加的文件，或被移除跟踪的文件，未建立跟踪，通过<code>git add</code>添加暂存并建立跟踪。</li><li>未修改：从仓库签出的文件默认状态，修改后就是“已修改”状态了。</li><li><strong>已修改</strong>（modified）：文件被修改后的状态。</li><li><strong>已暂存</strong>（staged）：修改、新增的文件添加到暂存区后的状态。</li><li><strong>已提交</strong>(committed)：从暂存区提交到版本库。</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f78be8de167c4fcc89b814ffda2e92f7~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image"></p><hr><h1 id="03、起步：Git安装配置"><a href="#03、起步：Git安装配置" class="headerlink" title="03、起步：Git安装配置"></a>03、起步：Git安装配置</h1><p>Git官网：<a href="https://link.juejin.cn/?target=https://www.git-scm.com/">www.git-scm.com/</a> 下载安装包进行安装。Git的使用有两种方式：</p><ul><li><strong>命令行</strong>：Git的命令通过系统命令行工具，或Git提供的命令行工具运行（<code>C:\Program Files\Git\git-bash.exe</code>）</li><li><strong>GUI工具</strong>：Windows(GUI)、Mac(GUI)工具，需单独安装，使用更简单、更易上手。</li></ul><p>指令<code>git --version</code>查看安装版本号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git --version</span><br><span class="line">git version 2.33.0.windows.2</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><blockquote><p>📢 本文是在Windows 平台上完成的，不过这个对学习Git没什么影响。</p></blockquote><h2 id="3-1、Git的配置文件"><a href="#3-1、Git的配置文件" class="headerlink" title="3.1、Git的配置文件"></a>3.1、Git的配置文件</h2><p>Git有三个主要的配置文件：三个配置文件的优先级是<strong>① &lt; ② &lt; ③</strong></p><ul><li><strong>① 系统全局配置</strong>(–system)：包含了适用于系统所有用户和所有仓库（项目）的配置信息，存放在Git安装目录下<code>C:\Program Files\Git\etc\gitconfig</code>。</li><li><strong>② 用户全局配置</strong>(–global)：当前系统用户的全局配置，存放用户目录：<code>C:\Users\[系统用户名]\.gitconfig</code>。</li><li><strong>③ 仓库&#x2F;项目配置</strong>(–local)：仓库（项目）的特定配置，存放在项目目录下<code>.git/config</code></li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/31c076f9d4b64b4eadba339a8113559c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看git配置</span></span><br><span class="line">git config --list</span><br><span class="line">git config -l</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看系统配置</span></span><br><span class="line">git config --system --list</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看当前用户（global）全局配置</span></span><br><span class="line">git config --list --global</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看当前仓库配置信息</span></span><br><span class="line">git config --<span class="built_in">local</span>  --list</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>仓库的配置是上面多个配置的集合：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git config --list</span><br><span class="line">$ git config -l</span><br><span class="line">diff.astextplain.textconv=astextplain</span><br><span class="line">http.sslbackend=openssl</span><br><span class="line">http.sslcainfo=C:/Program Files/Git/mingw64/ssl/certs/ca-bundle.crt</span><br><span class="line">core.autocrlf=<span class="literal">true</span></span><br><span class="line">core.fscache=<span class="literal">true</span></span><br><span class="line">core.symlinks=<span class="literal">false</span></span><br><span class="line">pull.rebase=<span class="literal">false</span></span><br><span class="line">credential.helper=manager-core</span><br><span class="line">credential.https://dev.azure.com.usehttppath=<span class="literal">true</span></span><br><span class="line">init.defaultbranch=master</span><br><span class="line">user.name=Kanding</span><br><span class="line">user.email=123anding@163.com</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h2 id="3-2、配置-初始化用户"><a href="#3-2、配置-初始化用户" class="headerlink" title="3.2、配置-初始化用户"></a>3.2、配置-初始化用户</h2><p>当安装Git后首先要做的事情是配置你的用户信息—— 告诉Git你是谁？配置 <strong>用户名</strong>、<strong>邮箱地址</strong>，每次提交文件时都会带上这个用户信息，查看历史记录时就知道是谁干的了。</p><p>配置用户信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&quot;Your Name&quot;</span></span><br><span class="line">$ git config --global user.email <span class="string">&quot;email@example.com&quot;</span></span><br><span class="line"><span class="comment"># 配置完后，看看用户配置文件：</span></span><br><span class="line">$ <span class="built_in">cat</span> <span class="string">&#x27;C:\Users\Kwongad\.gitconfig&#x27;</span></span><br><span class="line">[user]</span><br><span class="line">        name = Kanding</span><br><span class="line">        email = 123anding@163.com</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li><code>user.name</code>为用户名，<code>user.email</code>为邮箱。</li><li><code>--global</code>：<code>config</code>的参数，表示用户全局配置。如果要给特定仓库配置用户信息，则用参数<code>--local</code>配置即可，或直接在仓库配置文件<code>.git/config</code>里修改。</li></ul><h2 id="3-3、配置-忽略-gitignore"><a href="#3-3、配置-忽略-gitignore" class="headerlink" title="3.3、配置-忽略.gitignore"></a>3.3、配置-忽略.gitignore</h2><p>工作目录中的文件并不是全都需要纳入版本管理，如日志、临时文件、私有配置文件等不需要也不能纳入版本管理，那该怎么办呢？</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/042a124fa2fe41b1b64791ffb2c192ec~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"></p><p>在工作区根目录下创建“<code>.gitignore</code>”文件，文件中配置不需要进行版本管理的文件、文件夹。“<code>.gitignore</code>”文件本身是被纳入版本管理的，可以共享。有如下规则：</p><ul><li><code>#</code>符号开头为注释。</li><li>可以使用Linux通配符。<ul><li>星号（*）代表任意多个字符，</li><li>问号（？）代表一个字符，</li><li>方括号（[abc]）代表可选字符范围，</li><li>大括号（{string1,string2,…}）代表可选的字符串等。</li></ul></li><li>感叹号（<code>!</code>）开头：表示例外规则，将不被忽略。</li><li>路径分隔符（&#x2F;f）<strong>开头</strong>：，表示要忽略<strong>根目录</strong>下的<strong>文件</strong><code>f</code>。</li><li>路径分隔符（f&#x2F;）<strong>结尾</strong>：，表示要忽略<strong>文件夹</strong><code>f</code>下面的所有文件。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#为注释</span></span><br><span class="line">*.txt <span class="comment">#忽略所有“.txt”结尾的文件</span></span><br><span class="line">!lib.txt <span class="comment">#lib.txt除外</span></span><br><span class="line">/temp <span class="comment">#仅忽略项目根目录下的temp文件,不包括其它目录下的temp，如不包括“src/temp”</span></span><br><span class="line">build/ <span class="comment">#忽略build/目录下的所有文件</span></span><br><span class="line">doc/*.txt <span class="comment">#会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><blockquote><p>📢 各种语言项目的常用<code>.gitignore</code>文件配置：<a href="https://link.juejin.cn/?target=https://github.com/github/gitignore">github.com&#x2F;github&#x2F;giti…</a></p></blockquote><hr><h1 id="04、Git的GUI工具们"><a href="#04、Git的GUI工具们" class="headerlink" title="04、Git的GUI工具们"></a>04、Git的GUI工具们</h1><p>如果不想用命令行工具，完全可以安装一个Git的GUI工具，用的更简单、更舒服。不用记那么多命令了，极易上手，不过Git基础还是需要学习了解一下的。</p><blockquote><p>❓对于Git，建议用命令行，这样你才能真的理解Git的思想？ ✔️其实都只是工具而已，适合自己的就是最好的，没必要纠结，多写点Bug更重要！</p></blockquote><ul><li><p>TortoiseGit</p><p>：小乌龟，SVN时代就很流行的代码管理GUI利器。</p><ul><li>🚫只有Windows版本，支持中文，需要单独下载安装中文语言包。</li><li>✔️开源，免费，与文件管理器的良好集成。</li><li>✔️内置冲突对比解决工具。</li></ul></li><li><p>Sourcetree</p><p>：SourceTree是老牌的Git GUI管理工具了，也号称是最好用的Git GUI工具。</p><ul><li>✔️适用于 Windows 和 Mac 系统，内置中文版，自动识别语言。</li><li>✔️免费、功能强大，使用简单。</li><li>✔️功能丰富，基本操作和高级操作都设计得非常流畅，适合初学者上手，支持Git Flow。</li><li>🚫无冲突对比工具，支持配置第三方组件。</li></ul></li><li><p><a href="https://link.juejin.cn/?target=https://desktop.github.com/">GitHub Desktop</a>：Github官方出品的Git管理工具。</p></li><li><p><a href="https://link.juejin.cn/?target=https://www.gitkraken.com/">GitKraken</a>：GitKraken是一个跨平台GUI Git客户端，有免费版，专业版和企业版，这些版本启用了不同的功能。</p></li></ul><h2 id="4-1、SourceTree"><a href="#4-1、SourceTree" class="headerlink" title="4.1、SourceTree"></a>4.1、SourceTree</h2><p>SourceTree的<a href="https://link.juejin.cn/?target=https://www.sourcetreeapp.com/">官网</a> 下载安装包，支持Window、Mac系统，按照提示完成安装。</p><ul><li>SourceTree支持管理多个仓库，通过+按钮，可选择多种方式添加仓库。</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/938e73a171c745efa3f279d98f60dd79~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"></p><ul><li>然后就是可视化的仓库管理了，不用记住繁琐的指令（参数）了，可视化操作。</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1384a781a80042faaf754c0de52b8d6d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image"></p><h2 id="4-2、TortoiseGit"><a href="#4-2、TortoiseGit" class="headerlink" title="4.2、TortoiseGit"></a>4.2、TortoiseGit</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8165d603319245278464511ad2cc71cb~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"></p><p><a href="https://link.juejin.cn/?target=https://tortoisegit.org/">TortoiseGit</a> 官网下载安装包，及中文语言包，按照提示完成安装。小乌龟的Git是集成到操作系统里的，直接右键文件夹就可以进行Git操作了。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dca67d3a374d41e0bbae7b5d66c8b0e1~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"></p><ul><li>先进入设置：右键文件夹菜单 –&gt; TortoiseGit –&gt; Settings 进入设置，设置中文语言。</li><li>小乌龟的各种Git操作都在右键菜单了，深度集成到了操作系统的资源管理器中了，文件图标也是有Git状态的，比较容易分辨。</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5d4597b570744fbda1cf1879103a0511~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7494f0ff8dae4e1c8029fc1640938229~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"></p><h2 id="4-3、VSCode中的Git"><a href="#4-3、VSCode中的Git" class="headerlink" title="4.3、VSCode中的Git"></a>4.3、VSCode中的Git</h2><p>VSCode自带的Git工具基本已经可以满足日常使用了，既有可视化功能，也能敲命令，习惯了不就不用安装其他GUI工具了。不过还是可以再安装一些VSCode插件，来增强Git功能。</p><ul><li><strong>GitLens</strong> ：在团队项目开发中非常实用，必备！！！用于快速查看代码提交历史记录，在代码上会显示最近的修改信息，包括提交者，只就这一点就值得推荐了。</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c02bbef03d445b6b3c3e5ce64ae632b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"></p><ul><li><strong>Git History</strong>：可以轻松快速浏览Git文件操作历史记录的工具，可视化展示，操作简单。</li></ul><hr><h1 id="05、Git使用入门"><a href="#05、Git使用入门" class="headerlink" title="05、Git使用入门"></a>05、Git使用入门</h1><h2 id="5-1、创建仓库"><a href="#5-1、创建仓库" class="headerlink" title="5.1、创建仓库"></a>5.1、创建仓库</h2><p>创建本地仓库的方法有两种：</p><ul><li>一种是创建全新的仓库：<code>git init</code>，会在当前目录初始化创建仓库。</li><li>另一种是克隆远程仓库：<code>git clone [url]</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 准备一个文件夹“KwebNote”作为仓库目录，命令行进入该文件夹</span></span><br><span class="line">Kwongad@Kwongad-T14 MINGW64 ~</span><br><span class="line">$ <span class="built_in">cd</span> d:</span><br><span class="line">Kwongad@Kwongad-T14 MINGW64 /d</span><br><span class="line">$ <span class="built_in">cd</span> Project_Files</span><br><span class="line">Kwongad@Kwongad-T14 MINGW64 /d/Project_Files</span><br><span class="line"><span class="comment"># 多次cd指令进入到仓库目录KwebNote：“cd &lt;目录名称&gt;”指令进入目录，“cd ..”返回上级目录（有空格）</span></span><br><span class="line">Kwongad@Kwongad-T14 MINGW64 /d/Project_Files/github.kwong/KwebNote</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始初始化项目，也可指定目录：git init [文件目录]</span></span><br><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> D:/Project_Files/github.Kwong/KwebNote/.git/</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><blockquote><p><strong>📢注意</strong>：Git指令的执行，都需在仓库目录下。</p></blockquote><p>创建完多出了一个被隐藏的<code>.git</code>目录，这就是本地仓库Git的工作场所。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/183d6f2e27c34fe8a1dad03d190ad108~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"></p><p>克隆远程仓库，如在github上创建的仓库“<code>https://github.com/kwonganding/KWebNote.git</code>”</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> <span class="string">&#x27;https://github.com/kwonganding/KWebNote.git&#x27;</span></span><br><span class="line">Cloning into <span class="string">&#x27;KWebNote&#x27;</span>...</span><br><span class="line">remote: Enumerating objects: 108, <span class="keyword">done</span>.</span><br><span class="line">remote: Counting objects: 100% (108/108), <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (60/60), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 108 (delta 48), reused 88 (delta 34), pack-reused 0</span><br><span class="line">Receiving objects: 100% (108/108), 9.36 KiB | 736.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">Resolving deltas: 100% (48/48), <span class="keyword">done</span>.</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>会在当前目录下创建“KWebNote”项目目录。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/377739fca6a740819ce778c705e9cd22~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"></p><h2 id="5-2、暂存区add"><a href="#5-2、暂存区add" class="headerlink" title="5.2、暂存区add"></a>5.2、暂存区add</h2><p>可以简单理解为，<code>git add</code>命令就是把要提交的所有修改放到暂存区（Stage），然后，执行<code>git commit</code>就可以一次性把暂存区的所有修改提交到仓库。</p><table><thead><tr><th><strong>指令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>git add [file1] [file2]</td><td>添加文件到暂存区，包括修改的文件、新增的文件</td></tr><tr><td>git add [dir]</td><td>同上，添加目录到暂存区，包括子目录</td></tr><tr><td>git add .</td><td>同上，添加<strong>所有</strong>修改、新增文件（未跟踪）到暂存区</td></tr><tr><td>git rm [file]</td><td>删除工作区文件，并且将这次删除放入暂存区</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加指定文件到暂存区，包括被修改的文件</span></span><br><span class="line">$ git add [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加当前目录的所有文件到暂存区</span></span><br><span class="line">$ git add .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除工作区文件，并且将这次删除放入暂存区</span></span><br><span class="line">$ git <span class="built_in">rm</span> [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 改名文件，并且将这个改名放入暂存区</span></span><br><span class="line">$ git <span class="built_in">mv</span> [file-original] [file-renamed]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>修改文件“R.md”，未暂存：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/69ca93a857ca45769ae56f0492f1d9c6~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"></p><p>执行<code>git add .</code>暂存：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c5ebb71c0bb4bec9a5fa9284c70e8f7~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"></p><h2 id="5-3、提交commit-记录"><a href="#5-3、提交commit-记录" class="headerlink" title="5.3、提交commit-记录"></a>5.3、提交commit-记录</h2><p><code>git commit</code>提交是以时间顺序排列被保存到数据库中的，就如游戏关卡一样，每一次提交（commit）就会产生一条记录：<code>id + 描述 + 快照内容</code>。</p><ul><li><strong>🔸commit id</strong>：根据修改的文件内容采用摘要算法（SHA1）计算出不重复的40位字符，这么长是因为Git是分布式的，要保证唯一性、完整性，一般本地指令中可以只用前几位（6）。即使多年以后，依然可通过<code>id</code>找到曾经的任何内容和变动，再也不用担心丢失了。</li><li><strong>🔸描述</strong>：针对本次提交的描述说明，建议<strong>准确</strong>填写，就跟代码中的注释一样，很重要。</li><li><strong>🔸快照</strong>：就是完整的版本文件，以对象树的结构存在仓库下<code>\.git\objects</code>目录里，这也是Git效率高的秘诀之一。</li></ul><blockquote><ul><li>SHA1 是一种哈希算法，可以用来生成数据摘要</li><li>Git不适合大的非文本文件，会影响计算摘要、快照的性能。</li></ul></blockquote><p>多个提交就形成了一条时间线，每次提交完，会移动当前分支<code>master</code>、<code>HEAD</code>的“指针”位置。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a3233f335334f30902d0255ff1a6477~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image"></p><p>Sourcetree上的历史记录：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/77c51e33545943dcb2833872ca9fa798~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"></p><blockquote><p>📢一般情况，每完成一个小功能、一个Bu就可以提交一次，这样会形成比较清晰的历史记录。</p></blockquote><p><strong>🔥指令：</strong></p><table><thead><tr><th><strong>指令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>git commit -m ‘说明’</td><td>提交变更，参数<code>-m</code>设置提交的描述信息，应该正确提交，不带该参数会进入说明编辑模式</td></tr><tr><td>git commit -a</td><td>参数<code>-a</code>，表示直接从工作区提交到版本库，略过了<code>git add</code>步骤，不包括新增的文件</td></tr><tr><td>git commit [file]</td><td>提交暂存区的指定文件到仓库区</td></tr><tr><td>git commit –amend -m</td><td>使用一次新的<code>commit</code>，替代上一次提交，会修改<code>commit</code>的<code>hash</code>值（id）</td></tr><tr><td>git log -n20</td><td>查看日志(最近20条)，不带参数<code>-n</code>则显示所有日志</td></tr><tr><td>git log -n20 –oneline</td><td>参数“<code>--oneline</code>”可以让日志输出更简洁（一行）</td></tr><tr><td>git log -n20 –graph</td><td>参数“<code>--graph</code>”可视化显示分支关系</td></tr><tr><td>git log –follow [file]</td><td>显示某个文件的版本历史</td></tr><tr><td>git blame [file]</td><td>以列表形式显示指定文件的修改记录</td></tr><tr><td>git <strong>reflog</strong></td><td>查看所有可用的历史版本记录（实际是HEAD变更记录），包含被回退的记录（<strong>重要</strong>）</td></tr><tr><td>git status</td><td>查看本地仓库状态，比较常用的指令，加参数<code>-s</code>简洁模式</td></tr></tbody></table><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/14f7d7d18ad84b71b547456b5f5d35e1~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image"></p><p>通过<code>git log</code>指令可以查看提交记录日志，可以很方便的查看每次提交修改了哪些文件，改了哪些内容，从而进行恢复等操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提交暂存区到仓库区</span></span><br><span class="line">$ git commit -m [message]</span><br><span class="line"><span class="comment"># 提交所有修改到仓库</span></span><br><span class="line">$ git commit -a -m<span class="string">&#x27;修改README的版权信息&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交暂存区的指定文件到仓库区</span></span><br><span class="line">$ git commit [file1] [file2] ... -m [message]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用一次新的commit，替代上一次提交</span></span><br><span class="line"><span class="comment"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span></span><br><span class="line">$ git commit --amend -m [message]</span><br><span class="line"></span><br><span class="line">$ git <span class="built_in">log</span> -n2</span><br><span class="line">commit 412b56448568ff362ef312507e78797befcf2846 (HEAD -&gt; main)</span><br><span class="line">Author: Kanding &lt;123anding@163.com&gt;</span><br><span class="line">Date:   Thu Dec 1 19:02:22 2022 +0800</span><br><span class="line"></span><br><span class="line">commit c0ef58e3738f7d54545d8c13d603cddeee328fcb</span><br><span class="line">Author: Kanding &lt;123anding@163.com&gt;</span><br><span class="line">Date:   Thu Dec 1 16:52:56 2022 +0800</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用参数“--oneline”可以让日志输出更简洁（一行）</span></span><br><span class="line">$ git <span class="built_in">log</span> -n2 --oneline</span><br><span class="line">5444126 (HEAD -&gt; main, origin/main, origin/HEAD) Update README.md</span><br><span class="line">228362e Merge branch <span class="string">&#x27;main&#x27;</span> of github.com:kwonganding/KWebNote</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h2 id="5-4、Git的“指针”引用们"><a href="#5-4、Git的“指针”引用们" class="headerlink" title="5.4、Git的“指针”引用们"></a>5.4、Git的“指针”引用们</h2><p>Git中最重要的就是提交记录了，其他如<strong>标签</strong>、<strong>分支</strong>、<strong>HEAD</strong> 都对提交记录的“指针”引用，指向这些提交记录，理解这一点很重要。</p><ul><li>提交记录之间也存在“指针”引用，每个提交会指向其上一个提交。</li><li><strong>标签</strong> 就是对某一个提交记录的的 <strong>固定</strong> “指针”引用，取一个别名更容易记忆一些关键节点。存储在工作区根目录下<code>.git\refs\tags</code>。</li><li><strong>分支</strong> 也是指向某一个提交记录的“指针”引用，“指针”位置可变，如提交、更新、回滚。存储在工作区根目录下<code>.git\refs\heads</code>。</li><li><strong>HEAD</strong>：指向当前活动分支（最新提交）的一个“指针”引用，存在在“<code>.git/HEAD</code>”文件中，存储的内容为“<code>ref: refs/heads/master</code>”。</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13cd7d7c62e0424c8e900754e6494a76~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image"></p><p>上图中：</p><ul><li><code>HEAD</code>始终指向当前活动分支，多个分支只能有一个处于活动状态。</li><li>标签<code>t1</code>在某一个提交上创建后，就不会变了。而分支、<code>HEAD</code>的位置会改变。</li></ul><p>打开这些文件内容看看，就更容易理解这些“指针”的真面目了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tag</span></span><br><span class="line">$ git tag -a <span class="string">&#x27;v1&#x27;</span> -m<span class="string">&#x27;v1版本&#x27;</span></span><br><span class="line">$ <span class="built_in">cat</span> .git/refs/tags/v1</span><br><span class="line">a2e2c9caea35e176cf61e96ad9d5a929cfb82461</span><br><span class="line"></span><br><span class="line"><span class="comment"># main分支指向最新的提交</span></span><br><span class="line">$ <span class="built_in">cat</span> .git/refs/heads/main</span><br><span class="line">8f4244550c2b6c23a543b741c362b13768442090</span><br><span class="line"></span><br><span class="line"><span class="comment"># HEAD指向当前活动分支</span></span><br><span class="line">$ <span class="built_in">cat</span> .git/HEAD</span><br><span class="line">ref: refs/heads/main</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到dev分支，HEAD指向了dev</span></span><br><span class="line">$ git switch dev</span><br><span class="line">Switched to branch <span class="string">&#x27;dev&#x27;</span></span><br><span class="line">$ <span class="built_in">cat</span> .git/HEAD</span><br><span class="line">ref: refs/heads/dev</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这里的主分支名字为“<code>main</code>”，是因为该仓库是从Github上克隆的，Github上创建的仓库默认主分支名字就是“<code>main</code>”，本地创建的仓库默认主分支名字为“<code>master</code>”。</p><blockquote><p><strong>📢“指针”引用</strong>：之所以用引号的“指针”，是为了便于统一和理解。和指针原理类似，都是一个指向，只是实际上可能更复杂一点，且不同的“指针”引用会有区别。</p></blockquote><h2 id="5-5、提交的唯一标识id，HEAD-n是什么意思？"><a href="#5-5、提交的唯一标识id，HEAD-n是什么意思？" class="headerlink" title="5.5、提交的唯一标识id，HEAD~n是什么意思？"></a>5.5、提交的唯一标识id，HEAD~n是什么意思？</h2><p>每一个提交都有一个唯一标识，主要就是提交的<code>hash</code>值<code>commit id</code>，在很多指令中会用到，如版本回退、拣选提交等，需要指定一个提交。那标识唯一提交有两种方式：</p><ul><li><p>首先就是<code>commit id</code>，一个40位编码，指令中使用的时候可以只输入前几位（6位）即可。</p></li><li><p>还有一种就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HEAD~n</span><br></pre></td></tr></table></figure><p>，是基于当前</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HEAD</span><br></pre></td></tr></table></figure><p>位置的一个相对坐标。</p><ul><li><code>HEAD</code> 表示当前分支的最新版本，是比较常用的参数。</li><li><code>HEAD^</code>上一个版本，<code>HEAD^^</code> 上上一个版本。</li><li><code>HEAD~</code> 或<code>HEAD~1</code> 表示上一个版本，以此类推，<code>HEAD^10</code> 为最近第10个版本。</li><li><code>HEAD@&#123;2&#125;</code>在<code>git reflog</code>日志中标记的提交记录索引。</li></ul></li></ul><p>通过<code>git log</code>、<code>git reflog</code>可以查看历史日志，可以看每次提交的唯一编号（hash）。区别是<code>git reflog</code>可以查看所有操作的记录（实际是HEAD变更记录），包括被撤销回退的提交记录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog -n10</span><br><span class="line">5acc914 (HEAD -&gt; main) HEAD@&#123;0&#125;: reset: moving to HEAD~</span><br><span class="line">738748b (dev) HEAD@&#123;1&#125;: reset: moving to HEAD~</span><br><span class="line">9312c3e HEAD@&#123;2&#125;: reset: moving to HEAD~</span><br><span class="line">db03fcb HEAD@&#123;3&#125;: reset: moving to HEAD~</span><br><span class="line">1b81fb3 HEAD@&#123;4&#125;: reset: moving to HEAD~</span><br><span class="line">41ea423 HEAD@&#123;5&#125;: reset: moving to HEAD~</span><br><span class="line">d3e15f9 HEAD@&#123;6&#125;: reset: moving to d3e15f9</span><br><span class="line">1b81fb3 HEAD@&#123;7&#125;: reset: moving to HEAD~1</span><br><span class="line">41ea423 HEAD@&#123;8&#125;: reset: moving to HEAD~</span><br><span class="line">d3e15f9 HEAD@&#123;9&#125;: reset: moving to HEAD~</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h2 id="5-6、比较diff"><a href="#5-6、比较diff" class="headerlink" title="5.6、比较diff"></a>5.6、比较diff</h2><p><code>git diff</code>用来比较不同文件版本之间的差异。</p><table><thead><tr><th><strong>指令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>git diff</strong></td><td>查看暂存区和工作区的差异</td></tr><tr><td>git diff [file]</td><td>同上，指定文件</td></tr><tr><td>git diff –cached</td><td>查看已暂存的改动，就是暂存区与新版本<code>HEAD</code>进行比较</td></tr><tr><td>git diff –staged</td><td>同上</td></tr><tr><td>git diff –cached [file]</td><td>同上，指定文件</td></tr><tr><td>git diff HEAD</td><td>查看已暂存的+未暂存的所有改动，就是与最新版本<code>HEAD</code>进行比较</td></tr><tr><td>git diff HEAD~</td><td>同上，与上一个版本比较。<code>HEAD~</code>表示上一个版本，<code>HEAD~10</code>为最近第10个版本</td></tr><tr><td>git diff [id] [id]</td><td>查看两次提交之间的差异</td></tr><tr><td>git diff [branch]</td><td>查看工作区和分支直接的差异</td></tr></tbody></table><p>☘️画个图更清晰些：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/565ccedcf6664d6598178327bdf6f75a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看文件的修改</span></span><br><span class="line">$ git diff README.md</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看两次提交的差异</span></span><br><span class="line">$ git diff 8f4244 1da22</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示今天你写了多少行代码：工作区+暂存区</span></span><br><span class="line">$ git diff --shortstat <span class="string">&quot;@&#123;0 day ago&#125;&quot;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><hr><h1 id="06、远程仓库"><a href="#06、远程仓库" class="headerlink" title="06、远程仓库"></a>06、远程仓库</h1><p>Git作为分布式的版本管理系统，每个终端都有自己的Git仓库。但团队协作还需一个中间仓库，作为中心，同步各个仓库。于是服务端（远程）仓库就来承担这个职责，服务端不仅有仓库，还配套相关管理功能。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7566420b76e34e489e59871a4a0da9b3~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image"></p><p>可以用公共的Git服务器，也可以自己搭建一套Git服务器。</p><ul><li>公共Git服务器，如<a href="https://link.juejin.cn/?target=https://github.com/">Github</a>、<a href="https://link.juejin.cn/?target=https://about.gitlab.com/">Gitlab</a>、<a href="https://link.juejin.cn/?target=https://gitee.com/">码云Gitee</a>、<a href="https://link.juejin.cn/?target=https://coding.net/">腾讯Coding</a>等。</li><li>搭建私有Git服务器，如开源的Gitlab、<a href="https://link.juejin.cn/?target=https://github.com/go-gitea/gitea">Gitea</a>、等。</li></ul><h2 id="6-1、远程用户登录"><a href="#6-1、远程用户登录" class="headerlink" title="6.1、远程用户登录"></a>6.1、远程用户登录</h2><p>Git服务器一般提供两种登录验证方式：</p><ul><li><p>HTTS</p><p>：基于HTTPS连接，使用用户名、密码身份验证。</p><ul><li>每次都要输入用户名、密码，当然可以记住。</li><li>地址形式：<code>https://github.com/kwonganding/KWebNote.git</code></li></ul></li><li><p>SSL</p><p>：采用SSL通信协议，基于公私钥进行身份验证，所以需要额外配置公私秘钥。</p><ul><li>不用每次输入用户名、密码，比较推荐的方法。</li><li>地址形式：<code>git@github.com:kwonganding/KWebNote.git</code></li></ul></li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c1cc6ce8c34485989cf0b823f00d124~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看当前远程仓库使用的那种协议连接：</span></span><br><span class="line">$ git remote -v</span><br><span class="line">origin  git@github.com:kwonganding/KWebNote.git (fetch)</span><br><span class="line">origin  https://github.com/kwonganding/KWebNote.git (push)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更改为https地址，即可切换连接模式。还需要禁用掉SSL, 才能正常使用https管理git</span></span><br><span class="line">git config --global http.sslVerify <span class="literal">false</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="🔑远程用户登录：HTTS"><a href="#🔑远程用户登录：HTTS" class="headerlink" title="🔑远程用户登录：HTTS"></a>🔑远程用户登录：HTTS</h3><p>基于HTTPS的地址连接远程仓库，Github的共有仓库克隆、拉取（pull）是不需要验证的。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c57d5111fdb54323ba6fd64626f84435~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> <span class="string">&#x27;https://github.com/kwonganding/KWebNote.git&#x27;</span></span><br><span class="line">Cloning into <span class="string">&#x27;KWebNote&#x27;</span>...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 仓库配置文件“.git/config”</span></span><br><span class="line">[remote <span class="string">&quot;origin&quot;</span>]</span><br><span class="line"> url = https://github.com/kwonganding/KWebNote.git</span><br><span class="line">fetch = +refs/heads/*:refs/remotes/origin/*</span><br><span class="line">pushurl = https://github.com/kwonganding/KWebNote.git</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>推送（push）代码的时候就会提示输入用户名、密码了，否则无法提交。记住用户密码的方式有两种：</p><ul><li><strong>🔸URL地址配置</strong>：在原本URL地址上加上用户名、密码，<code>https://</code>后加<code>用户名:密码@</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接修改仓库的配置文件“.git/config”</span></span><br><span class="line">[remote <span class="string">&quot;origin&quot;</span>]</span><br><span class="line"> url = https://用户名:密码@github.com/kwonganding/KWebNote.git</span><br><span class="line">fetch = +refs/heads/*:refs/remotes/origin/*</span><br><span class="line">pushurl = https://github.com/kwonganding/KWebNote.git</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li><strong>🔸本地缓存</strong>：会创建一个缓存文件<code>.git-credentials</code>，存储输入的用户名、密码。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 参数“--global”全局有效，也可以针对仓库设置“--local”</span></span><br><span class="line"><span class="comment"># store 表示永久存储，也可以设置临时存储</span></span><br><span class="line">git config --global credential.helper store</span><br><span class="line"></span><br><span class="line"><span class="comment"># 存储内容如下，打开文件“仓库\.git\.git-credentials”</span></span><br><span class="line">https://kwonganding:[加密内容付费可见]@github.com</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="🔑远程用户登录：SSH"><a href="#🔑远程用户登录：SSH" class="headerlink" title="🔑远程用户登录：SSH"></a>🔑远程用户登录：SSH</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/73179047882b469cb72949d3a0537be7~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"></p><p>SSH（Secure Shell，安全外壳）是一种网络安全协议，通过加密和认证机制实现安全的访问和文件传输等业务，多用来进行远程登录、数据传输。SSH通过公钥、私钥非对称加密数据，所以SSH需要生成一个公私钥对，公钥放服务器上，私有自己留着进行认证。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b4c7bed1fa8e478aa68aefa3b5e94ff2~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p><p><strong>① 生成公私钥</strong>：通过Git指令<code>ssh-keygen -t rsa</code>生成公私钥，一路回车即可完成。生成在“<code>C:\Users\用户名\.ssh</code>”目录下，文件<code>id_rsa.pub</code>的内容就是公钥。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea24f85292134500a84374062f7ee6a4~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"></p><p><strong>② 配置公钥</strong>：打开<code>id_rsa.pub</code>文件，复制内容。Github上，打开<code>Setting</code>➤ <code>SSH and GPG keys</code> ➤ <code>SSH keys</code> ➤ 按钮<code>New SSH key</code>，标题（Title）随意，秘钥内容粘贴进去即可。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e03cbbc0ee74dad80dd4855e412cba0~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"></p><p>SSH配置完后，可用<code>ssh -T git@github.com</code>来检测是否连接成功。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br><span class="line">Hi kwonganding! You<span class="string">&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span></span><br><span class="line"><span class="string">复制代码</span></span><br></pre></td></tr></table></figure><h2 id="6-2、远程仓库指令🔥"><a href="#6-2、远程仓库指令🔥" class="headerlink" title="6.2、远程仓库指令🔥"></a>6.2、远程仓库指令🔥</h2><table><thead><tr><th><strong>指令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>git clone [git地址]</td><td>从远程仓库克隆到本地（当前目录）</td></tr><tr><td>git remote -v</td><td>查看所有远程仓库，不带参数<code>-v</code>只显示名称</td></tr><tr><td>git remote show [remote]</td><td>显示某个远程仓库的信息</td></tr><tr><td>git remote add [name] [url]</td><td>增加一个新的远程仓库，并命名</td></tr><tr><td>git remote rename [old] [new]</td><td>修改远程仓库名称</td></tr><tr><td><strong>git pull [remote] [branch]</strong></td><td>取回远程仓库的变化，并与本地版本合并</td></tr><tr><td><strong>git pull</strong></td><td>同上，针对当前分支</td></tr><tr><td>git fetch [remote]</td><td>获取远程仓库的所有变动到本地仓库，不会自动合并！需要手动合并</td></tr><tr><td><strong>git push</strong></td><td>推送当前分支到远程仓库</td></tr><tr><td>git push [remote] [branch]</td><td>推送本地当前分支到远程仓库的指定分支</td></tr><tr><td>git push [remote] –force&#x2F;-f</td><td>强行推送当前分支到远程仓库，即使有冲突，⚠️很危险！</td></tr><tr><td>git push [remote] –all</td><td>推送所有分支到远程仓库</td></tr><tr><td>git push –u</td><td>参数<code>–u</code>表示与远程分支建立关联，第一次执行的时候用，后面就不需要了</td></tr><tr><td>git remote rm [remote-name]</td><td>删除远程仓库</td></tr><tr><td>git pull –rebase</td><td>使用rebase的模式进行合并</td></tr></tbody></table><h2 id="6-3、推送push-x2F-拉取pull"><a href="#6-3、推送push-x2F-拉取pull" class="headerlink" title="6.3、推送push&#x2F;拉取pull"></a>6.3、推送push&#x2F;拉取pull</h2><p><code>git push</code>、<code>git pull</code>是团队协作中最常用的指令，用于同步本地、服务端的更新，与他人协作。</p><p><strong>🔸推送</strong>（push）：推送本地仓库到远程仓库。</p><ul><li>如果推送的更新与服务端存在冲突，则会被拒绝，<code>push</code>失败。一般是有其他人推送了代码，导致文件冲突，可以先<code>pull</code>代码，在本地进行合并，然后再<code>push</code>。</li></ul><p><strong>🔸拉取</strong>（pull）：从服务端（远程）仓库更新到本地仓库。</p><ul><li><code>git pull</code>：拉取服务端的最新提交到本地，并与本地合并，合并过程同分支的合并。</li><li><code>git fetch</code>：拉取服务端的最新提交到本地，不会自动合并，也不会更新工作区。</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/365395e73a254ef6abfd5a99e78992b0~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image"></p><h2 id="6-4、fetch与pull有什么不同？"><a href="#6-4、fetch与pull有什么不同？" class="headerlink" title="6.4、fetch与pull有什么不同？"></a>6.4、fetch与pull有什么不同？</h2><p>两者都是从服务端获取更新，主要区别是<code>fetch</code>不会自动合并，不会影响当前工作区内容。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull` = `git fetch` + `git merge</span><br></pre></td></tr></table></figure></blockquote><ul><li>如下面图中，<code>git fetch</code>只获取了更新，并未影响<code>master</code>、<code>HEAD</code>的位置。</li><li>要更新<code>master</code>、<code>HEAD</code>的位置需要手动执行<code>git merge</code>合并。</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/abf7648ba0314c3f9f5ad30c4e1e20c4~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># fetch只更新版本库</span></span><br><span class="line">$ git fetch</span><br><span class="line">remote: Enumerating objects: 5, <span class="keyword">done</span>.</span><br><span class="line">remote: Counting objects: 100% (5/5), <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (3/3), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 3 (delta 2), reused 0 (delta 0), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (3/3), 663 bytes | 44.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">From github.com:kwonganding/KWebNote</span><br><span class="line">   2ba12ca..c64f5b5  main       -&gt; origin/main</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行合并，合并自己</span></span><br><span class="line">$ git merge</span><br><span class="line">Updating 2ba12ca..c64f5b5</span><br><span class="line">Fast-forward</span><br><span class="line"> README.md | 2 +-</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><hr><h1 id="07、Git利器-分支"><a href="#07、Git利器-分支" class="headerlink" title="07、Git利器-分支"></a>07、Git利器-分支</h1><p>分支是从主线分离出去的“副本”，分支就像是平行宇宙，可独立发展，独立编辑、提交，也可以和其他分支合并。分支是Git的核心必杀利器之一，分支创建、切换、删除都非常快，他非常的轻量。所以，早建分支！多用分支！</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b9ab3c40bcf47858c8ee108ab35ff91~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"></p><h2 id="7-1、分支Branch"><a href="#7-1、分支Branch" class="headerlink" title="7.1、分支Branch"></a>7.1、分支Branch</h2><p>比如有一个项目团队，准备10月份发布新版本，要新开发一堆黑科技功能，占领市场。你和小伙伴“小美”一起负责开发一个新功能A，开发周期2周，在这两周你们的代码不能影响其他人，不影响主分支。这个时候就可以为这个新功能创建一个分支，你们两在这个分支上干活，2周后代码开发完了、测试通过，就可以合并进要发版的开发分支了。安全、高效，不影响其他人工作，完美！</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c58ef8e5f5334ee6909d9c9a55298e71~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image"></p><p>在实际项目中，一般会建几个主线分支。</p><ul><li><strong>🔸master</strong>：作为主分支，存放稳定的代码，就是开发后测试通过的代码，不允许随便修改和合并。</li><li><strong>🔸开发分支</strong>：用于团队日常开发用，比如团队计划10月份开发10个功能并发版，则在此分支上进行，不影响主分支的稳定。</li><li><strong>🔸功能A分支</strong>：开发人员根据自己的需要，可以创建一些临时分支用于特定功能的开发，开发完毕后再合并到开发分支，并删除该分支。</li></ul><p><strong>分支</strong>就是指向某一个提交记录的“指针”引用，因此创建分支是非常快的，不管仓库多大。当我们运行<code>git branch dev</code>创建了一个名字为<code>dev</code>的分支，Git实际上是在<code>.git\refs\heads</code>下创建一个<code>dev</code>的引用文件（没有扩展名）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git branch dev</span><br><span class="line">$ <span class="built_in">cat</span> .git/refs/heads/dev</span><br><span class="line">ca88989e7c286fb4ba56785c2cd8727ea1a07b97</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h2 id="7-2、分支指令🔥"><a href="#7-2、分支指令🔥" class="headerlink" title="7.2、分支指令🔥"></a>7.2、分支指令🔥</h2><table><thead><tr><th><strong>指令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>git branch</td><td>列出所有本地分支，加参数<code>-v</code>显示详细列表，下同</td></tr><tr><td>git branch -r</td><td>列出所有远程分支</td></tr><tr><td>git branch -a</td><td>列出所有本地分支和远程分支，用不同颜色区分</td></tr><tr><td>git branch [branch-name]</td><td>新建一个分支，但依然停留在当前分支</td></tr><tr><td>git branch -d dev</td><td>删除<code>dev</code>分支，-D（大写）强制删除</td></tr><tr><td><strong>git checkout -b</strong> dev</td><td>从当前分支创建并切换到<code>dev</code>分支</td></tr><tr><td>git checkout <strong>-b</strong> feature1 dev</td><td>从本地<code>dev</code>分支代码创建一个 <code>feature1</code>分支，并切换到新分支</td></tr><tr><td>git branch [branch] [commit]</td><td>新建一个分支，指向指定<code>commit id</code></td></tr><tr><td>git branch –track [branch] [remote-branch]</td><td>新建一个分支，与指定的远程分支建立关联</td></tr><tr><td>git checkout -b hotfix remote hotfix</td><td>从远端<code>remote</code>的<code>hotfix</code>分支创建本地<code>hotfix</code>分支</td></tr><tr><td>git branch –set-upstream [branch] [remote-branch]</td><td>在现有分支与指定的远程分支之间建立跟踪关联： <code>git branch --set-upstream hotfix remote/hotfix</code></td></tr><tr><td><strong>git checkout</strong> [branch-name]</td><td>切换到指定分支，并更新工作区</td></tr><tr><td>git checkout .</td><td>撤销工作区的（未暂存）修改，把暂存区恢复到工作区。</td></tr><tr><td>git checkout HEAD .</td><td>撤销工作区、暂存区的修改，用<code>HEAD</code>指向的当前分支最新版本替换</td></tr><tr><td>git merge [branch]</td><td>合并指定分支到当前分支</td></tr><tr><td><strong>git merge –no-ff</strong> dev</td><td>合并<code>dev</code>分支到当前分支，参数<code>--no-ff</code>禁用快速合并模式</td></tr><tr><td>git push origin –delete [branch-name]</td><td>删除远程分支</td></tr><tr><td>git rebase master</td><td>将当前分支变基合并到<code>master</code>分支</td></tr><tr><td>✅switch：新的分支切换指令</td><td>切换功能和<code>checkout</code>一样，<code>switch</code>只单纯的用于切换</td></tr><tr><td>git switch master</td><td>切换到已有的<code>master</code>分支</td></tr><tr><td>git switch -c dev</td><td>创建并切换到新的<code>dev</code>分支</td></tr></tbody></table><blockquote><p>📢<strong>关于 <code>checkout</code> 指令</strong>：<code>checkout</code>是Git的底层指令，比较常用，也比较危险，他会重写工作区。支持的功能比较多，能撤销修改，能切换分支，这也导致了这个指令比较复杂。在Git 2.23版本以后，增加了<code>git switch</code>、<code>git reset</code>指令。</p><ul><li><code>git switch</code>：专门用来实现分支切换。</li><li><code>git reset</code>：专门用来实现本地修改的撤销，更多可参考后续“reset”内容。</li></ul></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">  dev</span><br><span class="line">* main</span><br><span class="line"><span class="comment"># 列出了当前的所有分支，星号“*”开头的“main”为当前活动分支。</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h2 id="7-3、分支的切换checkout"><a href="#7-3、分支的切换checkout" class="headerlink" title="7.3、分支的切换checkout"></a>7.3、分支的切换checkout</h2><p>代码仓库可以有多个分支，<code>master</code>为默认的主分支，但只有一个分支在工作状态。所以要操作不同分支，需要切换到该分支，<code>HEAD</code>就是指向当前正在活动的分支。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/477ba6ccb6224187a72331fbc2cd3b7a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切换到dev分支，HEAD指向了dev</span></span><br><span class="line"><span class="comment"># 此处 switch 作用同 checkout，switch只用于切换，不像checkout功能很多</span></span><br><span class="line">$ git switch dev</span><br><span class="line">Switched to branch <span class="string">&#x27;dev&#x27;</span></span><br><span class="line">$ <span class="built_in">cat</span> .git/HEAD</span><br><span class="line">ref: refs/heads/dev</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>使用 <code>git checkout dev</code>切换分支时，干了两件事：</p><ul><li>①、<code>HEAD</code>指向<code>dev</code>：修改<code>HEAD</code>的“指针”引用，指向<code>dev</code>分支。</li><li>②、还原工作空间：把<code>dev</code>分支内容还原到工作空间。</li></ul><p>此时的活动分支就是<code>dev</code>了，后续的提交就会更新到<code>dev</code>分支了。</p><p><strong>❓切换时还没提交的代码怎么办？</strong></p><ul><li>如果修改（包括未暂存、已暂存）和待切换的分支没有冲突，则切换成果，且未提交修改会一起带过去，所以要注意！</li><li>如果有冲突，则会报错，提示先提交或隐藏，关于隐藏可查看后续章节内容“stash”。</li></ul><h2 id="7-4、合并merge-amp-冲突"><a href="#7-4、合并merge-amp-冲突" class="headerlink" title="7.4、合并merge&amp;冲突"></a>7.4、合并merge&amp;冲突</h2><p>把两个分支的修改内容合并到一起，常用的合并指令<code>git merge [branch]</code>，将分支<code>[branch]</code>合并到当前分支。根据要合并的内容的不同，具体合并过程就会有多种情况。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0bb900a1fb09455e979ebe78e9ed4717~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image"></p><h3 id="🔸快速合并（Fast-forward）"><a href="#🔸快速合并（Fast-forward）" class="headerlink" title="🔸快速合并（Fast forward）"></a>🔸快速合并（Fast forward）</h3><p>如下图，<code>master</code>分支么有任何提交，“<code>git merge dev</code>”合并分支<code>dev</code>到<code>master</code>，此时合并速度就非常快，直接移动<code>master</code>的“指针”引用到<code>dev</code>即可。这就是快速合并（Fast forward），不会产生新的提交。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d9e4500d07dd4608859822eff0946aa1~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image"></p><ul><li>合并<code>dev</code>到<code>master</code>，注意要先切换到<code>master</code>分支，然后执行<code>git merge dev</code>，把<code>dev</code>合并到当前分支。</li></ul><blockquote><p><strong>📢强制不用快速合并</strong>：<code>git merge --no-ff -m &quot;merge with no-ff&quot; dev</code>，参数<code>--no-ff</code>不启用快速合并，会产生一个新的合并提交记录。</p></blockquote><h3 id="🔸普通合并"><a href="#🔸普通合并" class="headerlink" title="🔸普通合并"></a>🔸普通合并</h3><p>如果<code>master</code>有变更，存在分支交叉，则会把两边的变更合并成一个提交。</p><ul><li>如果两边变更的文件不同，没有什么冲突，就自动合并了。</li><li>如果有修改同一个文件，则会存在冲突，到底该采用哪边的，程序无法判断，就换产生冲突。冲突内容需要人工修改后再重新提交，才能完成最终的合并。</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/11697f2dcf804ad9a9c34836743389f5~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image"></p><p>上图中，创建<code>dev</code>分支后，两个分支都有修改提交，因此两个分支就不在一条顺序线上了，此时合并<code>dev</code>到<code>master</code>就得把他们的修改进行合并操作了。</p><ul><li><code>v5</code>、<code>v7</code>共同祖先是<code>v4</code>，从这里开始分叉。</li><li>Git 会用两个分支的末端<code>v6</code> 和 <code>v8</code>以及它们的共同祖先<code>v4</code>进行三方合并计算。合并之后会生成一个新（和并）提交<code>v9</code>。</li><li>合并提交<code>v9</code>就有两个祖先<code>v6</code>、<code>v8</code>。</li></ul><h3 id="🔸处理冲突-lt-lt-lt-lt-lt-lt-lt-HEAD"><a href="#🔸处理冲突-lt-lt-lt-lt-lt-lt-lt-HEAD" class="headerlink" title="🔸处理冲突&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD"></a>🔸处理冲突&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</h3><p>在有冲突的文件中，<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</code>开头的内容就表示是有冲突的部分，需要人工处理，可以借助一些第三方的对比工具。人工处理完毕后，完成合并提交，才最终完成此次合并。<code>=======</code>分割线上方是当前分支的内容，下方是被合并分支的变更内容。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/790e17969958424c992eaf7a204641eb~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"></p><h2 id="7-5、变基rebase"><a href="#7-5、变基rebase" class="headerlink" title="7.5、变基rebase"></a>7.5、变基rebase</h2><p>把两个分支的修改内容合并到一起的办法有两种：<code>merge</code> 和 <code>rebase</code>，作用都是一样的，区别是<code>rebase</code>的提交历史更简洁，干掉了分叉，merge的提交历史更完整。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6009e8d4b42f4fdfbaf2e3330b3bd5f9~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image"></p><ul><li>在<code>dev</code>上执行“<code>git rebase master</code>”变基，将<code>dev</code>分支上分叉的<code>v7</code>、<code>v8</code>生成补丁，然后在<code>master</code>分支上应用补丁，产生新的<code>v7&#39;</code>、<code>v8&#39;</code>新的提交。</li><li>然后回到<code>master</code>分支，完成合并<code>git merge dev</code>，此时的合并就是快速合并了。</li><li>最终的提交记录就没有分叉了。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase master</span><br><span class="line">$ git checkout master</span><br><span class="line">$ git merge dev</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><hr><h1 id="08、标签管理"><a href="#08、标签管理" class="headerlink" title="08、标签管理"></a>08、标签管理</h1><p><strong>标签</strong>（Tags）指的是某个分支某个特定时间点的状态，是对某一个提交记录的的<strong>固定</strong>“指针”引用。一经创建，不可移动，存储在工作区根目录下<code>.git\refs\tags</code>。可以理解为某一次提交（编号）的别名，常用来标记版本。所以发布时，一般都会打一个版本标签，作为该版本的快照，指向对应提交<code>commit</code>。</p><p>当项目达到一个关键节点，希望永远记住那个特别的提交快照，你可以使用 <code>git tag </code>给它打上标签。比如我们今天终于完成了V1.1版本的开发、测试，并成功上线了，那就可给今天最后这个提交打一个标签“V1.1”，便于版本管理。</p><p>默认标签是打在最新提交的commit上的，如果希望在指定的提交上打标签则带上提交编号（commit id）：<code>git tag v0.9 f52c633</code></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2bb33deac27f4730b2026ff92ce38a20~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image"></p><table><thead><tr><th><strong>指令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>git tag</td><td>查看标签列表</td></tr><tr><td>git tag -l ‘a*’</td><td>查看名称是“a”开头的标签列表，带查询参数</td></tr><tr><td>git show [tagname]</td><td>查看标签信息</td></tr><tr><td><strong>git tag</strong> [tagname]</td><td>创建一个标签，默认标签是打在最新提交的commit上的</td></tr><tr><td>git tag [tagname] [commit id]</td><td>新建一个tag在指定commit上</td></tr><tr><td>git tag -a v5.1 -m’v5.1版本’</td><td>创建标签<code>v5.1.1039</code>，<code>-a</code>指定标签名，<code>-m</code>指定说明文字</td></tr><tr><td>git tag -d [tagname]</td><td>删除本地标签</td></tr><tr><td>git checkout v5.1.1039</td><td>切换标签，同切换分支</td></tr><tr><td>git push [remote] v5.1</td><td>推送标签，标签不会默认随代码推送推送到服务端</td></tr><tr><td>git push [remote] –tags</td><td>提交所有tag</td></tr></tbody></table><p>如果要推送某个标签到远程，使用命令<code>git push origin [tagname]</code>，或者，一次性推送全部到远程：<code>git push origin --tags</code></p><blockquote><p>📢注意：标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tag</span></span><br><span class="line">$ git tag -a <span class="string">&#x27;v1&#x27;</span> -m<span class="string">&#x27;v1版本&#x27;</span></span><br><span class="line">$ <span class="built_in">cat</span> .git/refs/tags/v1</span><br><span class="line">a2e2c9caea35e176cf61e96ad9d5a929cfb82461</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看标签列表</span></span><br><span class="line">$ git tag</span><br><span class="line">v1</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><hr><h1 id="09、后悔药-怎么撤销变更？"><a href="#09、后悔药-怎么撤销变更？" class="headerlink" title="09、后悔药-怎么撤销变更？"></a>09、后悔药-怎么撤销变更？</h1><p>发现写错了要回退怎么办？看看下面几种后悔指令吧！</p><ul><li><p>❓</p><p>还没提交的怎么撤销？</p><p>——</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">checkout</span><br></pre></td></tr></table></figure><p>、</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reset</span><br></pre></td></tr></table></figure><ul><li>还未提交的修改（工作区、暂存区）不想要了，用签出指令（checkout）进行撤销清除。</li><li>或者用<code>checkout</code>的新版回滚指令<code>reset</code>。</li></ul></li><li><p>❓<strong>已提交但么有push的提交如何撤销？</strong>—— <code>reset</code>、<code>revert</code></p></li><li><p>❓<strong>已push的提交如何撤销？</strong>—— 同上，先本地撤销，然后强制推送<code>git push origin -f</code>，<strong>⚠️注意慎用！</strong> 记得先<code>pull</code>获取更新。</p></li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/79de5cfe72814bca8d97411d49e59977~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image"></p><h2 id="9-1、后悔指令🔥"><a href="#9-1、后悔指令🔥" class="headerlink" title="9.1、后悔指令🔥"></a>9.1、后悔指令🔥</h2><table><thead><tr><th><strong>指令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>git checkout .</td><td>撤销工作区的（未暂存）修改，把暂存区恢复到工作区。不影响暂存区，如果没暂存，则撤销所有工作区修改</td></tr><tr><td>git checkout [file]</td><td>同上，<code>file</code>指定文件</td></tr><tr><td>git checkout HEAD .</td><td>撤销工作区、暂存区的修改，用<code>HEAD</code>指向的当前分支最新版本替换工作区、暂存区</td></tr><tr><td>git checkout HEAD [file]</td><td>同上，<code>file</code>指定文件</td></tr><tr><td></td><td></td></tr><tr><td>git reset</td><td>撤销暂存区状态，同<code>git reset HEAD</code>，不影响工作区</td></tr><tr><td>git reset HEAD [file]</td><td>同上，指定文件<code>file</code>，<code>HEAD</code>可省略</td></tr><tr><td>git reset [commit]</td><td>回退到指定版本，清空暂存区，不影响工作区。工作区需要手动<code>git checkout</code>签出</td></tr><tr><td>git reset –soft [commit]</td><td>移动分支<code>master</code>、<code>HEAD</code>到指定的版本，不影响暂存区、工作区，需手动<code>git checkout</code>签出更新</td></tr><tr><td>git reset –hard HEAD</td><td>撤销工作区、暂存区的修改，用当前最新版</td></tr><tr><td>git reset –hard HEAD~</td><td>回退到上一个版本，并重置工作区、暂存区内容。</td></tr><tr><td>git reset –hard [commit]</td><td>回退到指定版本，并重置工作区、暂存区内容。</td></tr><tr><td></td><td></td></tr><tr><td>git <strong>revert</strong>[commit]</td><td>撤销一个提交，会用一个新的提交（原提交的逆向操作）来完成撤销操作，如果已<code>push</code>则重新<code>push</code>即可</td></tr></tbody></table><ul><li><code>git checkout .</code>、<code>git checkout [file]</code> 会清除工作区中未添加到暂存区的修改，用暂存区内容替换工作区。</li><li><code>git checkout HEAD .</code>、<code> git checkout HEAD [file]</code> 会清除工作区、暂存区的修改，用HEAD指向的当前分支最新版本替换暂存区、工作区。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只撤销工作区的修改（未暂存）</span></span><br><span class="line">$ git checkout .</span><br><span class="line">Updated 1 path from the index</span><br><span class="line"></span><br><span class="line"><span class="comment"># 撤销工作区、暂存区的修改</span></span><br><span class="line">$ git checkout HEAD .</span><br><span class="line">Updated 1 path from f951a96</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h2 id="9-2、回退版本reset"><a href="#9-2、回退版本reset" class="headerlink" title="9.2、回退版本reset"></a>9.2、回退版本reset</h2><p><code>reset</code>是专门用来撤销修改、回退版本的指令，支持的场景比较多，多种撤销姿势，所以参数组合也比较多。简单理解就是移动<code>master</code>分支、<code>HEAD</code>的“指针”地址，理解这一点就基本掌握<code>reset</code>了。</p><p>如下图：</p><ul><li>回退版本<code>git reset --hard v4</code> 或 <code>git reset --hard HEAD~2</code>，<code>master</code>、<code>HEAD</code>会指向<code>v4</code>提交，<code>v5</code>、<code>v6</code>就被废弃了。</li><li>也可以重新恢复到<code>v6</code>版本：<code>git reset --hard v6</code>，就是移动<code>master</code>、<code>HEAD</code>的“指针”地址。</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45ad235c2b8b440ebe32481e56ab483f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image"></p><p><code>reset</code>有三种模式，对应三种参数：<code>mixed</code>（默认模式）、<code>soft</code>、<code>hard</code>。三种参数的主要区别就是对工作区、暂存区的操作不同。</p><ul><li><code>mixed</code>为默认模式，参数可以省略。</li><li>只有<code>hard</code>模式会重置工作区、暂存区，一般用这个模式会多一点。</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/737dd913911b4e57a2e7dedd4f094d9b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image"></p><table><thead><tr><th>*<em>模式名称*</em></th><th><strong>描述</strong></th><th><strong>HEAD的位置</strong></th><th><strong>暂存区</strong></th><th><strong>工作区</strong></th></tr></thead><tbody><tr><td><strong>soft</strong></td><td>回退到某一个版本，工作区不变，需手动<code>git checkout</code></td><td>修改</td><td>不修改</td><td>不修改</td></tr><tr><td><strong>mixed</strong>(默认)</td><td>撤销暂存区状态，不影响工作区，需手动<code>git checkout</code></td><td>修改</td><td>修改</td><td>不修改</td></tr><tr><td><strong>hard</strong></td><td>重置未提交修改（工作区、暂存区）</td><td>修改</td><td>修改</td><td>修改</td></tr></tbody></table><p>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">git reset [--soft | --mixed | --hard] [HEAD]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 撤销暂存区</span></span><br><span class="line">$ git reset</span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">M       R.md</span><br><span class="line"></span><br><span class="line"><span class="comment"># 撤销工作区、暂存区修改</span></span><br><span class="line">$ git reset --hard HEAD</span><br><span class="line"></span><br><span class="line"><span class="comment"># 回退版本库到上一个版本，并重置工作区、暂存</span></span><br><span class="line">$ git reset --hard HEAD~</span><br><span class="line"></span><br><span class="line"><span class="comment"># 回到原来的版本（恢复上一步的撤销操作），并重置工作区、暂存</span></span><br><span class="line">$ git reset --hard 5f8b961</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有历史提交记录</span></span><br><span class="line">$ git reflog</span><br><span class="line">ccb9937 (HEAD -&gt; main, origin/main, origin/HEAD) HEAD@&#123;0&#125;: commit: 报表新增导入功能</span><br><span class="line">8f61a60 HEAD@&#123;1&#125;: commit: bug：修复报表导出bug</span><br><span class="line">4869ff7 HEAD@&#123;2&#125;: commit: 用户报表模块开发</span><br><span class="line">4b1028c HEAD@&#123;3&#125;: commit: 财务报表模块开发完成</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h2 id="9-3、撤销提交revert"><a href="#9-3、撤销提交revert" class="headerlink" title="9.3、撤销提交revert"></a>9.3、撤销提交revert</h2><p>安全的撤销某一个提交记录，基本原理就是生产一个新的提交，用原提交的逆向操作来完成撤销操作。注意，这不同于<code>reset</code>，<code>reset</code>是回退版本，revert只是用于撤销某一次历史提交，操作是比较安全的。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3138dde33c5f40a09fe209bb30cd08f2~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image"></p><p>如上图：</p><ul><li>想撤销<code>v4</code>的修改，执行<code>git revert v4</code>，会产生一个新的提交<code>v-4</code>，是<code>v4</code>的逆向操作。</li><li>同时更新<code>maser</code>、<code>HEAD</code>“指针”位置，以及工作区内容。</li><li>如果已<code>push</code>则重新<code>push</code>即可。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># revert撤销指定的提交，“-m”附加说明</span></span><br><span class="line">$ git revert 41ea42 -m<span class="string">&#x27;撤销对***的修改&#x27;</span></span><br><span class="line">[main 967560f] Revert <span class="string">&quot;123&quot;</span></span><br><span class="line">                            1 file changed, 1 deletion(-)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h2 id="9-4、checkout-x2F-reset-x2F-revert总结"><a href="#9-4、checkout-x2F-reset-x2F-revert总结" class="headerlink" title="9.4、checkout&#x2F;reset&#x2F;revert总结"></a>9.4、checkout&#x2F;reset&#x2F;revert总结</h2><table><thead><tr><th><strong>标题 \ 指令</strong></th><th><strong>checkout</strong></th><th><strong>reset</strong></th><th><strong>revert</strong></th></tr></thead><tbody><tr><td><strong>主要作用（撤销）</strong></td><td>撤销工作区、暂存区未提交修改</td><td>回退版本，重置工作区、暂存区</td><td>撤销某一次提交</td></tr><tr><td><strong>撤销工作区</strong></td><td>git checkout [file]</td><td>git reset HEAD [file]</td><td></td></tr><tr><td><strong>撤销工作区、暂存区</strong></td><td>git checkout HEAD [file]</td><td>git reset –hard HEAD [file]</td><td></td></tr><tr><td><strong>回退版本</strong></td><td></td><td>git reset –hard [commit]</td><td></td></tr><tr><td><strong>安全性</strong></td><td>只针对未提交修改，<strong>安全</strong></td><td>如回退了已<code>push</code>提交，<strong>不安全</strong></td><td><strong>安全</strong></td></tr></tbody></table><p>可看出<code>reset</code>完全可以替代<code>checkout</code>来执行撤销、回退操作，<code>reset</code>本来也是专门用来干这个事情的，可以抛弃<code>checkout</code>了（撤销的时候）。</p><hr><h1 id="10、工作中的Git实践"><a href="#10、工作中的Git实践" class="headerlink" title="10、工作中的Git实践"></a>10、工作中的Git实践</h1><h2 id="10-1、Git-flow"><a href="#10-1、Git-flow" class="headerlink" title="10.1、Git flow"></a>10.1、Git flow</h2><p>Git flow（Git工作流程）是指软件项目中的一种Git分支管理模型，经过了大量的实践和优化，被认为是现代敏捷软件开发和DevOps（开发、技术运营和质量保障三者的交集）的最佳实践。Git flow主要流程及关键分支：<a href="https://link.juejin.cn/?target=https://www.processon.com/view/59ec836de4b0c86d400e99f1?fromnew=1">原图地址-processon</a></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/62805963c11f409497cbdf98cfecb5b3~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"></p><p><strong>✅主分支：master</strong>，稳定版本代码分支，对外可以随时编译发布的分支，不允许直接Push代码，只能请求合并（pull request），且只接受<code>hotfix</code>、<code>release</code>分支的代码合并。</p><p><strong>✅热修复分支：hotfix</strong>，针对线上紧急问题、bug修复的代码分支，修复完后合并到主分支、开发分支。</p><ul><li>① 切换到<code>hotfix</code>分支，从<code>master</code>更新代码；</li><li>② 修复bug；</li><li>③ 合并代码到<code>dev</code>分支，在本地Git中操作即可；</li><li>④ 合并代码到<code>master</code>分支。</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e799d590479c4b45a1da4af6d37aa709~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"></p><p><strong>✅发版分支：release</strong>，版本发布分支，用于迭代版本发布。迭代开发完成后，合并<code>dev</code>代码到<code>release</code>，在<code>release</code>分支上编译发布版本，以及修改bug（定时同步bug修改到<code>dev</code>分支）。测试完成后此版本可以作为发版使用，然后把稳定的代码push到<code>master</code>分支，并打上版本标签。</p><p><strong>✅开发分支：dev</strong>，开发版本分支，针对迭代任务开发的分支，日常开发原则上都在此分支上面，迭代完成后合并到release分支，开发、发版两不误。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/47dee6fb94154ab0abf61abcdf37b3eb~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"></p><p><strong>✅其他开发分支：dev-xxx</strong>，开发人员可以针对模块自己创建本地分支，开发完成后合并到dev开发分支，然后删除本地分支。</p><h2 id="10-2、金屋藏娇stash"><a href="#10-2、金屋藏娇stash" class="headerlink" title="10.2、金屋藏娇stash"></a>10.2、金屋藏娇stash</h2><p>当你正在<code>dev</code>分支开发一个功能时，代码写了一半，突然有一个线上的bug急需要马上修改。<code>dev</code>分支Bug没写完，不方便提交，就不能切换到主分支去修复线上bug。Git提供一个<code>stash</code>功能，可以把当前<strong>工作区、暂存区</strong> 未提交的内容“隐藏”起来，就像什么都没发生一样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 有未提交修改，切换分支时报错</span></span><br><span class="line">$ git checkout dev</span><br><span class="line">error: Your <span class="built_in">local</span> changes to the following files would be overwritten by checkout:</span><br><span class="line">        README.md</span><br><span class="line">Please commit your changes or stash them before you switch branches.</span><br><span class="line">Aborting</span><br><span class="line"></span><br><span class="line"><span class="comment"># 隐藏</span></span><br><span class="line">$ git stash</span><br><span class="line">Saved working directory and index state WIP on main: 2bc012c s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看被隐藏的内容</span></span><br><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on main: 2bc012c s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较一下，什么都没有，一切都没有发生过！</span></span><br><span class="line">$ git diff</span><br><span class="line"></span><br><span class="line"><span class="comment"># 去其他分支修改bug，修复完成回到当前分支，恢复工作区</span></span><br><span class="line">$ git stash pop</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>在上面示例中，有未提交修改，切换分支时报错。错误提示信息很明确了，<code>commit</code>提交或<code>stash</code>隐藏：<code>Please commit your changes or stash them before you switch branches.</code></p><blockquote><p>📢 如果切换分支时，未提交修改的内容没有冲突，是可以成功切换的，未提交修改会被带过去。</p></blockquote><table><thead><tr><th><strong>指令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>git stash</td><td>把未提交内容隐藏起来，包括未暂存、已暂存。 等以后恢复现场后继续工作</td></tr><tr><td>git stash list</td><td>查看所有被隐藏的内容列表</td></tr><tr><td>git stash pop</td><td>恢复被隐藏的内容，同时删除隐藏记录</td></tr><tr><td>git stash save “message”</td><td>同<code>git stash</code>，可以备注说明<code>message</code></td></tr><tr><td>git stash apply</td><td>恢复被隐藏的文件，但是隐藏记录不删除</td></tr><tr><td>git stash drop</td><td>删除隐藏记录</td></tr></tbody></table><blockquote><p>🪧当然这里先提交到本地也是可以的，只是提交不是一个完整的功能代码，而是残缺的一部分，影响也不大。</p></blockquote><h2 id="拣选提交cherry-pick"><a href="#拣选提交cherry-pick" class="headerlink" title="拣选提交cherry-pick"></a>拣选提交cherry-pick</h2><p>当有一个紧急bug，在<code>dev</code>上修复完，我们需要把<code>dev</code>上的这个bug修复所做的修改“复制”到<code>master</code>分支，但不想把整个dev合并过去。为了方便操作，Git专门提供了一个<code>cherry-pick</code>命令，让我们能复制一个特定的提交到当前分支，而不管这个提交在哪个分支。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe43365ecea04a0b843ed23e79a77936~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image"></p><p>如上图，操作过程相当于将该提交导出为补丁文件，然后在当前<code>HEAD</code>上重放，形成无论内容还是提交说明都一致的提交。</p><ul><li>希望把<code>dev</code>分支上的<code>v7</code>提交的内容合并到<code>master</code>，但不需要其他的内容。</li><li>在<code>master</code>分支上执行指令<code>git cherry-pick v7</code>，会产生一个新的<code>v7&#39;</code>提交，内容和<code>v7</code>相同。</li><li>同时更新<code>master</code>、<code>HEAD</code>，以及工作区。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 选择一个commit，合并进当前分支</span></span><br><span class="line">$ git cherry-pick [commit]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://link.juejin.cn/?target=https://www.cnblogs.com/syp172654682/p/7689328.html">博客园 | 深入浅出Git教程</a></li><li><a href="https://link.juejin.cn/?target=https://backlog.com/git-tutorial/cn/">猴子都能懂的GIT入门</a></li><li><a href="https://link.juejin.cn/?target=https://www.liaoxuefeng.com/wiki/896043488029600">廖雪峰的GIT教程</a></li><li>电子书《<a href="https://link.juejin.cn/?target=https://www.yuque.com/kanding/ktech/ng8w19">ProGit-Git教程</a>》</li><li>Gitee码云的 <a href="https://link.juejin.cn/?target=https://gitee.com/all-about-git">Git 大全</a>，真的挺全</li><li><a href="https://link.juejin.cn/?target=https://www.processon.com/view/59ec836de4b0c86d400e99f1">敏捷过程实践-git代码分支管理规范</a></li><li><a href="https://link.juejin.cn/?target=https://www.yiibai.com/git">易百教程-Git教程</a>？</li><li><a href="https://link.juejin.cn/?target=https://learngitbranching.js.org">在线Git学习+练习</a></li><li><a href="https://link.juejin.cn/?target=https://git-scm.com/downloads/guis">GUI Clients</a> Git网站上的GUI工具列表</li><li><a href="https://link.juejin.cn/?target=https://www.yuque.com/kanding/ktech/ai3d3ky8f0dgixto">Git常用指令集合🔥🔥</a></li></ul><hr><blockquote><p><strong>©️版权申明</strong>：版权所有@安木夕，本文内容仅供学习，欢迎指正、交流，转载请注明出处！<a href="https://link.juejin.cn/?target=https://www.yuque.com/kanding/ktech/ccgylqhnb94ug4bu"><em>原文编辑地址-语雀</em></a></p></blockquote><p>分类：</p><p><a href="https://juejin.cn/freebie">开发工具</a></p><p>标签：</p><p><a href="https://juejin.cn/tag/Git">Git</a><a href="https://juejin.cn/tag/%E6%8E%98%E9%87%91%C2%B7%E9%87%91%E7%9F%B3%E8%AE%A1%E5%88%92">掘金·金石计划</a></p><p>文章被收录于专栏：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/95414745836549ce9143753e2a30facd~tplv-k3u1fbpfcp-no-mark:160:160:160:120.awebp" alt="cover"></p><p>开发工具-效率</p><p>提升效率的各种开发工具</p><p>订阅专栏</p><p><a href="https://juejin.cn/extension/?utm_source=standalone&utm_medium=post&utm_campaign=extension_promotion">安装掘金浏览器插件</a></p><p>多内容聚合浏览、多引擎快捷搜索、多工具便捷提效、多模式随心畅享，你想要的，这里都有！</p><p><a href="https://juejin.cn/extension/?utm_source=standalone&utm_medium=post&utm_campaign=extension_promotion">前往安装</a></p><p>相关小册</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/11/27/15ffbb05174a57f8~tplv-t2oaga2asx-no-mark:420:420:300:420.awebp" alt="「Git 原理详解及实用指南」封面"></p><p>VIP</p><p> Git 原理详解及实用指南</p><p><a href="https://juejin.cn/user/2524134386185736">扔物线<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2fa3f08a7107485f81157b296fd9d41f~tplv-k3u1fbpfcp-no-mark:0:0:0:0.awebp" alt="lv-5"></a></p><p>8506购买</p><p>¥14.95</p><p>¥29.9</p><p>首单券后价</p><p>首单券后价</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37d63d614f1b4b8dbd3b34a5c5d721d9~tplv-k3u1fbpfcp-no-mark:420:420:300:420.awebp" alt="「Neovim 配置实战：从0到1打造自己的IDE」封面"></p><p>VIP</p><p> Neovim 配置实战：从0到1打造自己的IDE</p><p><a href="https://juejin.cn/user/1873223543167326">nshen<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad1d5b8ec0974b0bbc14446acdd7c20d~tplv-k3u1fbpfcp-no-mark:0:0:0:0.awebp" alt="lv-2"></a></p><p>2195购买</p><p>¥14.95</p><p>¥29.9</p><p>首单券后价</p><p>首单券后价</p><p>评论</p><p><img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/58aaf1326ac763d8a1054056f3b7f2ef.svg" alt="img"></p><p>看完啦，</p><p>登录</p><p>分享一下感受吧～</p><p>全部评论 19</p><p>最新</p><p>最热</p><p><a href="https://juejin.cn/user/4213787849670392"><img src="https://p3-passport.byteimg.com/img/user-avatar/6448e794cf8def0c3cdbdc3006bc6697~100x100.awebp" alt="潘十亿的头像"></a></p><p><a href="https://juejin.cn/user/4213787849670392">潘十亿<img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/69eb0ad2f93abf938e832fe53b979c10.svg" alt="掘友等级"><img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/7467fc326521e91a50af0d354572dccc.svg" alt="img"></a></p><p>4天前</p><p>比较全面了</p><p>点赞</p><p>回复</p><p><a href="https://juejin.cn/user/453456960426999"><img src="https://p3-passport.byteimg.com/img/mosaic-legacy/3793/3131589739~100x100.awebp" alt="CharlieMa的头像"></a></p><p><a href="https://juejin.cn/user/453456960426999">CharlieMa<img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/65a6a28f15d70e5a77bf881c5ec5340d.svg" alt="掘友等级"></a></p><p>10天前</p><p>写的不错<img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/img/jj_emoji_3.41d9a9a.png" alt="[色]"></p><p>点赞</p><p>回复</p><p><a href="https://juejin.cn/user/2656887169365367"><img src="https://p3-passport.byteimg.com/img/mosaic-legacy/3795/3044413937~100x100.awebp" alt="用户4500200659905的头像"></a></p><p><a href="https://juejin.cn/user/2656887169365367">用户4500200659905<img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/8c6985e2aa4c06f307ae3734da4b43ac.svg" alt="掘友等级"></a></p><p>28天前</p><p>拿什么工具画的图啊</p><p>点赞</p><p>1</p><p><a href="https://juejin.cn/user/2120322602780935"><img src="https://p3-passport.byteimg.com/img/user-avatar/4f97c321b2f9df11757da519625aac4d~100x100.awebp" alt="img"></a></p><p><a href="https://juejin.cn/user/2120322602780935">安木夕</a></p><p>（作者）28天前</p><p>文末附有原文编辑地址，语雀的编辑器里有画图工具</p><p>点赞</p><p>回复</p><p><a href="https://juejin.cn/user/4275318344650605"><img src="https://p3-passport.byteimg.com/img/user-avatar/87a9e4e33c9e196b58a439497ffbe6ca~100x100.awebp" alt="PlutoOfCharon的头像"></a></p><p><a href="https://juejin.cn/user/4275318344650605">PlutoOfCharon<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a4dbd8a81a84d599442ef1095e35bab~tplv-k3u1fbpfcp-no-mark:0:0:0:0.awebp" alt="lv-1"><img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/70f1e5e3a2fde62e0d623009ab80cb12.svg" alt="掘友等级"></a></p><p>大三 @ npu1月前</p><p>nice 很强</p><p>1</p><p>1</p><p><a href="https://juejin.cn/user/2120322602780935"><img src="https://p3-passport.byteimg.com/img/user-avatar/4f97c321b2f9df11757da519625aac4d~100x100.awebp" alt="img"></a></p><p><a href="https://juejin.cn/user/2120322602780935">安木夕</a></p><p>（作者）1月前</p><p><img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/img/jj_emoji_10.42a731c.png" alt="[吃瓜群众]"></p><p>点赞</p><p>回复</p><p><a href="https://juejin.cn/user/1556564197246989"><img src="https://p3-passport.byteimg.com/img/user-avatar/dadbe1ef6beead8ced3271c54b8857d3~100x100.awebp" alt="卧龙傲天的头像"></a></p><p><a href="https://juejin.cn/user/1556564197246989">卧龙傲天<img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/7042b5a0cda0d030ddfdd1fdd14f8049.svg" alt="掘友等级"></a></p><p>自我介绍一下：我和我分开的很远。 @ 话唠，心情好一天能发100条。1月前</p><p>6</p><p>点赞</p><p>回复</p><p><a href="https://juejin.cn/user/2594503171517742"><img src="https://p3-passport.byteimg.com/img/user-avatar/c0bd0afdef482a94df25fa6536704d11~100x100.awebp" alt="前端anglus的头像"></a></p><p><a href="https://juejin.cn/user/2594503171517742">前端anglus<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad1d5b8ec0974b0bbc14446acdd7c20d~tplv-k3u1fbpfcp-no-mark:0:0:0:0.awebp" alt="lv-2"><img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/cf19b122213ebdbd25b66f02500b8c27.svg" alt="掘友等级"></a></p><p>啥都干工程师 @ To全栈1月前</p><p>可</p><p>点赞</p><p>回复</p><p><a href="https://juejin.cn/user/2911162519791080"><img src="https://p3-passport.byteimg.com/img/user-avatar/77ff5ff15d971d639eede766ab66001e~100x100.awebp" alt="fitcong的头像"></a></p><p><a href="https://juejin.cn/user/2911162519791080">fitcong<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a4dbd8a81a84d599442ef1095e35bab~tplv-k3u1fbpfcp-no-mark:0:0:0:0.awebp" alt="lv-1"><img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/70f1e5e3a2fde62e0d623009ab80cb12.svg" alt="掘友等级"><img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/ffdbad884aa0e7884cbcf924226df6ce.svg" alt="img"></a></p><p>前端 @ 怕丢公司人1月前</p><p>很nice</p><p>1</p><p>1</p><p><a href="https://juejin.cn/user/2120322602780935"><img src="https://p3-passport.byteimg.com/img/user-avatar/4f97c321b2f9df11757da519625aac4d~100x100.awebp" alt="img"></a></p><p><a href="https://juejin.cn/user/2120322602780935">安木夕</a></p><p>（作者）1月前</p><p><img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/img/jj_emoji_120.6c3effe.png" alt="[抱拳]"></p><p>点赞</p><p>回复</p><p><a href="https://juejin.cn/user/3227821871216135"><img src="https://p3-passport.byteimg.com/img/user-avatar/97c33e9e4e89d8e15b1f87c98f7435ca~100x100.awebp" alt="MrBai的头像"></a></p><p><a href="https://juejin.cn/user/3227821871216135">MrBai<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad1d5b8ec0974b0bbc14446acdd7c20d~tplv-k3u1fbpfcp-no-mark:0:0:0:0.awebp" alt="lv-2"><img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/cf19b122213ebdbd25b66f02500b8c27.svg" alt="掘友等级"></a></p><p>1月前</p><p>学习学习</p><p>1</p><p>回复</p><p><a href="https://juejin.cn/user/17231267252679"><img src="https://p3-passport.byteimg.com/img/user-avatar/494038ecbb196f34c49ec3d43f2f4746~100x100.awebp" alt="糖墨夕的头像"></a></p><p><a href="https://juejin.cn/user/17231267252679">糖墨夕<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05be64d75fee4dbdb290ba23afd21fcf~tplv-k3u1fbpfcp-no-mark:0:0:0:0.awebp" alt="lv-4"><img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/70f1e5e3a2fde62e0d623009ab80cb12.svg" alt="掘友等级"></a></p><p>FE @ NestJS1月前</p><p>哥，写得不错，一起加油下，看我主页的三篇Git都没给我推流<img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/img/jj_emoji_85.43ad2fc.png" alt="[泪奔]"></p><p>1</p><p>1</p><p><a href="https://juejin.cn/user/2120322602780935"><img src="https://p3-passport.byteimg.com/img/user-avatar/4f97c321b2f9df11757da519625aac4d~100x100.awebp" alt="img"></a></p><p><a href="https://juejin.cn/user/2120322602780935">安木夕</a></p><p>（作者）1月前</p><p>互推一个</p><p>点赞</p><p>回复</p><p><a href="https://juejin.cn/user/888061126511720"><img src="https://p3-passport.byteimg.com/img/user-avatar/1886491a3fcfb034690394c43cb8f96c~100x100.awebp" alt="蝉沐风的头像"></a></p><p><a href="https://juejin.cn/user/888061126511720">蝉沐风<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2fa3f08a7107485f81157b296fd9d41f~tplv-k3u1fbpfcp-no-mark:0:0:0:0.awebp" alt="lv-5"><img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/cf19b122213ebdbd25b66f02500b8c27.svg" alt="掘友等级"></a></p><p><a href="http://www.chanmufeng.com1月前/">www.chanmufeng.com1月前</a></p><p>在博客园和掘金都给你点赞了</p><p>1</p><p>3</p><p><a href="https://juejin.cn/user/2120322602780935"><img src="https://p3-passport.byteimg.com/img/user-avatar/4f97c321b2f9df11757da519625aac4d~100x100.awebp" alt="img"></a></p><p><a href="https://juejin.cn/user/2120322602780935">安木夕</a></p><p>（作者）1月前</p><p><img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/img/jj_emoji_120.6c3effe.png" alt="[抱拳]"></p><p>点赞</p><p>回复</p><p><a href="https://juejin.cn/user/2863564825830743"><img src="https://p3-passport.byteimg.com/img/user-avatar/3deb5275dc3f02b15fa050dccbce7c98~100x100.awebp" alt="img"></a></p><p><a href="https://juejin.cn/user/2863564825830743">zhang66</a></p><p>回复</p><p><a href="https://juejin.cn/user/2120322602780935">安木夕</a></p><p>1月前</p><p>感谢大神的分享<img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/img/jj_emoji_3.41d9a9a.png" alt="[色]"></p><p>“</p><p><img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/img/jj_emoji_120.6c3effe.png" alt="[抱拳]"></p><p>”</p><p>1</p><p>回复</p><p>查看更多回复</p><p><a href="https://juejin.cn/user/3620047225629853"><img src="https://p3-passport.byteimg.com/img/mosaic-legacy/3791/5070639578~100x100.awebp" alt="不要codeing的头像"></a></p><p><a href="https://juejin.cn/user/3620047225629853">不要codeing<img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/65a6a28f15d70e5a77bf881c5ec5340d.svg" alt="掘友等级"></a></p><p>1月前</p><p>很完整，mark</p><p>1</p><p>1</p><p><a href="https://juejin.cn/user/2120322602780935"><img src="https://p3-passport.byteimg.com/img/user-avatar/4f97c321b2f9df11757da519625aac4d~100x100.awebp" alt="img"></a></p><p><a href="https://juejin.cn/user/2120322602780935">安木夕</a></p><p>（作者）1月前</p><p><img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/img/jj_emoji_1.7d9f699.png" alt="[微笑]"></p><p>点赞</p><p>回复</p><p>相关推荐</p><p><a href="https://juejin.cn/user/2084329777010894">程序员乔戈里</a></p><p>3年前</p><p><a href="https://juejin.cn/tag/Java">Java</a></p><p><a href="https://juejin.cn/post/6844904036873814023">美团面试官问我一个字符的String.length()是多少，我说是1，面试官说你回去好好学一下吧</a></p><ul><li><p>24.2w</p></li><li><p>791</p></li><li><p>246</p></li></ul><p><a href="https://juejin.cn/user/2981531265821416">杰出D</a></p><p>1年前</p><p><a href="https://juejin.cn/tag/%E5%89%8D%E7%AB%AF">前端</a><a href="https://juejin.cn/tag/%E7%AE%97%E6%B3%95">算法</a></p><p><a href="https://juejin.cn/post/6983904373508145189">面试了十几个高级前端，竟然连（扁平数据结构转Tree）都写不出来</a></p><ul><li><p>28.2w</p></li><li><p>3972</p></li><li><p>2030</p></li></ul><p><a href="https://juejin.cn/user/4283353031252967">浪里行舟</a></p><p>4年前</p><p><a href="https://juejin.cn/tag/JavaScript">JavaScript</a><a href="https://juejin.cn/tag/%E5%89%8D%E7%AB%AF">前端</a></p><p><a href="https://juejin.cn/post/6844903767226351623">九种跨域方式实现原理（完整版）</a></p><ul><li><p>17.5w</p></li><li><p>3188</p></li><li><p>134</p></li></ul><p><a href="https://juejin.cn/user/3544481220801815">CUGGZ</a></p><p>1年前</p><p><a href="https://juejin.cn/tag/%E9%9D%A2%E8%AF%95">面试</a></p><p><a href="https://juejin.cn/post/6996841019094335519">金九银十，你准备好面试了吗? (附30w字前端面试题总结)</a></p><ul><li><p>7.6w</p></li><li><p>1073</p></li><li><p>55</p></li></ul><p><a href="https://juejin.cn/user/360295545973597">呛再首</a></p><p>8月前</p><p><a href="https://juejin.cn/tag/%E5%89%8D%E7%AB%AF">前端</a><a href="https://juejin.cn/tag/TypeScript">TypeScript</a></p><p><a href="https://juejin.cn/post/7124117404187099172">2022年了，我才开始学 typescript ，晚吗？（7.5k字总结）</a></p><ul><li><p>12.0w</p></li><li><p>2591</p></li><li><p>258</p></li></ul><p><a href="https://juejin.cn/user/958429870963207">陌小路</a></p><p>7月前</p><p><a href="https://juejin.cn/tag/%E5%89%8D%E7%AB%AF">前端</a><a href="https://juejin.cn/tag/Git">Git</a><a href="https://juejin.cn/tag/%E9%9D%A2%E8%AF%95">面试</a></p><p><a href="https://juejin.cn/post/7131713973572861966">女朋友说 Git 玩不明白，怎么办？安排！</a></p><ul><li><p>7.6w</p></li><li><p>1741</p></li><li><p>234</p></li></ul><p><a href="https://juejin.cn/user/430664257382462">神三元</a></p><p>3年前</p><p><a href="https://juejin.cn/tag/JavaScript">JavaScript</a><a href="https://juejin.cn/tag/%E9%9D%A2%E8%AF%95">面试</a></p><p><a href="https://juejin.cn/post/6844904100035821575">（建议精读）HTTP灵魂之问，巩固你的 HTTP 知识体系</a></p><ul><li><p>22.7w</p></li><li><p>4849</p></li><li><p>188</p></li></ul><p><a href="https://juejin.cn/user/589812812228408">一起去看星星吧</a></p><p>11月前</p><p><a href="https://juejin.cn/tag/%E5%89%8D%E7%AB%AF">前端</a></p><p><a href="https://juejin.cn/post/7092415149809598500">ts保姆级教程，别再说你不会ts了</a></p><ul><li><p>9.3w</p></li><li><p>2103</p></li><li><p>204</p></li></ul><p><a href="https://juejin.cn/user/2330620350432110">JowayYoung</a></p><p>3年前</p><p><a href="https://juejin.cn/tag/JavaScript">JavaScript</a>[ECMAScript 6](<a href="https://juejin.cn/tag/ECMAScript">https://juejin.cn/tag/ECMAScript</a> 6)</p><p><a href="https://juejin.cn/post/6844903959283367950">1.5万字概括ES6全部特性(已更新ES2020)</a></p><ul><li><p>23.2w</p></li><li><p>5951</p></li><li><p>235</p></li></ul><p><a href="https://juejin.cn/user/2330620350708823">ssh_晨曦时梦见兮</a></p><p>3年前</p><p><a href="https://juejin.cn/tag/JavaScript">JavaScript</a><a href="https://juejin.cn/tag/%E9%9D%A2%E8%AF%95">面试</a></p><p><a href="https://juejin.cn/post/6844904115428917255">写给女朋友的中级前端面试秘籍（含详细答案，15k级别）</a></p><ul><li><p>23.8w</p></li><li><p>3495</p></li><li><p>225</p></li></ul><p><a href="https://juejin.cn/user/1292681403180136">一袋米要扛几楼</a></p><p>7月前</p><p><a href="https://juejin.cn/tag/%E5%89%8D%E7%AB%AF">前端</a><a href="https://juejin.cn/tag/Git">Git</a><a href="https://juejin.cn/tag/JavaScript">JavaScript</a></p><p><a href="https://juejin.cn/post/7133045617877581831">【讲真!】Git进阶精选看这篇就够了</a></p><ul><li><p>7.1w</p></li><li><p>1024</p></li><li><p>175</p></li></ul><p><a href="https://juejin.cn/user/8451825870263">我z</a></p><p>3年前</p><p><a href="https://juejin.cn/tag/%E9%9D%A2%E8%AF%95">面试</a></p><p><a href="https://juejin.cn/post/6844903976693940231">web前端面试总结(自认为还算全面哈哈哈哈哈！！！！）</a></p><ul><li><p>24.2w</p></li><li><p>2239</p></li><li><p>123</p></li></ul><p><a href="https://juejin.cn/user/325111174926350">杨村长</a></p><p>10月前</p><p><a href="https://juejin.cn/tag/%E5%89%8D%E7%AB%AF">前端</a><a href="https://juejin.cn/tag/%E9%9D%A2%E8%AF%95">面试</a><a href="https://juejin.cn/tag/Vue.js">Vue.js</a></p><p><a href="https://juejin.cn/post/7097067108663558151">历时一个月，2.6W字！50+Vue经典面试题源码级详解，你值得收藏！</a></p><ul><li><p>9.9w</p></li><li><p>2408</p></li><li><p>164</p></li></ul><p><a href="https://juejin.cn/user/3544481220801815">CUGGZ</a></p><p>2年前</p><p><a href="https://juejin.cn/tag/%E9%9D%A2%E8%AF%95">面试</a><a href="https://juejin.cn/tag/%E5%89%8D%E7%AB%AF">前端</a></p><p><a href="https://juejin.cn/post/6940945178899251230">「2021」高频前端面试题汇总之JavaScript篇（上）</a></p><ul><li><p>47.4w</p></li><li><p>2938</p></li><li><p>116</p></li></ul><p><a href="https://juejin.cn/user/1838039171859662">秋天不落叶</a></p><p>3年前</p><p><a href="https://juejin.cn/tag/React.js">React.js</a></p><p><a href="https://juejin.cn/post/6844903985338400782">React Hooks 详解 【近 1W 字】+ 项目实战</a></p><ul><li><p>15.6w</p></li><li><p>2801</p></li><li><p>107</p></li></ul><p><a href="https://juejin.cn/user/2348212566372104">零零水</a></p><p>3年前</p><p><a href="https://juejin.cn/tag/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6">前端框架</a><a href="https://juejin.cn/tag/%E5%89%8D%E7%AB%AF">前端</a><a href="https://juejin.cn/tag/%E6%9E%B6%E6%9E%84">架构</a></p><p><a href="https://juejin.cn/post/6844903853859536903">大型项目前端架构浅谈（8000字原创）</a></p><ul><li><p>17.2w</p></li><li><p>4422</p></li><li><p>306</p></li></ul><p><a href="https://juejin.cn/user/1275089188039917">你听___</a></p><p>4年前</p><p><a href="https://juejin.cn/tag/Git">Git</a><a href="https://juejin.cn/tag/GitHub">GitHub</a><a href="https://juejin.cn/tag/%E5%90%8E%E7%AB%AF">后端</a></p><p><a href="https://juejin.cn/post/6844903598522908686">git基本操作，一篇文章就够了！</a></p><ul><li><p>10.2w</p></li><li><p>1475</p></li><li><p>39</p></li></ul><p><a href="https://juejin.cn/user/3368559354851470">嘟嘟MD</a></p><p>5年前</p><p><a href="https://juejin.cn/tag/Java">Java</a><a href="https://juejin.cn/tag/maven">maven</a></p><p><a href="https://juejin.cn/post/6844903543711907848">Maven入门，读完这篇就够了</a></p><ul><li><p>8.7w</p></li><li><p>470</p></li><li><p>12</p></li></ul><p><a href="https://juejin.cn/user/1327865774742830">黄小虫</a></p><p>3年前</p><p><a href="https://juejin.cn/tag/JavaScript">JavaScript</a></p><p><a href="https://juejin.cn/post/6844904031240863758">2020年了,再不会webpack敲得代码就不香了(近万字实战)</a></p><ul><li><p>18.3w</p></li><li><p>4659</p></li><li><p>393</p></li></ul><p><a href="https://juejin.cn/user/307518985747774">Wizey</a></p><p>4年前</p><p><a href="https://juejin.cn/tag/%E5%90%8E%E7%AB%AF">后端</a><a href="https://juejin.cn/tag/Debug">Debug</a><a href="https://juejin.cn/tag/Python">Python</a></p><p><a href="https://juejin.cn/post/6844903692915703815">Python日志库logging总结-可能是目前为止将logging库总结的最好的一篇文章</a></p><ul><li><p>31.2w</p></li><li><p>179</p></li><li><p>16</p></li></ul><p><a href="https://juejin.cn/user/2120322602780935"><img src="https://p3-passport.byteimg.com/img/user-avatar/4f97c321b2f9df11757da519625aac4d~100x100.awebp" alt="img"></a></p><p><a href="https://juejin.cn/user/2120322602780935">安木夕<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05be64d75fee4dbdb290ba23afd21fcf~tplv-k3u1fbpfcp-no-mark:0:0:0:0.awebp" alt="lv-4"></a></p><p>IT•软件工程•代码开发 @ 成都-广州</p><p>关注<a href="https://juejin.cn/notification/im?participantId=2120322602780935">私信</a></p><p>获得点赞 572</p><p>文章被阅读 159,142</p><p>- </p><p><a href="https://juejin.cn/user/center/signin?from=item"><img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/img/sign-in.d6891e5.png" alt="限时领掘金会员"></a></p><p>相关文章</p><p><a href="https://juejin.cn/post/7203512643238232123">金三银四来了-找工作有哪些平台&#x2F;工具？52点赞 · 16评论</a><a href="https://juejin.cn/post/7189076751920660537">程序猿健康防猝指南4：常见医药疾病知识35点赞 · 2评论</a><a href="https://juejin.cn/post/7179407872923533370">注意看，她叫小美，在地址栏输入URL地址后发生了什么？16点赞 · 8评论</a><a href="https://juejin.cn/post/7182374196108853306">程序猿健康防猝指南1：体重和减肥的秘密38点赞 · 13评论</a><a href="https://juejin.cn/post/7188341138883870775">程序猿健康防猝指南3：健康保健18点赞 · 5评论</a></p><p>目录</p><ul><li><a href="https://juejin.cn/post/7195030726096453690#heading-0">01、认识一下Git！—简介</a></li><li><a href="https://juejin.cn/post/7195030726096453690#heading-1">02、Git是干什么的？—基础概念</a><ul><li><a href="https://juejin.cn/post/7195030726096453690#heading-2">2.1、Git概念汇总🔥</a></li><li><a href="https://juejin.cn/post/7195030726096453690#heading-3">2.2、工作区&#x2F;暂存区&#x2F;仓库</a></li><li><a href="https://juejin.cn/post/7195030726096453690#heading-4">2.3、Git基本流程（图）</a></li><li><a href="https://juejin.cn/post/7195030726096453690#heading-5">2.4、Git状态（图）</a></li></ul></li><li><a href="https://juejin.cn/post/7195030726096453690#heading-6">03、起步：Git安装配置</a><ul><li><a href="https://juejin.cn/post/7195030726096453690#heading-7">3.1、Git的配置文件</a></li><li><a href="https://juejin.cn/post/7195030726096453690#heading-8">3.2、配置-初始化用户</a></li><li><a href="https://juejin.cn/post/7195030726096453690#heading-9">3.3、配置-忽略.gitignore</a></li></ul></li><li><a href="https://juejin.cn/post/7195030726096453690#heading-10">04、Git的GUI工具们</a><ul><li><a href="https://juejin.cn/post/7195030726096453690#heading-11">4.1、SourceTree</a></li><li><a href="https://juejin.cn/post/7195030726096453690#heading-12">4.2、TortoiseGit</a></li><li><a href="https://juejin.cn/post/7195030726096453690#heading-13">4.3、VSCode中的Git</a></li></ul></li><li><a href="https://juejin.cn/post/7195030726096453690#heading-14">05、Git使用入门</a><ul><li><a href="https://juejin.cn/post/7195030726096453690#heading-15">5.1、创建仓库</a></li><li><a href="https://juejin.cn/post/7195030726096453690#heading-16">5.2、暂存区add</a></li><li><a href="https://juejin.cn/post/7195030726096453690#heading-17">5.3、提交commit-记录</a></li><li><a href="https://juejin.cn/post/7195030726096453690#heading-18">5.4、Git的“指针”引用们</a></li><li><a href="https://juejin.cn/post/7195030726096453690#heading-19">5.5、提交的唯一标识id，HEAD~n是什么意思？</a></li><li><a href="https://juejin.cn/post/7195030726096453690#heading-20">5.6、比较diff</a></li></ul></li><li><a href="https://juejin.cn/post/7195030726096453690#heading-21">06、远程仓库</a><ul><li><a href="https://juejin.cn/post/7195030726096453690#heading-22">6.1、远程用户登录</a><ul><li><a href="https://juejin.cn/post/7195030726096453690#heading-23">🔑远程用户登录：HTTS</a></li><li><a href="https://juejin.cn/post/7195030726096453690#heading-24">🔑远程用户登录：SSH</a></li></ul></li><li><a href="https://juejin.cn/post/7195030726096453690#heading-25">6.2、远程仓库指令🔥</a></li><li><a href="https://juejin.cn/post/7195030726096453690#heading-26">6.3、推送push&#x2F;拉取pull</a></li><li><a href="https://juejin.cn/post/7195030726096453690#heading-27">6.4、fetch与pull有什么不同？</a></li></ul></li><li><a href="https://juejin.cn/post/7195030726096453690#heading-28">07、Git利器-分支</a><ul><li><a href="https://juejin.cn/post/7195030726096453690#heading-29">7.1、分支Branch</a></li><li><a href="https://juejin.cn/post/7195030726096453690#heading-30">7.2、分支指令🔥</a></li><li><a href="https://juejin.cn/post/7195030726096453690#heading-31">7.3、分支的切换checkout</a></li><li><a href="https://juejin.cn/post/7195030726096453690#heading-32">7.4、合并merge&amp;冲突</a><ul><li><a href="https://juejin.cn/post/7195030726096453690#heading-33">🔸快速合并（Fast forward）</a></li><li><a href="https://juejin.cn/post/7195030726096453690#heading-34">🔸普通合并</a></li><li><a href="https://juejin.cn/post/7195030726096453690#heading-35">🔸处理冲突&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</a></li></ul></li><li><a href="https://juejin.cn/post/7195030726096453690#heading-36">7.5、变基rebase</a></li></ul></li><li><a href="https://juejin.cn/post/7195030726096453690#heading-37">08、标签管理</a></li><li><a href="https://juejin.cn/post/7195030726096453690#heading-38">09、后悔药-怎么撤销变更？</a><ul><li><a href="https://juejin.cn/post/7195030726096453690#heading-39">9.1、后悔指令🔥</a></li><li><a href="https://juejin.cn/post/7195030726096453690#heading-40">9.2、回退版本reset</a></li><li><a href="https://juejin.cn/post/7195030726096453690#heading-41">9.3、撤销提交revert</a></li><li><a href="https://juejin.cn/post/7195030726096453690#heading-42">9.4、checkout&#x2F;reset&#x2F;revert总结</a></li></ul></li><li><a href="https://juejin.cn/post/7195030726096453690#heading-43">10、工作中的Git实践</a><ul><li><a href="https://juejin.cn/post/7195030726096453690#heading-44">10.1、Git flow</a></li><li><a href="https://juejin.cn/post/7195030726096453690#heading-45">10.2、金屋藏娇stash</a></li><li><a href="https://juejin.cn/post/7195030726096453690#heading-46">拣选提交cherry-pick</a></li></ul></li><li><a href="https://juejin.cn/post/7195030726096453690#heading-47">参考资料</a></li></ul><p>下一篇</p><hr><p><a href="https://juejin.cn/post/7181259757230129212">Git入门图文教程⑩-Git常用指令集合</a></p>]]></content>
      
      
      <categories>
          
          <category> -Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -标签6 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[/* 页脚与头图透明 */#footer {    background: transparent !important;  }  #page-header {    background: transparent !important;  }    /* 白天模式遮罩透明 */  #footer::before {    background: transparent !important;  }  #page-header::before {    background: transparent !important;  }    /* 夜间模式遮罩透明 */  [data-theme="dark"] #footer::before {    background: transparent !important;  }  [data-theme="dark"] #page-header::before {    background: transparent !important;  }  #body-wrap {    /* 背景图像的地址（url括号里）  */    background: url(https://dogefs.s3.ladydaily.com/~/source/wallhaven/full/1p/wallhaven-1pqe79.png?w=2560&h=1440&fmt=webp);    /* 背景图像不重复 */    background-repeat: no-repeat;    /* 背景图像大小 */    /* background-size: cover; */    background-size:100% 100%;    background-attachment: fixed;  }  /* 一级菜单居中 */#nav .menus_items {  position: absolute !important;  width: fit-content !important;  left: 50% !important;  transform: translateX(-50%) !important;}/* 子菜单横向展示 */#nav .menus_items .menus_item:hover .menus_item_child {  display: flex !important;}/* 这里的2是代表导航栏的第2个元素，即有子菜单的元素，可以按自己需求修改 */.menus_items .menus_item:nth-child(2) .menus_item_child {  left: -125px;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>留言板</title>
      <link href="/comments/index.html"/>
      <url>/comments/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>电影</title>
      <link href="/movie/index.html"/>
      <url>/movie/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>音乐</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>link</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
